window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "src.fairreckitlib", "modulename": "src.fairreckitlib", "type": "module", "doc": "<p>This package contains the FairRecKit recommender system API.</p>\n\n<p>Modules:</p>\n\n<pre><code>recommender_system: the top level API intended for use by applications.\n</code></pre>\n\n<p>Packages:</p>\n\n<pre><code>core: base functionality that is used in the other packages.\ndata: data(set) functionality with a data registry and a data pipeline.\nevaluation: rating result performance evaluation computations as a pipeline.\nexperiment: combined computations of the data, model and evaluation pipelines.\nmodel: algorithmic rating result computations as a model pipeline.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core", "modulename": "src.fairreckitlib.core", "type": "module", "doc": "<p>This package contains core functionality to be used in other packages.</p>\n\n<p>Modules:</p>\n\n<pre><code>core_constants: core constants that are used in other packages.\n</code></pre>\n\n<p>Packages:</p>\n\n<pre><code>config: classes that are used for yml (object) configuration.\nevents: event dispatching/listening behaviour.\nio: various functions for commonly used IO operations.\nparsing: base functionality for parsing configuration files.\npipeline: base class functionality for a pipeline.\nthreading: base class thread and processing threads.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.config", "modulename": "src.fairreckitlib.core.config", "type": "module", "doc": "<p>This package contains functionality for yml (object) configuration.</p>\n\n<p>Modules:</p>\n\n<pre><code>config_base_param: base configuration param classes.\nconfig_factories: (base) factory classes that are structured tree-like.\nconfig_object: base functionality for an object's name and parameters configuration.\nconfig_option_param: configuration option param implementations.\nconfig_parameters: configuration parameters container.\nconfig_value_param: configuration value param implementations.\nconfig_yml: base yml configuration class.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.config.config_base_param", "modulename": "src.fairreckitlib.core.config.config_base_param", "type": "module", "doc": "<p>This module contains functionality for base configuration parameters.</p>\n\n<p>Classes:</p>\n\n<pre><code>ConfigParam: base class for all parameters.\nConfigOptionParam: (base) parameter that can be a value from a known list of options.\nConfigValueParam: (base) parameter that can be a value between a minimum and maximum.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.config.config_base_param.ConfigParam", "modulename": "src.fairreckitlib.core.config.config_base_param", "qualname": "ConfigParam", "type": "class", "doc": "<p>Config Param base class.</p>\n\n<p>Public methods:</p>\n\n<p>to_dict\nvalidate_value</p>\n"}, {"fullname": "src.fairreckitlib.core.config.config_base_param.ConfigParam.__init__", "modulename": "src.fairreckitlib.core.config.config_base_param", "qualname": "ConfigParam.__init__", "type": "function", "doc": "<p>Construct the ConfigParam.</p>\n\n<p>Args:\n    name: the name of the parameter.\n    value_type: the type of the parameter.\n    default_value: the default value of the parameter.</p>\n", "signature": "(self, name: str, value_type: Type, default_value: Any)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_base_param.ConfigParam.to_dict", "modulename": "src.fairreckitlib.core.config.config_base_param", "qualname": "ConfigParam.to_dict", "type": "function", "doc": "<p>Get a dictionary describing the parameter.</p>\n\n<p>The dictionary should at least contains keys for the name\nand default value of the parameter.</p>\n\n<p>Returns:\n    the dictionary containing the parameter descriptions.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_base_param.ConfigParam.validate_value", "modulename": "src.fairreckitlib.core.config.config_base_param", "qualname": "ConfigParam.validate_value", "type": "function", "doc": "<p>Validate the specified value with the parameter.</p>\n\n<p>Derived implementations should at least check for type mismatch and None.</p>\n\n<p>Args:\n    value: the value to verify with the parameter.</p>\n\n<p>Returns:\n    whether it was successful, the validated value and (optional) message.</p>\n", "signature": "(self, value: Any) -> Tuple[bool, Any, str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_base_param.ConfigOptionParam", "modulename": "src.fairreckitlib.core.config.config_base_param", "qualname": "ConfigOptionParam", "type": "class", "doc": "<p>Config Option Parameter.</p>\n\n<p>The default_value and all the options are expected to be of the same value_type.\nThe default_value is expected to be present in the list of available options.</p>\n", "bases": "ConfigParam"}, {"fullname": "src.fairreckitlib.core.config.config_base_param.ConfigOptionParam.__init__", "modulename": "src.fairreckitlib.core.config.config_base_param", "qualname": "ConfigOptionParam.__init__", "type": "function", "doc": "<p>Construct the ConfigOptionParam.</p>\n\n<p>Args:\n    name: the name of the parameter.\n    value_type: the type of the parameter.\n    default_value: the default option of the parameter.\n    options: list of available options for the parameter.</p>\n", "signature": "(\n    self,\n    name: str,\n    value_type: Type,\n    default_value: Any,\n    options: List[Any]\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_base_param.ConfigOptionParam.to_dict", "modulename": "src.fairreckitlib.core.config.config_base_param", "qualname": "ConfigOptionParam.to_dict", "type": "function", "doc": "<p>Get a dictionary describing the option parameter.</p>\n\n<p>The dictionary contains keys for the name, default value\nand options of the parameter.</p>\n\n<p>Returns:\n    the dictionary containing the parameter descriptions.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_base_param.ConfigValueParam", "modulename": "src.fairreckitlib.core.config.config_base_param", "qualname": "ConfigValueParam", "type": "class", "doc": "<p>Config Value Parameter.</p>\n\n<p>The value_type of default_value and min_max_value types are all expected to be either\nint or float, conversions between the two during validation is available.\nThe default_value is expected to be between the min_max_value.\nThe min_max_value is expected to have min_value &lt;= max_value.</p>\n", "bases": "ConfigParam"}, {"fullname": "src.fairreckitlib.core.config.config_base_param.ConfigValueParam.__init__", "modulename": "src.fairreckitlib.core.config.config_base_param", "qualname": "ConfigValueParam.__init__", "type": "function", "doc": "<p>Construct the ConfigValueParam.</p>\n\n<p>Args:\n    name: the name of the parameter.\n    value_type: the type of the parameter.\n    default_value: the default value of the parameter.\n    min_max_value: tuple with the minimum and maximum value of the parameter.</p>\n", "signature": "(\n    self,\n    name: str,\n    value_type: Type,\n    default_value: Any,\n    min_max_value: Union[Tuple[int, int], Tuple[float, float]]\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_base_param.ConfigValueParam.to_dict", "modulename": "src.fairreckitlib.core.config.config_base_param", "qualname": "ConfigValueParam.to_dict", "type": "function", "doc": "<p>Get a dictionary describing the value parameter.</p>\n\n<p>The dictionary contains keys for the name, default value,\nminimum value and maximum value of the parameter.</p>\n\n<p>Returns:\n    the dictionary containing the parameter descriptions.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories", "modulename": "src.fairreckitlib.core.config.config_factories", "type": "module", "doc": "<p>This module contains the (base) factories that are used in other packages.</p>\n\n<p>Classes:</p>\n\n<pre><code>BaseFactory: base class for all factories.\nFactory: class that instantiates new objects (a leaf).\nGroupFactory: class that groups other factories (a branch).\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.config.config_factories.BaseFactory", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "BaseFactory", "type": "class", "doc": "<p>Base class for all FairRecKit experiment factories.</p>\n\n<p>The abstraction is intended to support functionality for a tree-like structure.\nThe actual factory is a leaf and a group of factories that belong together a branch.</p>\n\n<p>Public methods:</p>\n\n<p>get_available\nget_available_names\nget_name\nis_available</p>\n"}, {"fullname": "src.fairreckitlib.core.config.config_factories.BaseFactory.__init__", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "BaseFactory.__init__", "type": "function", "doc": "<p>Construct the base factory.</p>\n\n<p>Args:\n    factory_name: the name of the factory.</p>\n", "signature": "(self, factory_name: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.BaseFactory.get_available", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "BaseFactory.get_available", "type": "function", "doc": "<p>Get the available objects in the factory.</p>\n\n<p>The availability return type depends on the derived class.</p>\n", "signature": "(self) -> Any", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.BaseFactory.get_available_names", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "BaseFactory.get_available_names", "type": "function", "doc": "<p>Get the names that are available in the factory.</p>\n\n<p>Returns:\n    a list of names that is available.</p>\n", "signature": "(self) -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.BaseFactory.get_name", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "BaseFactory.get_name", "type": "function", "doc": "<p>Get the name of the factory.</p>\n\n<p>Returns:\n    the factory name.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.BaseFactory.get_num_entries", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "BaseFactory.get_num_entries", "type": "function", "doc": "<p>Get the number of entries present in the factory.</p>\n\n<p>Returns:\n    the amount of entries.</p>\n", "signature": "(self) -> int", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.BaseFactory.is_obj_available", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "BaseFactory.is_obj_available", "type": "function", "doc": "<p>Is the object with the specified name available.</p>\n\n<p>Args:\n    obj_name: the name of the object to query for availability.</p>\n\n<p>Returns:\n    whether the object is available.</p>\n", "signature": "(self, obj_name: str) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.Factory", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "Factory", "type": "class", "doc": "<p>The factory that implements object and parameters creation.</p>\n\n<p>Public methods:</p>\n\n<p>add_obj\ncreate\ncreate_params</p>\n", "bases": "BaseFactory"}, {"fullname": "src.fairreckitlib.core.config.config_factories.Factory.add_obj", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "Factory.add_obj", "type": "function", "doc": "<p>Add object with associated parameter creation to the factory.</p>\n\n<p>Parameter creation is optional and should be None if the object has no parameters.\nA key error is raised when the obj_name is present in the factory.</p>\n\n<p>Args:\n    obj_name: the name of the object\n    func_create_obj: the function that creates and returns a new object.\n    func_create_obj_params: the function that creates and returns the parameters\n        that are associated with a newly created object.</p>\n", "signature": "(\n    self,\n    obj_name: str,\n    func_create_obj: Callable[[str, Dict[str, Any]], Any],\n    func_create_obj_params: Callable[[], src.fairreckitlib.core.config.config_parameters.ConfigParameters] = None\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.Factory.create", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "Factory.create", "type": "function", "doc": "<p>Create and return a new object with the specified name.</p>\n\n<p>The specified parameters are expected to be of the same structure as the defaults\nof the ConfigParameters that are associated with the desired object. When no parameters\nare specified it will use the object's defaults.</p>\n\n<p>Args:\n    obj_name: the name of the object to create.\n    obj_params: the parameters of the object.</p>\n\n<p>Keyword Args:\n    Any: extra arguments that need to be passed to the object on creation.</p>\n", "signature": "(self, obj_name: str, obj_params: Dict[str, Any] = None, **kwargs) -> Any", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.Factory.create_params", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "Factory.create_params", "type": "function", "doc": "<p>Create parameters for the object with the specified name.</p>\n\n<p>Args:\n    obj_name: name of the object to create parameters for.</p>\n\n<p>Returns:\n    the configuration parameters of the object or empty parameters when it does not exist.</p>\n", "signature": "(\n    self,\n    obj_name: str\n) -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.Factory.get_available", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "Factory.get_available", "type": "function", "doc": "<p>Get the availability of all object names and their parameters.</p>\n\n<p>override\nEach object in the factory has a name and parameters that consists of\na dictionary with name-value pairs.</p>\n\n<p>Returns:\n    a list of dictionary entries that includes the name and the parameters.</p>\n", "signature": "(self) -> List[Dict[str, Dict[str, Any]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.Factory.is_obj_available", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "Factory.is_obj_available", "type": "function", "doc": "<p>Is the object with the specified name available.</p>\n\n<p>Checks the object for existing in this factory.</p>\n\n<p>Args:\n    obj_name: the name of the object to query for availability.</p>\n\n<p>Returns:\n    whether the object is available.</p>\n", "signature": "(self, obj_name: str) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.GroupFactory", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "GroupFactory", "type": "class", "doc": "<p>The factory that groups other factories together.</p>\n\n<p>Public methods:</p>\n\n<p>add_factory\nget_factory\nget_sub_availability</p>\n", "bases": "BaseFactory"}, {"fullname": "src.fairreckitlib.core.config.config_factories.GroupFactory.add_factory", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "GroupFactory.add_factory", "type": "function", "doc": "<p>Add the specified factory to the group.</p>\n\n<p>The name of the factory is used as the key, and thus it will raise a\nKeyError when the name of the factory already exists in the group.</p>\n\n<p>Args:\n    factory: to add to the group.</p>\n", "signature": "(\n    self,\n    factory: src.fairreckitlib.core.config.config_factories.BaseFactory\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.GroupFactory.get_available", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "GroupFactory.get_available", "type": "function", "doc": "<p>Get the availability of all factories in the group.</p>\n\n<p>override</p>\n\n<p>Each factory has a name and availability that depends on the\ntype of the factory. Effectively this will generate a tree-like\nstructure of the factory's availability.</p>\n\n<p>Returns:\n    a dictionary with factory name and availability pairs.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.GroupFactory.get_factory", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "GroupFactory.get_factory", "type": "function", "doc": "<p>Get the factory with the specified name.</p>\n\n<p>Args:\n    factory_name: the name of the factory to retrieve</p>\n\n<p>Returns:\n    the requested factory or None when not available.</p>\n", "signature": "(\n    self,\n    factory_name: str\n) -> src.fairreckitlib.core.config.config_factories.BaseFactory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.GroupFactory.get_sub_availability", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "GroupFactory.get_sub_availability", "type": "function", "doc": "<p>Get the sub availability from the factory with the specified name (and type).</p>\n\n<p>Args:\n    sub_factory_name: the name of the sub-factory to query for availability.\n    sub_type: the subtype of the sub-factory to query for availability or None\n        for the complete availability.</p>\n\n<p>Returns:\n    a dictionary containing the availability of the sub-factory (type).</p>\n", "signature": "(self, sub_factory_name: str, sub_type: str = None) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.GroupFactory.is_obj_available", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "GroupFactory.is_obj_available", "type": "function", "doc": "<p>Is the object with the specified name available.</p>\n\n<p>Checks the object for existing in any of the child factories.</p>\n\n<p>Args:\n    obj_name: the name of the object to query for availability.</p>\n\n<p>Returns:\n    whether the object is available.</p>\n", "signature": "(self, obj_name: str) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_factories.create_factory_from_list", "modulename": "src.fairreckitlib.core.config.config_factories", "qualname": "create_factory_from_list", "type": "function", "doc": "<p>Create and return the factory with the specified tuple entries.</p>\n\n<p>Each tuple in the list consists of three things; the name of the object,\nthe object creation function and the parameter creation function.</p>\n\n<p>Args:\n    factory_name: the name of the factory to create.\n    obj_tuple_list: a list of object tuples to add after factory creation.</p>\n\n<p>Returns:\n    the factory with the added objects.</p>\n", "signature": "(\n    factory_name: str,\n    obj_tuple_list: List[Tuple[str, Callable[[str, Dict[str, Any]], Any], Callable[[], src.fairreckitlib.core.config.config_parameters.ConfigParameters]]]\n) -> src.fairreckitlib.core.config.config_factories.Factory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_object", "modulename": "src.fairreckitlib.core.config.config_object", "type": "module", "doc": "<p>This module contains the base functionality for an object's configuration.</p>\n\n<p>Classes:</p>\n\n<pre><code>ObjectConfig: base class configuration for an object with a name and parameters.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>object_config_list_to_yml_format: convert list of ObjectConfig's to a yml format.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.config.config_object.ObjectConfig", "modulename": "src.fairreckitlib.core.config.config_object", "qualname": "ObjectConfig", "type": "class", "doc": "<p>Base Object Configuration.</p>\n\n<p>name: the name of the object.\nparams: the parameters of the object.</p>\n", "bases": "src.fairreckitlib.core.config.config_yml.YmlConfig"}, {"fullname": "src.fairreckitlib.core.config.config_object.ObjectConfig.__init__", "modulename": "src.fairreckitlib.core.config.config_object", "qualname": "ObjectConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, name: str, params: Dict[str, Any])", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_object.ObjectConfig.to_yml_format", "modulename": "src.fairreckitlib.core.config.config_object", "qualname": "ObjectConfig.to_yml_format", "type": "function", "doc": "<p>Format object configuration to a yml compatible dictionary.</p>\n\n<p>Returns:\n    a dictionary containing the object configuration.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_option_param", "modulename": "src.fairreckitlib.core.config.config_option_param", "type": "module", "doc": "<p>This module contains functionality for configuration option parameters.</p>\n\n<p>Classes:</p>\n\n<pre><code>ConfigSingleOptionParam: parameter that can be a single value from a known list of options.\nConfigMultiOptionParam: parameter that can be multiple values from a known list of options.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_bool_param: create boolean option parameter.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.config.config_option_param.ConfigMultiOptionParam", "modulename": "src.fairreckitlib.core.config.config_option_param", "qualname": "ConfigMultiOptionParam", "type": "class", "doc": "<p>Config Multi Option Parameter.</p>\n\n<p>The default_value and all the options are expected to be strings.\nThe default_value list is expected to have at least one entry.\nThe default_value list is expected to be present in the list of available options.</p>\n", "bases": "src.fairreckitlib.core.config.config_base_param.ConfigOptionParam"}, {"fullname": "src.fairreckitlib.core.config.config_option_param.ConfigMultiOptionParam.__init__", "modulename": "src.fairreckitlib.core.config.config_option_param", "qualname": "ConfigMultiOptionParam.__init__", "type": "function", "doc": "<p>Construct the ConfigMultiOptionParam.</p>\n\n<p>Args:\n    name: the name of the parameter.\n    default_value: the default option(s) of the parameter.\n    options: list of available options for the parameter.</p>\n", "signature": "(self, name: str, default_value: List[str], options: List[str])", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_option_param.ConfigMultiOptionParam.validate_value", "modulename": "src.fairreckitlib.core.config.config_option_param", "qualname": "ConfigMultiOptionParam.validate_value", "type": "function", "doc": "<p>Validate the specified value with the parameter.</p>\n\n<p>Checks for None, type mismatch, duplicates and if the value is one of the allowed options.</p>\n\n<p>Args:\n    value: the list of options to verify with the parameter.</p>\n\n<p>Returns:\n    whether it was successful, the validated value and (optional) message.</p>\n", "signature": "(self, value: Any) -> Tuple[bool, List[str], str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_option_param.ConfigSingleOptionParam", "modulename": "src.fairreckitlib.core.config.config_option_param", "qualname": "ConfigSingleOptionParam", "type": "class", "doc": "<p>Config Single Option Parameter.</p>\n\n<p>The default_value and all the options are expected to be either strings or booleans.\nThe default_value is expected to be present in the list of available options.\nThe options list is expected to have unique values.</p>\n", "bases": "src.fairreckitlib.core.config.config_base_param.ConfigOptionParam"}, {"fullname": "src.fairreckitlib.core.config.config_option_param.ConfigSingleOptionParam.__init__", "modulename": "src.fairreckitlib.core.config.config_option_param", "qualname": "ConfigSingleOptionParam.__init__", "type": "function", "doc": "<p>Construct the ConfigOptionParam.</p>\n\n<p>Args:\n    name: the name of the parameter.\n    value_type: the type of the parameter.\n    default_value: the default option of the parameter.\n    options: list of available options for the parameter.</p>\n", "signature": "(\n    self,\n    name: str,\n    value_type: Type,\n    default_value: Union[str, bool],\n    options: Union[List[str], List[bool]]\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_option_param.ConfigSingleOptionParam.validate_value", "modulename": "src.fairreckitlib.core.config.config_option_param", "qualname": "ConfigSingleOptionParam.validate_value", "type": "function", "doc": "<p>Validate the specified value with the parameter.</p>\n\n<p>Checks for None, type mismatch and if the value is one of the allowed options.</p>\n\n<p>Args:\n    value: the option to verify with the parameter.</p>\n\n<p>Returns:\n    whether it was successful, the validated value and (optional) message.</p>\n", "signature": "(self, value: Any) -> Tuple[bool, Union[str, bool], str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_option_param.create_bool_param", "modulename": "src.fairreckitlib.core.config.config_option_param", "qualname": "create_bool_param", "type": "function", "doc": "<p>Create a boolean option parameter.</p>\n\n<p>Args:\n    name: the name of the boolean parameter.\n    default_value: the default boolean value.</p>\n\n<p>Returns:\n    the boolean parameter.</p>\n", "signature": "(\n    name: str,\n    default_value: bool\n) -> src.fairreckitlib.core.config.config_option_param.ConfigSingleOptionParam", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters", "modulename": "src.fairreckitlib.core.config.config_parameters", "type": "module", "doc": "<p>This module contains a container of configuration parameters.</p>\n\n<p>Classes:</p>\n\n<pre><code>ConfigParameters: container that stores multiple ConfigParam's.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_empty_parameters: create parameters with no entries.\ncreate_params_random_seed: create configuration with only a random seed parameter.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.ConfigParameters", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "ConfigParameters", "type": "class", "doc": "<p>Config Parameters.</p>\n\n<p>Container with varying Config parameters using a dictionary.\nMoreover, he added option/value parameters are stored separately.</p>\n\n<p>Public methods:</p>\n\n<p>add_bool\nadd_multi_option\nadd_single_option\nadd_number\nadd_random_seed\nadd_range\nget_defaults\nget_num_params\nget_param\nget_param_names\nto_dict</p>\n"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.ConfigParameters.__init__", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "ConfigParameters.__init__", "type": "function", "doc": "<p>Construct the ConfigParameters.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.ConfigParameters.add_bool", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "ConfigParameters.add_bool", "type": "function", "doc": "<p>Add a boolean parameter.</p>\n\n<p>Sugar for an option parameter that is either True or False.\nRaises a KeyError when the name of the parameter is already present.</p>\n\n<p>Args:\n      name: name of the boolean parameter.\n      default_value: the default boolean value.</p>\n", "signature": "(self, name: str, default_value: bool) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.ConfigParameters.add_multi_option", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "ConfigParameters.add_multi_option", "type": "function", "doc": "<p>Add a multi option parameter.</p>\n\n<p>The default_value and all the options are expected to be strings.\nThe default_value list is expected to have at least one entry.\nThe default_value list is expected to be present in the list of available options.\nRaises a KeyError when the name of the parameter is already present.</p>\n\n<p>Args:\n    name: the name of the parameter.\n    default_value: the default option(s) of the parameter.\n    options: list of available options for the parameter.</p>\n", "signature": "(self, name: str, default_value: List[str], options: List[str]) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.ConfigParameters.add_single_option", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "ConfigParameters.add_single_option", "type": "function", "doc": "<p>Add a single option parameter.</p>\n\n<p>The default_value and all the options are expected to be strings.\nThe default_value is expected to be present in the list of available options.\nThe options list is expected to have unique values.\nRaises a KeyError when the name of the parameter is already present.</p>\n\n<p>Args:\n    name: the name of the parameter.\n    value_type:  the type of the parameter.\n    default_option: default option of the parameter.\n    options: list of available options for the parameter.</p>\n", "signature": "(\n    self,\n    name: str,\n    value_type: Type,\n    default_option: str,\n    options: List[str]\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.ConfigParameters.add_number", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "ConfigParameters.add_number", "type": "function", "doc": "<p>Add a number parameter.</p>\n\n<p>The value_type of default_value and min_max_value types are all expected to be either\nint or float, conversions between the two during validation is available.\nThe default value is expected to be between the min_max_value.\nThe min_max_value is expected to have min_value &lt;= max_value.\nRaises a KeyError when the name of the parameter is already present.</p>\n\n<p>Args:\n    name: the name of the parameter.\n    value_type: the type of the parameter.\n    default_value: the default value of the parameter.\n    min_max_value: tuple with the minimum and maximum value of the parameter.</p>\n", "signature": "(\n    self,\n    name: str,\n    value_type: Type,\n    default_value: Union[int, float],\n    min_max_value: Union[Tuple[int, int], Tuple[float, float]]\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.ConfigParameters.add_random_seed", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "ConfigParameters.add_random_seed", "type": "function", "doc": "<p>Add a random seed parameter.</p>\n\n<p>An integer number parameter, where the default_value is None.\nRaises a KeyError when the name of the parameter is already present.</p>\n\n<p>Args:\n    name: the name of the random seed parameter.</p>\n", "signature": "(self, name: str) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.ConfigParameters.add_range", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "ConfigParameters.add_range", "type": "function", "doc": "<p>Add a range parameter.</p>\n\n<p>The value_type of default_value and min_max_value types are all expected to be either\nint or float, conversions between the two during validation is available.\nThe default_value min and max values are expected to be between the min_max_value.\nThe default_value and min_max_value are expected to have min_value &lt;= max_value.\nRaises a KeyError when the name of the parameter is already present.</p>\n\n<p>Args:\n    name: the name of the parameter.\n    value_type: the type of the parameter.\n    default_value: tuple with the default minimum and maximum value of the parameter.\n    min_max_value: tuple with the minimum and maximum value of the parameter.</p>\n", "signature": "(\n    self,\n    name: str,\n    value_type: Type,\n    default_value: Union[Tuple[int, int], Tuple[float, float]],\n    min_max_value: Union[Tuple[int, int], Tuple[float, float]]\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.ConfigParameters.get_defaults", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "ConfigParameters.get_defaults", "type": "function", "doc": "<p>Get the default values from all parameters.</p>\n\n<p>Returns:\n    a dictionary containing name-default pairs for all parameters.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.ConfigParameters.get_num_params", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "ConfigParameters.get_num_params", "type": "function", "doc": "<p>Get the number of parameters.</p>\n\n<p>Returns:\n    the parameter count.</p>\n", "signature": "(self) -> int", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.ConfigParameters.get_param", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "ConfigParameters.get_param", "type": "function", "doc": "<p>Get the parameter with the specified name.</p>\n\n<p>Returns:\n     the parameter on success or None on failure.</p>\n", "signature": "(\n    self,\n    param_name: str\n) -> Optional[src.fairreckitlib.core.config.config_base_param.ConfigParam]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.ConfigParameters.get_param_names", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "ConfigParameters.get_param_names", "type": "function", "doc": "<p>Get the names of all parameters.</p>\n\n<p>Returns:\n    a list of all parameter names.</p>\n", "signature": "(self) -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.ConfigParameters.to_dict", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "ConfigParameters.to_dict", "type": "function", "doc": "<p>Get a dictionary describing all the parameters.</p>\n\n<p>The parameters in the dictionary are stored separately:\n    PARAM_KEY_OPTIONS: list of all option parameter descriptions.\n    PARAM_KEY_VALUES: list of all value parameter descriptions.</p>\n\n<p>Returns:\n    a dictionary containing the parameters' descriptions.</p>\n", "signature": "(self) -> Dict[str, List[Dict[str, Any]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.ConfigParameters.add_param", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "ConfigParameters.add_param", "type": "function", "doc": "<p>Add a parameter to the internal dictionary.</p>\n\n<p>This function is only used internally by the parameters,\nuse the other add functions instead.\nRaises a KeyError when the name of the parameter is already present.</p>\n\n<p>Args:\n    param: the parameter to add.</p>\n", "signature": "(\n    self,\n    param: src.fairreckitlib.core.config.config_base_param.ConfigParam\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.create_empty_parameters", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "create_empty_parameters", "type": "function", "doc": "<p>Create the Config parameters with no entries.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_parameters.create_params_random_seed", "modulename": "src.fairreckitlib.core.config.config_parameters", "qualname": "create_params_random_seed", "type": "function", "doc": "<p>Create the configuration with only the random 'seed' parameter.</p>\n\n<p>Returns:\n    the configuration parameters with one parameter: 'seed'.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_value_param", "modulename": "src.fairreckitlib.core.config.config_value_param", "type": "module", "doc": "<p>This module contains functionality for configuration value parameters.</p>\n\n<p>Classes:</p>\n\n<pre><code>ConfigNumberParam: parameter that can be a number between a minimum and maximum.\nConfigRandomParam: parameter that can be used to pick the (optional) random seed.\nConfigRangeParam: parameter that can be a range between a minimum and maximum.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>validate_min_max:\nvalidate_type:\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.config.config_value_param.ConfigNumberParam", "modulename": "src.fairreckitlib.core.config.config_value_param", "qualname": "ConfigNumberParam", "type": "class", "doc": "<p>Config Number Parameter.</p>\n\n<p>The value_type of default_value and min_max_value types are all expected to be either\nint or float, conversions between the two during validation is available.\nThe default_value is expected to be between the min_max_value.\nThe min_max_value is expected to have min_value &lt;= max_value.</p>\n", "bases": "src.fairreckitlib.core.config.config_base_param.ConfigValueParam"}, {"fullname": "src.fairreckitlib.core.config.config_value_param.ConfigNumberParam.__init__", "modulename": "src.fairreckitlib.core.config.config_value_param", "qualname": "ConfigNumberParam.__init__", "type": "function", "doc": "<p>Construct the ConfigNumberParam.</p>\n\n<p>Args:\n    name: the name of the parameter.\n    value_type: the type of the parameter.\n    default_value: the default value of the parameter.\n    min_max_value: tuple with the minimum and maximum value of the parameter.</p>\n", "signature": "(\n    self,\n    name: str,\n    value_type: Type,\n    default_value: Union[int, float],\n    min_max_value: Union[Tuple[int, int], Tuple[float, float]]\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_value_param.ConfigNumberParam.validate_value", "modulename": "src.fairreckitlib.core.config.config_value_param", "qualname": "ConfigNumberParam.validate_value", "type": "function", "doc": "<p>Validate the specified value with the parameter.</p>\n\n<p>Checks for None, type mismatch (conversion between int and float is allowed) and if\nthe value is between the minimum and maximum value of the parameter.</p>\n\n<p>Args:\n    value: the number to verify with the parameter.</p>\n\n<p>Returns:\n    whether it was successful, the validated value and (optional) message.</p>\n", "signature": "(self, value: Any) -> Tuple[bool, Union[int, float], str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_value_param.ConfigRandomParam", "modulename": "src.fairreckitlib.core.config.config_value_param", "qualname": "ConfigRandomParam", "type": "class", "doc": "<p>Config Random Parameter.</p>\n", "bases": "ConfigNumberParam"}, {"fullname": "src.fairreckitlib.core.config.config_value_param.ConfigRandomParam.__init__", "modulename": "src.fairreckitlib.core.config.config_value_param", "qualname": "ConfigRandomParam.__init__", "type": "function", "doc": "<p>Construct the ConfigRandomParam.</p>\n\n<p>Args:\n    name: the name of the random seed parameter.</p>\n", "signature": "(self, name: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_value_param.ConfigRandomParam.validate_value", "modulename": "src.fairreckitlib.core.config.config_value_param", "qualname": "ConfigRandomParam.validate_value", "type": "function", "doc": "<p>Validate the specified value with the parameter.</p>\n\n<p>Checks are the same as ConfigNumberParam.validate_value, but None is allowed.</p>\n\n<p>Args:\n    value: the random seed to verify with the parameter.</p>\n\n<p>Returns:\n    whether it was successful, the validated value and (optional) message.</p>\n", "signature": "(self, value: Any) -> Tuple[bool, Optional[int], str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_value_param.ConfigRangeParam", "modulename": "src.fairreckitlib.core.config.config_value_param", "qualname": "ConfigRangeParam", "type": "class", "doc": "<p>Config Range Parameter.</p>\n\n<p>The value_type of default_value and min_max_value types are all expected to be either\nint or float, conversions between the two during validation is available.\nThe default_value min and max values are expected to be between the min_max_value.\nThe default_value and min_max_value are expected to have min_value &lt;= max_value.</p>\n", "bases": "src.fairreckitlib.core.config.config_base_param.ConfigValueParam"}, {"fullname": "src.fairreckitlib.core.config.config_value_param.ConfigRangeParam.__init__", "modulename": "src.fairreckitlib.core.config.config_value_param", "qualname": "ConfigRangeParam.__init__", "type": "function", "doc": "<p>Construct the ConfigRangeParam.</p>\n\n<p>Args:\n    name: the name of the parameter.\n    value_type: the type of the parameter.\n    default_value: tuple with the default minimum and maximum value of the parameter.\n    min_max_value: tuple with the minimum and maximum value of the parameter.</p>\n", "signature": "(\n    self,\n    name: str,\n    value_type: Type,\n    default_value: Union[Tuple[int, int], Tuple[float, float]],\n    min_max_value: Union[Tuple[int, int], Tuple[float, float]]\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_value_param.ConfigRangeParam.validate_value", "modulename": "src.fairreckitlib.core.config.config_value_param", "qualname": "ConfigRangeParam.validate_value", "type": "function", "doc": "<p>Validate the specified value with the parameter.</p>\n\n<p>Checks for None, type mismatch (conversion between int and float is allowed) and if\nthe min-max range is between the minimum and maximum value of the parameter.</p>\n\n<p>Args:\n    value: the min-max range dictionary to verify with the parameter.</p>\n\n<p>Returns:\n    whether it was successful, the validated value and (optional) message.</p>\n", "signature": "(self, value: Any) -> Tuple[bool, Dict[str, Union[int, float]], str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_value_param.ConfigRangeParam.validate_dict", "modulename": "src.fairreckitlib.core.config.config_value_param", "qualname": "ConfigRangeParam.validate_dict", "type": "function", "doc": "<p>Validate the specified value to a min-max range dictionary.</p>\n\n<p>Args:\n    value: the min-max range dictionary to validate.</p>\n\n<p>Returns:\n    whether it was successful, the validated dictionary and (optional) message.</p>\n", "signature": "(self, value: Any) -> Tuple[bool, Dict[str, Any], str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_value_param.validate_min_max", "modulename": "src.fairreckitlib.core.config.config_value_param", "qualname": "validate_min_max", "type": "function", "doc": "<p>Validate the value with the specified min- and max-value.</p>\n\n<p>Args:\n    value_name: the name associated with the value.\n    value: the value to validate.\n    min_value: the minimum value to use for validation.\n    max_value: the maximum value to use for validation.</p>\n\n<p>Returns:\n    whether it was successful, the validated value and (optional) message.</p>\n", "signature": "(\n    value_name: str,\n    value: Union[int, float],\n    min_value: Union[int, float],\n    max_value: Union[int, float]\n) -> Tuple[bool, Union[int, float], str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_value_param.validate_type", "modulename": "src.fairreckitlib.core.config.config_value_param", "qualname": "validate_type", "type": "function", "doc": "<p>Validate the value to be of the correct type.</p>\n\n<p>Conversion between int/float is allowed and will return True, but\nwith the optional message that the value was cast to the correct value_type.</p>\n\n<p>Args:\n    value_name: the name associated with the value.\n    value: the value to validate the type of.\n    value_type: the type of the value.\n    default_value: the default value to return on invalidation.</p>\n\n<p>Returns:\n    whether it was successful, the validated value and (optional) message.</p>\n", "signature": "(\n    value_name: str,\n    value: Any,\n    value_type: Type,\n    default_value: Union[int, float]\n) -> Tuple[bool, Union[int, float], str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_yml", "modulename": "src.fairreckitlib.core.config.config_yml", "type": "module", "doc": "<p>This module contains the base functionality for an object's configuration.</p>\n\n<p>Classes:</p>\n\n<pre><code>YmlConfig: base class configuration that is compatible with an yml format.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>format_yml_config_dict: convert dict of YmlConfig's to an yml format.\nformat_yml_config_list: convert list of YmlConfig's to an yml format.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.config.config_yml.YmlConfig", "modulename": "src.fairreckitlib.core.config.config_yml", "qualname": "YmlConfig", "type": "class", "doc": "<p>Base YML Configuration.</p>\n"}, {"fullname": "src.fairreckitlib.core.config.config_yml.YmlConfig.to_yml_format", "modulename": "src.fairreckitlib.core.config.config_yml", "qualname": "YmlConfig.to_yml_format", "type": "function", "doc": "<p>Format configuration to a yml compatible dictionary.</p>\n\n<p>Returns:\n    a dictionary containing the configuration.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_yml.format_yml_config_dict", "modulename": "src.fairreckitlib.core.config.config_yml", "qualname": "format_yml_config_dict", "type": "function", "doc": "<p>Format yml configuration dictionary.</p>\n\n<p>Returns:\n    a list containing the yml configuration's.</p>\n", "signature": "(\n    yml_configs: Dict[str, src.fairreckitlib.core.config.config_yml.YmlConfig]\n) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.config.config_yml.format_yml_config_list", "modulename": "src.fairreckitlib.core.config.config_yml", "qualname": "format_yml_config_list", "type": "function", "doc": "<p>Format yml configuration list to a yml compatible list.</p>\n\n<p>Returns:\n    a list containing the yml configuration's.</p>\n", "signature": "(\n    yml_configs: List[src.fairreckitlib.core.config.config_yml.YmlConfig]\n) -> List[Dict[str, Any]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.core_constants", "modulename": "src.fairreckitlib.core.core_constants", "type": "module", "doc": "<p>This module contains configuration constants that are used in other packages.</p>\n\n<p>Constants:</p>\n\n<pre><code>ELLIOT_API: name of the Elliot API.\nIMPLICIT_API: name of the Implicit API.\nLENSKIT_API: name of the LensKit API.\nREXMEX_API: name of the Rexmex API.\nSURPRISE_API: name of the Surprise API.\n\nKEY_NAME: the key that is used for a name.\nKEY_PARAMS: the key that is used for params.\nKEY_TYPE: the key that is used for types.\n\nTYPE_PREDICTION: the prediction experiment type.\nTYPE_RECOMMENDATION: the recommender experiment type.\n\nVALID_TYPES: the valid experiment types.\n\nKEY_TOP_K: the key that is used for top k.\nKEY_RATED_ITEMS_FILTER: the key that is used for the rated items filter.\n\nDEFAULT_TOP_K: the default top k for recommender experiments.\nDEFAULT_RATED_ITEMS_FILTER: the default rated items filter for recommender experiments.\n\nMODEL_USER_BATCH_SIZE: the batch size of users that is used when model computations are done.\nMODEL_RATINGS_FILE: the file that is used to store the computed model ratings.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.events", "modulename": "src.fairreckitlib.core.events", "type": "module", "doc": "<p>This package contains functionality for event dispatching/listening behaviour.</p>\n\n<p>Modules:</p>\n\n<pre><code>event_args: (base) class for event arguments.\nevent_dispatcher: class that can dispatch events to listeners.\nevent_error: event ids, event args and a print switch that are error related.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.events.event_args", "modulename": "src.fairreckitlib.core.events.event_args", "type": "module", "doc": "<p>This module contains the base event arguments dataclasses.</p>\n\n<p>Classes:</p>\n\n<pre><code>EventArgs: base event args for all events.\nMessageEventArgs: event args that has a message.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.events.event_args.EventArgs", "modulename": "src.fairreckitlib.core.events.event_args", "qualname": "EventArgs", "type": "class", "doc": "<p>Base Event Arguments.</p>\n\n<p>Event arguments classes are allowed to be shared for different event ids.</p>\n\n<p>event_id: the unique ID that classifies the event.</p>\n"}, {"fullname": "src.fairreckitlib.core.events.event_args.EventArgs.__init__", "modulename": "src.fairreckitlib.core.events.event_args", "qualname": "EventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, event_id: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.events.event_args.MessageEventArgs", "modulename": "src.fairreckitlib.core.events.event_args", "qualname": "MessageEventArgs", "type": "class", "doc": "<p>Message Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the message event.\nmessage: the message.</p>\n", "bases": "EventArgs"}, {"fullname": "src.fairreckitlib.core.events.event_args.MessageEventArgs.__init__", "modulename": "src.fairreckitlib.core.events.event_args", "qualname": "MessageEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, event_id: str, message: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.events.event_dispatcher", "modulename": "src.fairreckitlib.core.events.event_dispatcher", "type": "module", "doc": "<p>This module contains a class that implements dispatcher/listener behaviour.</p>\n\n<p>Classes:</p>\n\n<pre><code>EventDispatcher: can dispatch an event to the respectively subscribed listeners.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.events.event_dispatcher.EventDispatcher", "modulename": "src.fairreckitlib.core.events.event_dispatcher", "qualname": "EventDispatcher", "type": "class", "doc": "<p>Event Dispatcher provides tools to communicate events to listeners.</p>\n\n<p>The dispatcher is a centralized object that keeps track of all registered listeners\nfor a specified event ID. These listeners can be added and removed dynamically.</p>\n\n<p>Public methods:</p>\n\n<p>add_listener\nget_num_listeners\nget_num_listeners_total\nremove_listener\ndispatch</p>\n"}, {"fullname": "src.fairreckitlib.core.events.event_dispatcher.EventDispatcher.__init__", "modulename": "src.fairreckitlib.core.events.event_dispatcher", "qualname": "EventDispatcher.__init__", "type": "function", "doc": "<p>Construct the EventDispatcher.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.events.event_dispatcher.EventDispatcher.add_listener", "modulename": "src.fairreckitlib.core.events.event_dispatcher", "qualname": "EventDispatcher.add_listener", "type": "function", "doc": "<p>Add a listener for the specified event ID.</p>\n\n<p>The event_listener and func_on_event are joined as a tuple to describe the listener\nand is expected to be unique. The listener will be notified by the dispatcher\nevery time that the event arguments with the specified ID is propagated.\nThis function raises a KeyError when the listener tuple already exists.</p>\n\n<p>Args:\n    event_id: unique ID that classifies the event.\n    event_listener: the listener of the event. This object is passed to\n        the event callback function as the first argument when the event is dispatched.\n    func_on_event: the callback functions that are called when the event\n        is dispatched. The first argument is the event_listener, followed by event args.\n        and any keyword args</p>\n", "signature": "(\n    self,\n    event_id: str,\n    event_listener: Any,\n    func_on_event: Tuple[Callable[[Any, src.fairreckitlib.core.events.event_args.EventArgs], NoneType], Optional[Callable[[Any, src.fairreckitlib.core.events.event_args.EventArgs], NoneType]]]\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.events.event_dispatcher.EventDispatcher.get_num_listeners", "modulename": "src.fairreckitlib.core.events.event_dispatcher", "qualname": "EventDispatcher.get_num_listeners", "type": "function", "doc": "<p>Get the amount of listeners for the specified event id.</p>\n\n<p>Args:\n    event_id: the event id to query the number of listeners of.</p>\n\n<p>Returns:\n    the number of listeners of the event or None when the event is not registered.</p>\n", "signature": "(self, event_id: str) -> Optional[int]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.events.event_dispatcher.EventDispatcher.get_num_listeners_total", "modulename": "src.fairreckitlib.core.events.event_dispatcher", "qualname": "EventDispatcher.get_num_listeners_total", "type": "function", "doc": "<p>Get the total amount of listeners for the dispatcher.</p>\n\n<p>Returns:\n    the number of listeners in total.</p>\n", "signature": "(self) -> int", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.events.event_dispatcher.EventDispatcher.remove_listener", "modulename": "src.fairreckitlib.core.events.event_dispatcher", "qualname": "EventDispatcher.remove_listener", "type": "function", "doc": "<p>Remove a listener for the specified event ID.</p>\n\n<p>The event_listener and func_on_event are joined as a tuple to describe the listener\nand is expected to be unique. The listener is also expected to be identical to the one\nthat was used in 'add_listener' and will no longer be notified by the dispatcher when the\nevent arguments with the specified ID is propagated.\nThis function raises a KeyError when either the event_id or listener tuple does not exist.</p>\n\n<p>Args:\n    event_id: unique ID that classifies the event.\n    event_listener: the listener of the event. This object is passed to\n        the event callback function as the first argument when the event is dispatched.\n    func_on_event: the callback functions that are called when the event\n        is dispatched. The first argument is the event_listener, followed by event args\n        and any keyword args.</p>\n", "signature": "(\n    self,\n    event_id: str,\n    event_listener: Any,\n    func_on_event: Tuple[Callable[[Any, src.fairreckitlib.core.events.event_args.EventArgs], NoneType], Optional[Callable[[Any, src.fairreckitlib.core.events.event_args.EventArgs], NoneType]]]\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.events.event_dispatcher.EventDispatcher.dispatch", "modulename": "src.fairreckitlib.core.events.event_dispatcher", "qualname": "EventDispatcher.dispatch", "type": "function", "doc": "<p>Dispatch event arguments with the corresponding event ID.</p>\n\n<p>The event arguments with the specified ID will be propagated to all registered listeners.\nFor each listener their respective callback function is called with the listener\nas the first argument, followed by the specified event args and keyword args.</p>\n\n<p>Args:\n    event_args: the event's arguments.</p>\n\n<p>Keyword Args:\n    Any: varies depending on the event.</p>\n\n<p>Returns:\n    whether the event was dispatched to any registered listeners.</p>\n", "signature": "(\n    self,\n    event_args: src.fairreckitlib.core.events.event_args.EventArgs,\n    **kwargs\n) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.events.event_error", "modulename": "src.fairreckitlib.core.events.event_error", "type": "module", "doc": "<p>This module contains all event ids, event args and a print switch that are error related.</p>\n\n<p>Constants:</p>\n\n<pre><code>ON_FAILURE_ERROR: id of the event that is used when a failure occurs.\nON_RAISE_ERROR: id of the event that is used when an error was raised.\n</code></pre>\n\n<p>Classes:</p>\n\n<pre><code>ErrorEventArgs: event args for errors.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>get_error_events: list of error event IDs.\nget_error_event_print_switch: switch to print error event arguments by ID.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.events.event_error.ErrorEventArgs", "modulename": "src.fairreckitlib.core.events.event_error", "qualname": "ErrorEventArgs", "type": "class", "doc": "<p>Error Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the error event.\nmessage: the error message.</p>\n", "bases": "src.fairreckitlib.core.events.event_args.MessageEventArgs"}, {"fullname": "src.fairreckitlib.core.events.event_error.ErrorEventArgs.__init__", "modulename": "src.fairreckitlib.core.events.event_error", "qualname": "ErrorEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, event_id: str, message: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.events.event_error.get_error_events", "modulename": "src.fairreckitlib.core.events.event_error", "qualname": "get_error_events", "type": "function", "doc": "<p>Get a list of error event IDs.</p>\n\n<p>Returns:\n    a list of unique error event IDs.</p>\n", "signature": "() -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.events.event_error.get_error_event_print_switch", "modulename": "src.fairreckitlib.core.events.event_error", "qualname": "get_error_event_print_switch", "type": "function", "doc": "<p>Get a switch that prints error event IDs.</p>\n\n<p>Returns:\n    the print error event switch.</p>\n", "signature": "(\n    \n) -> Dict[str, Callable[[src.fairreckitlib.core.events.event_error.ErrorEventArgs], NoneType]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io", "modulename": "src.fairreckitlib.core.io", "type": "module", "doc": "<p>This package contains functionality for commonly used IO operations.</p>\n\n<p>Modules:</p>\n\n<pre><code>event_io: event ids, event args and a print switch that are IO related.\nio_create: IO functions that create something on the disk and dispatch an IO event.\nio_delete: IO functions that delete something on the disk and dispatch an IO event.\nio_utility: IO utility functions that connect with external packages.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.io.event_io", "modulename": "src.fairreckitlib.core.io.event_io", "type": "module", "doc": "<p>This module contains all event ids, event args and a print switch that are IO related.</p>\n\n<p>Constants:</p>\n\n<pre><code>ON_MAKE_DIR: id of the event that is used when a directory is created.\nON_REMOVE_DIR: id of the event that is used when a directory is removed.\nON_CREATE_FILE: id of the event that is used when a file is created.\nON_REMOVE_FILE: id of the event that is used when a file is removed.\nON_RENAME_FILE: id of the event that is used when a file is renamed.\n</code></pre>\n\n<p>Classes:</p>\n\n<pre><code>DirEventArgs: event args related to a directory.\nFileEventArgs: event args related to a file.\nDataframeEventArgs: event args related to a dataframe.\nRenameFileEventArgs: event args related to renaming a file.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>get_io_events: list of IO event IDs.\nget_io_event_print_switch: switch to print IO event arguments by ID.\nprint_load_dataframe_event_args: print dataframe event arguments for loading.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.io.event_io.DirEventArgs", "modulename": "src.fairreckitlib.core.io.event_io", "qualname": "DirEventArgs", "type": "class", "doc": "<p>Directory Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the directory event.\ndirectory: the path to the directory.</p>\n", "bases": "src.fairreckitlib.core.events.event_args.EventArgs"}, {"fullname": "src.fairreckitlib.core.io.event_io.DirEventArgs.__init__", "modulename": "src.fairreckitlib.core.io.event_io", "qualname": "DirEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, event_id: str, directory: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.event_io.FileEventArgs", "modulename": "src.fairreckitlib.core.io.event_io", "qualname": "FileEventArgs", "type": "class", "doc": "<p>File Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the file event.\nfile_path: the path to the file.</p>\n", "bases": "src.fairreckitlib.core.events.event_args.EventArgs"}, {"fullname": "src.fairreckitlib.core.io.event_io.FileEventArgs.__init__", "modulename": "src.fairreckitlib.core.io.event_io", "qualname": "FileEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, event_id: str, file_path: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.event_io.DataframeEventArgs", "modulename": "src.fairreckitlib.core.io.event_io", "qualname": "DataframeEventArgs", "type": "class", "doc": "<p>Dataframe Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the dataframe event.\nfile_path: the path to the dataframe file.\ndataframe_name: the name of the dataframe.</p>\n", "bases": "FileEventArgs"}, {"fullname": "src.fairreckitlib.core.io.event_io.DataframeEventArgs.__init__", "modulename": "src.fairreckitlib.core.io.event_io", "qualname": "DataframeEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, event_id: str, file_path: str, dataframe_name: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.event_io.get_io_events", "modulename": "src.fairreckitlib.core.io.event_io", "qualname": "get_io_events", "type": "function", "doc": "<p>Get a list of IO event IDs.</p>\n\n<p>Returns:\n    a list of unique IO event IDs.</p>\n", "signature": "() -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.event_io.get_io_event_print_switch", "modulename": "src.fairreckitlib.core.io.event_io", "qualname": "get_io_event_print_switch", "type": "function", "doc": "<p>Get a switch that prints IO event IDs.</p>\n\n<p>Returns:\n    the print IO event switch.</p>\n", "signature": "(\n    \n) -> Dict[str, Callable[[src.fairreckitlib.core.events.event_args.EventArgs], NoneType]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.event_io.print_load_df_event_args", "modulename": "src.fairreckitlib.core.io.event_io", "qualname": "print_load_df_event_args", "type": "function", "doc": "<p>Print dataframe event arguments for loading.</p>\n\n<p>It is assumed that the event started when elapsed_time is None and is finished otherwise.</p>\n\n<p>Args:\n    event_args: the arguments to print.\n    elapsed_time: the time that has passed since the loading started, expressed in seconds.</p>\n", "signature": "(\n    event_args: src.fairreckitlib.core.io.event_io.DataframeEventArgs,\n    elapsed_time: float = None\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.io_create", "modulename": "src.fairreckitlib.core.io.io_create", "type": "module", "doc": "<p>This module contains IO functions that create something on the disk and dispatch an IO event.</p>\n\n<p>Functions:</p>\n\n<pre><code>create_dir: create a directory on the disk with IO event dispatching.\ncreate_json: create a json file on the disk with IO event dispatching.\ncreate_yml: create a yml file on the disk with event dispatching.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.io.io_create.create_dir", "modulename": "src.fairreckitlib.core.io.io_create", "qualname": "create_dir", "type": "function", "doc": "<p>Create the specified directory.</p>\n\n<p>This functions checks whether the directory exists and the\nevent is only dispatched when the directory did not exist yet.</p>\n\n<p>Args:\n    directory: the directory to create on the disk.\n    event_dispatcher: used to dispatch the IO event.</p>\n\n<p>Returns:\n    the directory path.</p>\n", "signature": "(\n    directory: str,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.io_create.create_json", "modulename": "src.fairreckitlib.core.io.io_create", "qualname": "create_json", "type": "function", "doc": "<p>Create a JSON file with the specified data.</p>\n\n<p>The IO event is dispatched after the file is created.</p>\n\n<p>Args:\n    file_path: path to where the json file will be stored.\n    data: the source dictionary to save in the file.\n    event_dispatcher: used to dispatch the IO event.\n    encoding: the encoding to use for writing the file contents.\n    indent: the indent level for pretty printing JSON array elements and object members.</p>\n", "signature": "(\n    file_path: str,\n    data: Dict,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher,\n    *,\n    encoding: str = 'utf-8',\n    indent=1\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.io_create.create_yml", "modulename": "src.fairreckitlib.core.io.io_create", "qualname": "create_yml", "type": "function", "doc": "<p>Create a YML file with the specified data.</p>\n\n<p>The IO event is dispatched after the file is created.</p>\n\n<p>Args:\n    file_path: path to where the json file will be stored.\n    data: the source dictionary to save in the file.\n    event_dispatcher: used to dispatch the IO event.\n    encoding: the encoding to use for writing the file contents.</p>\n", "signature": "(\n    file_path: str,\n    data: Dict,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher,\n    *,\n    encoding: str = 'utf-8'\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.io_delete", "modulename": "src.fairreckitlib.core.io.io_delete", "type": "module", "doc": "<p>This module contains IO functions that delete something on the disk and dispatch an IO event.</p>\n\n<p>Functions:</p>\n\n<pre><code>delete_dir: delete a directory, recursively, with IO event dispatching.\ndelete_file: delete a file from the disk with IO event dispatching.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.io.io_delete.delete_dir", "modulename": "src.fairreckitlib.core.io.io_delete", "qualname": "delete_dir", "type": "function", "doc": "<p>Delete the specified directory.</p>\n\n<p>This functions removes all the files and directories that are present\nin the specified directory path (recursively).\nThe IO event is dispatched after the directory and/or files are deleted.</p>\n\n<p>Args:\n    directory: the path to the directory to delete.\n    event_dispatcher: used to dispatch the IO event.</p>\n", "signature": "(\n    directory: str,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.io_delete.delete_file", "modulename": "src.fairreckitlib.core.io.io_delete", "qualname": "delete_file", "type": "function", "doc": "<p>Delete the specified file.</p>\n\n<p>The IO event is dispatched after the file is deleted.</p>\n\n<p>Args:\n    file_path: the path to the file to delete.\n    event_dispatcher: used to dispatch the IO event.</p>\n", "signature": "(\n    file_path: str,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.io_utility", "modulename": "src.fairreckitlib.core.io.io_utility", "type": "module", "doc": "<p>This module contains IO utility functions that connect with external packages.</p>\n\n<p>Functions:</p>\n\n<pre><code>load_array_from_hdf5: load array data from hdf5 file.\nload_json: load dictionary from json file.\nload_yml: load dictionary from yml file.\nsave_array_to_hdf5: save array data to hdf5 file.\nsave_json: save dictionary to json file.\nsave_yml: save dictionary to yml file.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.io.io_utility.load_array_from_hdf5", "modulename": "src.fairreckitlib.core.io.io_utility", "qualname": "load_array_from_hdf5", "type": "function", "doc": "<p>Load a single array from a HDF5 binary data file.</p>\n\n<p>This function raises a FileNotFoundError when the specified file does not exist.\nCounterpart of the save_array_to_hdf5 function.</p>\n\n<p>Args:\n    file_path: path to where the HDF5 file is stored.\n    array_name: name of the array to retrieve from the file.</p>\n\n<p>Returns:\n    the array data from the file.</p>\n", "signature": "(file_path: str, array_name: str) -> <built-in function array>", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.io_utility.load_json", "modulename": "src.fairreckitlib.core.io.io_utility", "qualname": "load_json", "type": "function", "doc": "<p>Load a json file.</p>\n\n<p>This function raises a FileNotFoundError when the specified file does not exist.\nCounterpart of the save_json function.</p>\n\n<p>Args:\n    file_path: path to where the json file is stored.\n    encoding: the encoding to use for reading the file contents.</p>\n\n<p>Returns:\n    the resulting dictionary.</p>\n", "signature": "(file_path: str, encoding: str = 'utf-8') -> Dict", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.io_utility.load_yml", "modulename": "src.fairreckitlib.core.io.io_utility", "qualname": "load_yml", "type": "function", "doc": "<p>Load a yml file.</p>\n\n<p>This function raises a FileNotFoundError when the specified file does not exist.\nCounterpart of the save_yml function.</p>\n\n<p>Args:\n    file_path: path to where the yml file is stored.\n    encoding: the encoding to use for reading the file contents.</p>\n\n<p>Returns:\n    the resulting dictionary.</p>\n", "signature": "(file_path: str, encoding: str = 'utf-8') -> Dict", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.io_utility.save_array_to_hdf5", "modulename": "src.fairreckitlib.core.io.io_utility", "qualname": "save_array_to_hdf5", "type": "function", "doc": "<p>Save a single array to a HDF5 binary data file.</p>\n\n<p>Counterpart of the load_array_from_hdf5 function.</p>\n\n<p>Args:\n    file_path: path to where the HDF5 file will be stored.\n    arr: the source array to save in the file.\n    array_name: name of the array to save in the file.</p>\n", "signature": "(file_path: str, arr: List[Any], array_name: str) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.io_utility.save_json", "modulename": "src.fairreckitlib.core.io.io_utility", "qualname": "save_json", "type": "function", "doc": "<p>Save a json file.</p>\n\n<p>Counterpart of the load_json function.</p>\n\n<p>Args:\n    file_path: path to where the json file will be stored.\n    data: the source dictionary to save in the file.\n    encoding: the encoding to use for writing the file contents.\n    indent: the indent level for pretty printing JSON array elements and object members.</p>\n", "signature": "(\n    file_path: str,\n    data: Dict,\n    *,\n    encoding: str = 'utf-8',\n    indent=None\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.io.io_utility.save_yml", "modulename": "src.fairreckitlib.core.io.io_utility", "qualname": "save_yml", "type": "function", "doc": "<p>Save a yml file.</p>\n\n<p>Counterpart of the load_yml function.</p>\n\n<p>Args:\n    file_path: path to where the yml file will be stored.\n    data: the source dictionary to save in the file.\n    encoding: the encoding to use for writing the file contents.</p>\n", "signature": "(file_path: str, data: Dict, *, encoding: str = 'utf-8') -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.parsing", "modulename": "src.fairreckitlib.core.parsing", "type": "module", "doc": "<p>This package contains base functionality for parsing configuration files.</p>\n\n<p>Modules:</p>\n\n<pre><code>parse_assert: parse functions in the form of commonly used assertions.\nparse_config_object: parse configuration object name and parameters.\nparse_config_params: parse configuration parameter(s).\nparse_event: event id, event args and a print function for a parse event.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.parsing.parse_assert", "modulename": "src.fairreckitlib.core.parsing.parse_assert", "type": "module", "doc": "<p>This module contains parsing functionality for commonly used assertions.</p>\n\n<p>Functions:</p>\n\n<pre><code>assert_is_container_not_empty: assert a container to have entries.\nassert_is_key_in_dict: assert a dictionary to have a key.\nassert_is_one_of_list: assert a value to be one of the values of a list.\nassert_is_type: assert a value to be of a certain type.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.parsing.parse_assert.assert_is_container_not_empty", "modulename": "src.fairreckitlib.core.parsing.parse_assert", "qualname": "assert_is_container_not_empty", "type": "function", "doc": "<p>Assert whether the specified container is not empty.</p>\n\n<p>Args:\n    src_container: the container to assert.\n    event_dispatcher: to dispatch the parse event on failure.\n    error_msg: the error message describing the assertion failure.\n    one_of_list: a list of values that contains the expected value.\n    expected_type: the type that is expected to be parsed.\n    actual_type: the value that is attempted to be parsed.\n    default_value: the default value that is returned after parsing.</p>\n\n<p>Returns:\n    whether the assertion has passed.</p>\n", "signature": "(\n    src_container: Union[Dict, List],\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher,\n    error_msg: str,\n    *,\n    one_of_list: List[Any] = None,\n    expected_type: Type = None,\n    actual_type: Type = None,\n    default_value: Any = None\n) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.parsing.parse_assert.assert_is_key_in_dict", "modulename": "src.fairreckitlib.core.parsing.parse_assert", "qualname": "assert_is_key_in_dict", "type": "function", "doc": "<p>Assert whether the specified key is present in the specified dictionary.</p>\n\n<p>Args:\n    src_key: the key to assert.\n    src_dict: the dictionary to check the key in.\n    event_dispatcher: to dispatch the parse event on failure.\n    error_msg: the error message describing the assertion failure.\n    one_of_list: a list of values that contains the expected value.\n    expected_type: the type that is expected to be parsed.\n    actual_type: the value that is attempted to be parsed.\n    default_value: the default value that is returned after parsing.</p>\n\n<p>Returns:\n    whether the assertion has passed.</p>\n", "signature": "(\n    src_key: str,\n    src_dict: Dict[str, Any],\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher,\n    error_msg: str,\n    *,\n    one_of_list: List[Any] = None,\n    expected_type: Type = None,\n    actual_type: Any = None,\n    default_value: Any = None\n) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.parsing.parse_assert.assert_is_one_of_list", "modulename": "src.fairreckitlib.core.parsing.parse_assert", "qualname": "assert_is_one_of_list", "type": "function", "doc": "<p>Assert whether the specified value is present in the specified list.</p>\n\n<p>Args:\n    src_value: the value to assert.\n    src_list: the list to check the value in.\n    event_dispatcher: to dispatch the parse event on failure.\n    error_msg: the error message describing the assertion failure.\n    expected_type: the type that is expected to be parsed.\n    actual_type: the value that is attempted to be parsed.\n    default_value: the default value that is returned after parsing.</p>\n\n<p>Returns:\n    bool: whether the assertion has passed.</p>\n", "signature": "(\n    src_value: str,\n    src_list: List[str],\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher,\n    error_msg: str,\n    *,\n    expected_type: Type = None,\n    actual_type: Any = None,\n    default_value: Any = None\n) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.parsing.parse_assert.assert_is_type", "modulename": "src.fairreckitlib.core.parsing.parse_assert", "qualname": "assert_is_type", "type": "function", "doc": "<p>Assert whether the specified value is of the expected type.</p>\n\n<p>Args:\n    value: the value to assert.\n    expected_type: the type that is expected.\n    event_dispatcher: to dispatch the parse event on failure.\n    error_msg: the error message describing the assertion failure.\n    one_of_list: a list of values that contains the expected value.\n    default_value: the default value that is returned after parsing.</p>\n\n<p>Returns:\n    bool: whether the assertion has passed.</p>\n", "signature": "(\n    value: Any,\n    expected_type: Type,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher,\n    error_msg: str,\n    *,\n    one_of_list: List[Any] = None,\n    default_value: Any = None\n) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.parsing.parse_config_object", "modulename": "src.fairreckitlib.core.parsing.parse_config_object", "type": "module", "doc": "<p>This module contains functionality to parse configuration object name and parameters.</p>\n\n<p>Functions:</p>\n\n<pre><code>parse_config_object: parse an object name and parameters configuration.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.parsing.parse_config_object.parse_config_object", "modulename": "src.fairreckitlib.core.parsing.parse_config_object", "qualname": "parse_config_object", "type": "function", "doc": "<p>Parse an object name and parameters configuration.</p>\n\n<p>Args:\n    obj_type_name: name of the object type.\n    obj_config: dictionary with the object's configuration.\n    obj_factory: the object factory related to the object config.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    the parsed configuration and object name or None on failure.</p>\n", "signature": "(\n    obj_type_name: str,\n    obj_config: Dict[str, Any],\n    obj_factory: src.fairreckitlib.core.config.config_factories.Factory,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> Union[Tuple[src.fairreckitlib.core.config.config_object.ObjectConfig, str], Tuple[NoneType, NoneType]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.parsing.parse_config_params", "modulename": "src.fairreckitlib.core.parsing.parse_config_params", "type": "module", "doc": "<p>This module contains functionality to parse configuration parameter(s).</p>\n\n<p>Functions:</p>\n\n<pre><code>parse_config_parameters: parse multiple parameters.\nparse_config_param: parse a single parameter.\ntrim_config_params: trim unnecessary params that are not present in the config parameters.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.parsing.parse_config_params.parse_config_parameters", "modulename": "src.fairreckitlib.core.parsing.parse_config_params", "qualname": "parse_config_parameters", "type": "function", "doc": "<p>Parse the object's parameters configuration.</p>\n\n<p>Args:\n    params_config: dictionary with the configuration to parse.\n    parent_name: name of the parent related to the parameters' configuration.\n    parameters: the configuration parameters.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    the parsed params configuration as key-value pairs.</p>\n", "signature": "(\n    params_config: Any,\n    parent_name: str,\n    parameters: src.fairreckitlib.core.config.config_parameters.ConfigParameters,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.parsing.parse_config_params.parse_config_param", "modulename": "src.fairreckitlib.core.parsing.parse_config_params", "qualname": "parse_config_param", "type": "function", "doc": "<p>Parse a parameter from the specified configuration.</p>\n\n<p>Args:\n    params_config: dictionary with the parameters' configuration.\n    parent_name: name of the parent related to the parameters' configuration.\n    param: the parameter that is being parsed.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    whether the parsing succeeded and the parsed (validated) value.</p>\n", "signature": "(\n    params_config: Dict[str, Any],\n    parent_name: str,\n    param: src.fairreckitlib.core.config.config_base_param.ConfigParam,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> Tuple[bool, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.parsing.parse_config_params.trim_config_params", "modulename": "src.fairreckitlib.core.parsing.parse_config_params", "qualname": "trim_config_params", "type": "function", "doc": "<p>Trim the parameters from the specified configuration.</p>\n\n<p>Removes unnecessary parameters that are not present in the\noriginal config parameter list.</p>\n\n<p>Args:\n    params_config: dictionary with the parameters' configuration.\n    parent_name: name of the parent related to the parameters' configuration.\n    parameters: the configuration parameters.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    the dictionary with the trimmed parameters.</p>\n", "signature": "(\n    params_config: Dict[str, Any],\n    parent_name: str,\n    parameters: src.fairreckitlib.core.config.config_parameters.ConfigParameters,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.parsing.parse_event", "modulename": "src.fairreckitlib.core.parsing.parse_event", "type": "module", "doc": "<p>This module contains an event id, event args and print function for a parsing event.</p>\n\n<p>Constants:</p>\n\n<pre><code>ON_PARSE: id of the event that is used when parsing fails.\n</code></pre>\n\n<p>Classes:</p>\n\n<pre><code>ParseEventArgs: event args related to parsing.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>print_parse_event: print parse event arguments.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.parsing.parse_event.ParseEventArgs", "modulename": "src.fairreckitlib.core.parsing.parse_event", "qualname": "ParseEventArgs", "type": "class", "doc": "<p>Parse Event Arguments.</p>\n\n<p>Only the message is required, other variables are optional.</p>\n\n<p>message: the message describing the parsing failure.\none_of_list: a list of values that contains the expected value.\nexpected_type: the type that is expected to be parsed.\nactual_type: the type that is attempted to be parsed.\ndefault_value: the default value that is returned after parsing.</p>\n", "bases": "src.fairreckitlib.core.events.event_args.MessageEventArgs"}, {"fullname": "src.fairreckitlib.core.parsing.parse_event.ParseEventArgs.__init__", "modulename": "src.fairreckitlib.core.parsing.parse_event", "qualname": "ParseEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    event_id: str,\n    message: str,\n    one_of_list: List[Any] = None,\n    expected_type: Type = None,\n    actual_type: Type = None,\n    default_value: Any = None\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.parsing.parse_event.ParseEventArgs.one_of_list", "modulename": "src.fairreckitlib.core.parsing.parse_event", "qualname": "ParseEventArgs.one_of_list", "type": "variable", "doc": "<p></p>\n", "annotation": ": List[Any]", "default_value": " = None"}, {"fullname": "src.fairreckitlib.core.parsing.parse_event.ParseEventArgs.expected_type", "modulename": "src.fairreckitlib.core.parsing.parse_event", "qualname": "ParseEventArgs.expected_type", "type": "variable", "doc": "<p></p>\n", "annotation": ": Type", "default_value": " = None"}, {"fullname": "src.fairreckitlib.core.parsing.parse_event.ParseEventArgs.actual_type", "modulename": "src.fairreckitlib.core.parsing.parse_event", "qualname": "ParseEventArgs.actual_type", "type": "variable", "doc": "<p></p>\n", "annotation": ": Type", "default_value": " = None"}, {"fullname": "src.fairreckitlib.core.parsing.parse_event.ParseEventArgs.default_value", "modulename": "src.fairreckitlib.core.parsing.parse_event", "qualname": "ParseEventArgs.default_value", "type": "variable", "doc": "<p></p>\n", "annotation": ": Any", "default_value": " = None"}, {"fullname": "src.fairreckitlib.core.parsing.parse_event.print_parse_event", "modulename": "src.fairreckitlib.core.parsing.parse_event", "qualname": "print_parse_event", "type": "function", "doc": "<p>Print parse event arguments.</p>\n\n<p>Args:\n    event_args: the arguments to print.</p>\n", "signature": "(\n    event_args: src.fairreckitlib.core.parsing.parse_event.ParseEventArgs\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.pipeline", "modulename": "src.fairreckitlib.core.pipeline", "type": "module", "doc": "<p>This module contains functionality for the core pipeline.</p>\n\n<p>Modules:</p>\n\n<pre><code>core_pipeline: base class for the core pipeline.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.pipeline.core_pipeline", "modulename": "src.fairreckitlib.core.pipeline.core_pipeline", "type": "module", "doc": "<p>This module contains the base core pipeline class.</p>\n\n<p>Classes:</p>\n\n<pre><code>CorePipeline:\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.pipeline.core_pipeline.CorePipeline", "modulename": "src.fairreckitlib.core.pipeline.core_pipeline", "qualname": "CorePipeline", "type": "class", "doc": "<p>Base class for FairRecKit pipelines.</p>\n\n<p>This class exposes some reusable functionality that can be used in derived\npipelines to read and/or write dataframes.</p>\n"}, {"fullname": "src.fairreckitlib.core.pipeline.core_pipeline.CorePipeline.__init__", "modulename": "src.fairreckitlib.core.pipeline.core_pipeline", "qualname": "CorePipeline.__init__", "type": "function", "doc": "<p>Construct the CorePipeline.</p>\n\n<p>Args:\n    event_dispatcher: used to dispatch events when running the core pipeline.</p>\n", "signature": "(\n    self,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.pipeline.core_pipeline.CorePipeline.read_dataframe", "modulename": "src.fairreckitlib.core.pipeline.core_pipeline", "qualname": "CorePipeline.read_dataframe", "type": "function", "doc": "<p>Read a dataframe from the disk.</p>\n\n<p>This function dispatches an error event when the FileNotFoundError is raised,\nand thereafter the error is raised once more.</p>\n\n<p>Args:\n    dataframe_path: path to the dataframe file.\n    dataframe_name: name of the dataframe to use for event dispatching.\n    event_id_on_begin: the event_id to dispatch when loading starts.\n    event_id_on_end: the event_id to dispatch when loading is finished.\n    names: the column names of the dataframe or None to infer them from the header.</p>\n\n<p>Returns:\n    the loaded dataframe.</p>\n", "signature": "(\n    self,\n    dataframe_path: str,\n    dataframe_name: str,\n    event_id_on_begin: str,\n    event_id_on_end: str,\n    *,\n    names=None\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.pipeline.core_pipeline.CorePipeline.write_dataframe", "modulename": "src.fairreckitlib.core.pipeline.core_pipeline", "qualname": "CorePipeline.write_dataframe", "type": "function", "doc": "<p>Write a dataframe to the disk.</p>\n\n<p>This function is intended to write (append) a dataframe in chunks,\nincluding the header of the dataframe.\nIt is assumed that when the header is True that the dataframe file\nhas been created, which in turn will dispatch the IO event.</p>\n\n<p>Args:\n    dataframe_path: path to the dataframe file.\n    dataframe: the dataframe to append to the file.\n    header: whether to include the header.</p>\n", "signature": "(\n    self,\n    dataframe_path: str,\n    dataframe: pandas.core.frame.DataFrame,\n    header: bool\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading", "modulename": "src.fairreckitlib.core.threading", "type": "module", "doc": "<p>This package contains functionality for base threading and processing.</p>\n\n<p>Modules:</p>\n\n<pre><code>thread_base: base class for a thread that can be handled by the processor.\nthread_processor: processor that starts new and stops active threads.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.threading.thread_base", "modulename": "src.fairreckitlib.core.threading.thread_base", "type": "module", "doc": "<p>This module contains the base class for threads.</p>\n\n<p>Classes:</p>\n\n<pre><code>ThreadBase: base class that implements basic threading functionality.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.threading.thread_base.ThreadBase", "modulename": "src.fairreckitlib.core.threading.thread_base", "qualname": "ThreadBase", "type": "class", "doc": "<p>Base class for all threads.</p>\n\n<p>Wraps the threading module in a class interface. The main function of each\nthread consists of three steps:</p>\n\n<p>1) Initialize\n2) Run\n3) Terminate</p>\n\n<p>Threads are not running on creation, only after the start() function is called.\nThe function is_running() will return True as long as the thread is active,\nonce the stop() function is called it requests the thread to finish.\nThreads cannot be cancelled so any derived class logic needs to account for this request\nby checking the is_running function pointer (in step 2) regularly.</p>\n\n<p>Abstract methods:</p>\n\n<p>on_initialize (optional)\non_run (required)\non_terminate (optional)</p>\n\n<p>Public methods:</p>\n\n<p>get_name\nis_running\nstart\nstop</p>\n"}, {"fullname": "src.fairreckitlib.core.threading.thread_base.ThreadBase.__init__", "modulename": "src.fairreckitlib.core.threading.thread_base", "qualname": "ThreadBase.__init__", "type": "function", "doc": "<p>Construct the BaseThread.</p>\n\n<p>Args:\n    name the name of the thread.\n    verbose: whether the thread should give verbose output.</p>\n\n<p>Keyword Args:\n    varying: these are passed to the run function from step 2.</p>\n", "signature": "(self, name: str, verbose: bool, **kwargs)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_base.ThreadBase.start", "modulename": "src.fairreckitlib.core.threading.thread_base", "qualname": "ThreadBase.start", "type": "function", "doc": "<p>Start running the thread.</p>\n\n<p>Args:\n    terminate_callback: call back function that is called once the thread is\n    finished running and is terminated. This function has one argument\n    which is the thread itself.</p>\n\n<p>Returns:\n    True when the thread successfully started or False when the thread is already running.</p>\n", "signature": "(self, terminate_callback: Callable[[Any], NoneType]) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_base.ThreadBase.stop", "modulename": "src.fairreckitlib.core.threading.thread_base", "qualname": "ThreadBase.stop", "type": "function", "doc": "<p>Stop running the thread.</p>\n\n<p>Does not cancel the thread, but rather requests for the thread to finish\nby settings the is_running flag to False. Derived classes need to account\nfor this request by checking the status regularly.</p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_base.ThreadBase.get_name", "modulename": "src.fairreckitlib.core.threading.thread_base", "qualname": "ThreadBase.get_name", "type": "function", "doc": "<p>Get the name of the thread.</p>\n\n<p>Returns:\n    the thread's name.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_base.ThreadBase.is_running", "modulename": "src.fairreckitlib.core.threading.thread_base", "qualname": "ThreadBase.is_running", "type": "function", "doc": "<p>Get if the thread is still running.</p>\n\n<p>Returns:\n    whether the thread is running.</p>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_base.ThreadBase.on_initialize", "modulename": "src.fairreckitlib.core.threading.thread_base", "qualname": "ThreadBase.on_initialize", "type": "function", "doc": "<p>Initialize the thread.</p>\n\n<p>This function is called once when the thread is started.\nIt should not be used directly, add specific logic in derived classes.</p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_base.ThreadBase.on_run", "modulename": "src.fairreckitlib.core.threading.thread_base", "qualname": "ThreadBase.on_run", "type": "function", "doc": "<p>Run the thread.</p>\n\n<p>This function is called once after the thread is initialized.\nIt should not be used directly, add specific logic in derived classes.</p>\n\n<p>Keyword Args:\n    varying: these are passed directly from the thread's constructor.</p>\n", "signature": "(self, **kwargs) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_base.ThreadBase.on_terminate", "modulename": "src.fairreckitlib.core.threading.thread_base", "qualname": "ThreadBase.on_terminate", "type": "function", "doc": "<p>Terminate the thread.</p>\n\n<p>This function is called once after the thread is done running.\nIt should not be used directly, add specific logic in derived classes.\nMoreover, derived classes are expected to call their super implementation\nafter their own implementation is finished.</p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_base.ThreadBase.main", "modulename": "src.fairreckitlib.core.threading.thread_base", "qualname": "ThreadBase.main", "type": "function", "doc": "<p>Run the main function target of the thread.</p>\n\n<p>Keyword Args:\n    varying: these are passed directly from the thread's constructor.</p>\n", "signature": "(self, **kwargs) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_processor", "modulename": "src.fairreckitlib.core.threading.thread_processor", "type": "module", "doc": "<p>This module contains a processor that handles active threads.</p>\n\n<p>Classes:</p>\n\n<pre><code>ThreadProcessor: class that starts new and stops running threads.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.core.threading.thread_processor.ThreadProcessor", "modulename": "src.fairreckitlib.core.threading.thread_processor", "qualname": "ThreadProcessor", "type": "class", "doc": "<p>Processor for multiple threads (derived from ThreadBase class).</p>\n\n<p>Keeps track of all threads that are started by this processor.\nThe processor acquires ownership of these aforementioned threads and\nwill dispose of them after they are finished.\nAdditionally, these threads can be stopped as well.</p>\n\n<p>Public methods:</p>\n\n<p>get_active_threads\nget_num_active\nis_active_thread\nstart\nstop</p>\n"}, {"fullname": "src.fairreckitlib.core.threading.thread_processor.ThreadProcessor.__init__", "modulename": "src.fairreckitlib.core.threading.thread_processor", "qualname": "ThreadProcessor.__init__", "type": "function", "doc": "<p>Construct the ThreadProcessor.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_processor.ThreadProcessor.get_active_threads", "modulename": "src.fairreckitlib.core.threading.thread_processor", "qualname": "ThreadProcessor.get_active_threads", "type": "function", "doc": "<p>Get the names of any active threads.</p>\n\n<p>Returns:\n    a list of thread names that are currently running.</p>\n", "signature": "(self) -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_processor.ThreadProcessor.get_num_active", "modulename": "src.fairreckitlib.core.threading.thread_processor", "qualname": "ThreadProcessor.get_num_active", "type": "function", "doc": "<p>Get the number of active threads for this processor.</p>\n\n<p>Returns:\n    the number of threads.</p>\n", "signature": "(self) -> int", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_processor.ThreadProcessor.is_active_thread", "modulename": "src.fairreckitlib.core.threading.thread_processor", "qualname": "ThreadProcessor.is_active_thread", "type": "function", "doc": "<p>Get if the thread with the specified name is active.</p>\n\n<p>Args:\n    thread_name: the name of the thread to query.</p>\n\n<p>Returns:\n    whether the thread is handled by the processor.</p>\n", "signature": "(self, thread_name: str) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_processor.ThreadProcessor.start", "modulename": "src.fairreckitlib.core.threading.thread_processor", "qualname": "ThreadProcessor.start", "type": "function", "doc": "<p>Start the specified thread.</p>\n\n<p>The processor takes ownership of the thread and will clean it up\nafter it is done running.\nThis function returns a KeyError when a thread with the same name\nis already being handled by the processor.</p>\n\n<p>Args:\n    thread: the thread to start.</p>\n", "signature": "(\n    self,\n    thread: src.fairreckitlib.core.threading.thread_base.ThreadBase\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_processor.ThreadProcessor.stop", "modulename": "src.fairreckitlib.core.threading.thread_processor", "qualname": "ThreadProcessor.stop", "type": "function", "doc": "<p>Stop the thread with the specified name.</p>\n\n<p>The processor requests the thread to stop running.\nThis function returns a KeyError when a thread with the specified name\nis not being handled by the processor.</p>\n\n<p>Args:\n    thread_name: the name of the thread to stop.</p>\n", "signature": "(self, thread_name: str) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.core.threading.thread_processor.ThreadProcessor.remove", "modulename": "src.fairreckitlib.core.threading.thread_processor", "qualname": "ThreadProcessor.remove", "type": "function", "doc": "<p>Remove the thread from the processor.</p>\n", "signature": "(self, thread)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data", "modulename": "src.fairreckitlib.data", "type": "module", "doc": "<p>This package contains functionality for data(set) operations.</p>\n\n<p>Modules:</p>\n\n<pre><code>data_factory: create data factory with available data modifiers.\ndata_modifier: base class for dataframe modifications.\ndata_transition: data transition class.\n</code></pre>\n\n<p>Packages:</p>\n\n<pre><code>filter: dataframe filtering.\npipeline: run data modifiers on (multiple) datasets.\nratings: dataframe rating conversion.\nset: dataset definition/preprocessing/registry.\nsplit: dataframe splitting.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.data_factory", "modulename": "src.fairreckitlib.data.data_factory", "type": "module", "doc": "<p>This module contains functionality to create a data factory.</p>\n\n<p>Constants:</p>\n\n<pre><code>KEY_DATA: key that is used to identify data.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_data_factory: create factory with data modifier factories.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.data_factory.create_data_factory", "modulename": "src.fairreckitlib.data.data_factory", "qualname": "create_data_factory", "type": "function", "doc": "<p>Create a group factory with all data modifiers.</p>\n\n<p>Consists of two data modifier factories:\n    1) data rating converters.\n    2) data splitters.</p>\n\n<p>Returns:\n    the group factory with available data modifier factories.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_factories.GroupFactory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.data_modifier", "modulename": "src.fairreckitlib.data.data_modifier", "type": "module", "doc": "<p>This module contains the base class for data modification.</p>\n\n<p>Classes:</p>\n\n<pre><code>DataModifier: the base class for data modifying.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.data_modifier.DataModifier", "modulename": "src.fairreckitlib.data.data_modifier", "qualname": "DataModifier", "type": "class", "doc": "<p>Base class for FairRecKit data modifiers.</p>\n\n<p>Public methods:</p>\n\n<p>get_name\nget_params\nrun</p>\n"}, {"fullname": "src.fairreckitlib.data.data_modifier.DataModifier.__init__", "modulename": "src.fairreckitlib.data.data_modifier", "qualname": "DataModifier.__init__", "type": "function", "doc": "<p>Construct the DataModifier.</p>\n\n<p>Args:\n    name: the name of the modifier.\n    params: the modifier parameters.</p>\n", "signature": "(self, name: str, params: Dict[str, Any])", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.data_modifier.DataModifier.get_name", "modulename": "src.fairreckitlib.data.data_modifier", "qualname": "DataModifier.get_name", "type": "function", "doc": "<p>Get the name of the modifier.</p>\n\n<p>Returns:\n    the modifier name.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.data_modifier.DataModifier.get_params", "modulename": "src.fairreckitlib.data.data_modifier", "qualname": "DataModifier.get_params", "type": "function", "doc": "<p>Get the parameters of the modifier.</p>\n\n<p>Returns:\n    the modifier parameters.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.data_modifier.DataModifier.run", "modulename": "src.fairreckitlib.data.data_modifier", "qualname": "DataModifier.run", "type": "function", "doc": "<p>Run the modifier on the specified dataframe.</p>\n\n<p>Args:\n    dataframe: source df to modify.</p>\n\n<p>Returns:\n    any modification to the dataframe.</p>\n", "signature": "(self, dataframe: pandas.core.frame.DataFrame) -> Any", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.data_transition", "modulename": "src.fairreckitlib.data.data_transition", "type": "module", "doc": "<p>This module contains a data transition definition.</p>\n\n<p>Classes:</p>\n\n<pre><code>DataTransition: data descriptions to be used between pipelines.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.data_transition.DataTransition", "modulename": "src.fairreckitlib.data.data_transition", "qualname": "DataTransition", "type": "class", "doc": "<p>Data Transition to transfer pipeline data.</p>\n"}, {"fullname": "src.fairreckitlib.data.data_transition.DataTransition.__init__", "modulename": "src.fairreckitlib.data.data_transition", "qualname": "DataTransition.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    dataset: src.fairreckitlib.data.set.dataset.Dataset,\n    output_dir: str,\n    train_set_path: str,\n    test_set_path: str,\n    rating_scale: Tuple[float, float],\n    rating_type: str\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter", "modulename": "src.fairreckitlib.data.filter", "type": "module", "doc": "<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.filter.age", "modulename": "src.fairreckitlib.data.filter.age", "type": "module", "doc": "<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.filter.age.AgeFilter", "modulename": "src.fairreckitlib.data.filter.age", "qualname": "AgeFilter", "type": "class", "doc": "<p>Filters the dataframe on user age, if such a column exists.</p>\n", "bases": "src.fairreckitlib.data.filter.base.DataFilter"}, {"fullname": "src.fairreckitlib.data.filter.age.AgeFilter.run", "modulename": "src.fairreckitlib.data.filter.age", "qualname": "AgeFilter.run", "type": "function", "doc": "<p>Filter the dataframe based on age column in the range of min_val and max_val values.</p>\n\n<p>Args:\n    min_val: minimum age (default 0)\n    max_val: maximum age (default 0)</p>\n\n<p>Returns:\n    a filtered dataframe from the given dataframe</p>\n", "signature": "(\n    self,\n    min_val: int = 0,\n    max_val: int = 100\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.age.create_age_filter", "modulename": "src.fairreckitlib.data.filter.age", "qualname": "create_age_filter", "type": "function", "doc": "<p>Create an instance of the class AgeFilter</p>\n\n<p>Args:\n    data_frame: a pandas DataFrame being filtered</p>\n\n<p>Returns:\n    an instance of the AgeFilter class</p>\n", "signature": "(\n    data_frame: pandas.core.frame.DataFrame\n) -> src.fairreckitlib.data.filter.base.DataFilter", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.base", "modulename": "src.fairreckitlib.data.filter.base", "type": "module", "doc": "<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.filter.base.DataFilter", "modulename": "src.fairreckitlib.data.filter.base", "qualname": "DataFilter", "type": "class", "doc": "<p>Base class to filter a df (not a dataset in particular), as long as the df\ncontains a 'user' and 'item' column.</p>\n\n<p>Dataset class is not really necessary here, but when combined with the\ndata.format module it needs to know about them to construct them.</p>\n\n<p>Together with a factory pattern similar to the data.split module\nwe can define a variety of filters to exclude rows that do not satisfy the filter\nfrom the specified df as long as it retains the 'user' and 'item' columns.</p>\n\n<p>These filters could be used by the fair-rec-kit-app as well (table browsing).</p>\n\n<p>Public method:\n    run</p>\n"}, {"fullname": "src.fairreckitlib.data.filter.base.DataFilter.__init__", "modulename": "src.fairreckitlib.data.filter.base", "qualname": "DataFilter.__init__", "type": "function", "doc": "<p>Make Constructor of the class.</p>\n", "signature": "(self, dataset: pandas.core.frame.DataFrame)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.base.DataFilter.run", "modulename": "src.fairreckitlib.data.filter.base", "qualname": "DataFilter.run", "type": "function", "doc": "<p>Carry out the filtering</p>\n\n<p>Raises:\n    NotImplementedError: this method should be implimented in the subclasses</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.country", "modulename": "src.fairreckitlib.data.filter.country", "type": "module", "doc": "<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.filter.country.CountryFilter", "modulename": "src.fairreckitlib.data.filter.country", "qualname": "CountryFilter", "type": "class", "doc": "<p>Filters the dataframe on country, if such column exists.</p>\n", "bases": "src.fairreckitlib.data.filter.base.DataFilter"}, {"fullname": "src.fairreckitlib.data.filter.country.CountryFilter.run", "modulename": "src.fairreckitlib.data.filter.country", "qualname": "CountryFilter.run", "type": "function", "doc": "<p>Filter specific country of the dataframe.</p>\n\n<p>Args:\n    country: the name of the country used in filtering</p>\n\n<p>Returns:\n    a filtered dataframe from the given dataframe</p>\n", "signature": "(self, country: str = None) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.country.create_country_filter", "modulename": "src.fairreckitlib.data.filter.country", "qualname": "create_country_filter", "type": "function", "doc": "<p>Create an instance of the class CountryFilter</p>\n\n<p>Args:\n    data_frame: a pandas DataFrame being filtered</p>\n\n<p>Returns:\n    an instance of the CountryFilter class</p>\n", "signature": "(\n    data_frame: pandas.core.frame.DataFrame\n) -> src.fairreckitlib.data.filter.base.DataFilter", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.factory", "modulename": "src.fairreckitlib.data.filter.factory", "type": "module", "doc": "<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.filter.factory.get_filter", "modulename": "src.fairreckitlib.data.filter.factory", "qualname": "get_filter", "type": "function", "doc": "<p>To string</p>\n\n<p>Returns:\n    name of the class</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.filter_constants", "modulename": "src.fairreckitlib.data.filter.filter_constants", "type": "module", "doc": "<p>This module contains filtering constants that are used in other modules.</p>\n\n<p>Constants:</p>\n\n<pre><code>KEY_DATA_FILTERS: key that is used to identify data filters.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.filter.filter_event", "modulename": "src.fairreckitlib.data.filter.filter_event", "type": "module", "doc": "<p>This module contains event args and a print function for a filter event.</p>\n\n<p>Classes:</p>\n\n<pre><code>FilterDataframeEventArgs: event args related to filtering a dataframe.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>print_filter_event_args: print filter event arguments.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.filter.filter_event.FilterDataframeEventArgs", "modulename": "src.fairreckitlib.data.filter.filter_event", "qualname": "FilterDataframeEventArgs", "type": "class", "doc": "<p>Filter Dataframe Event Arguments.</p>\n\n<p>message: the message describing the parsing failure.\nprefilters: list of filters that is used on the dataframe.</p>\n", "bases": "src.fairreckitlib.core.events.event_args.EventArgs"}, {"fullname": "src.fairreckitlib.data.filter.filter_event.FilterDataframeEventArgs.__init__", "modulename": "src.fairreckitlib.data.filter.filter_event", "qualname": "FilterDataframeEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, event_id: str, prefilters: List[Any])", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.filter_event.print_filter_event_args", "modulename": "src.fairreckitlib.data.filter.filter_event", "qualname": "print_filter_event_args", "type": "function", "doc": "<p>Print filter dataframe event arguments.</p>\n\n<p>It is assumed that the event started when elapsed_time is None and is finished otherwise.</p>\n\n<p>Args:\n    event_args: the arguments to print.\n    elapsed_time: the time that has passed since the filtering started, expressed in seconds.</p>\n", "signature": "(\n    event_args: src.fairreckitlib.data.filter.filter_event.FilterDataframeEventArgs,\n    elapsed_time: float = None\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.gender", "modulename": "src.fairreckitlib.data.filter.gender", "type": "module", "doc": "<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.filter.gender.GenderFilter", "modulename": "src.fairreckitlib.data.filter.gender", "qualname": "GenderFilter", "type": "class", "doc": "<p>Filters the dataframe on gender column f/m, if such a column exists.</p>\n", "bases": "src.fairreckitlib.data.filter.base.DataFilter"}, {"fullname": "src.fairreckitlib.data.filter.gender.GenderFilter.run", "modulename": "src.fairreckitlib.data.filter.gender", "qualname": "GenderFilter.run", "type": "function", "doc": "<p>Filter specific gender of the dataframe.</p>\n\n<p>Args:\n    country: the name of the country used in filtering</p>\n\n<p>Returns:\n    a filtered dataframe from the given dataframe</p>\n", "signature": "(self, gender: str = None) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.filter.gender.create_gender_filter", "modulename": "src.fairreckitlib.data.filter.gender", "qualname": "create_gender_filter", "type": "function", "doc": "<p>Create an instance of the class GenderFilter</p>\n\n<p>Args:\n    data_frame: a pandas DataFrame being filtered</p>\n\n<p>Returns:\n    an instance of the GenderFilter class</p>\n", "signature": "(\n    data_frame: pandas.core.frame.DataFrame\n) -> src.fairreckitlib.data.filter.base.DataFilter", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline", "modulename": "src.fairreckitlib.data.pipeline", "type": "module", "doc": "<p>This package contains functionality for running the data pipeline.</p>\n\n<p>Modules:</p>\n\n<pre><code>data_config: dataset configuration class.\ndata_config_parsing: parse dataset configuration.\ndata_event: event ids, event args and a print switch for the data pipeline.\ndata_pipeline: the data pipeline class.\ndata_run: run (multiple) data pipelines.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.pipeline.data_config", "modulename": "src.fairreckitlib.data.pipeline.data_config", "type": "module", "doc": "<p>This module contains the dataset configuration.</p>\n\n<p>Classes:</p>\n\n<pre><code>DatasetConfig: dataset configuration.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.pipeline.data_config.DataMatrixConfig", "modulename": "src.fairreckitlib.data.pipeline.data_config", "qualname": "DataMatrixConfig", "type": "class", "doc": "<p>Data Matrix Configuration.</p>\n"}, {"fullname": "src.fairreckitlib.data.pipeline.data_config.DataMatrixConfig.__init__", "modulename": "src.fairreckitlib.data.pipeline.data_config", "qualname": "DataMatrixConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    dataset: str,\n    matrix: str,\n    prefilters: [],\n    converter: Optional[src.fairreckitlib.data.ratings.convert_config.ConvertConfig],\n    splitting: src.fairreckitlib.data.split.split_config.SplitConfig\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_config.DataMatrixConfig.to_yml_format", "modulename": "src.fairreckitlib.data.pipeline.data_config", "qualname": "DataMatrixConfig.to_yml_format", "type": "function", "doc": "<p>Format dataset configuration to a yml compatible dictionary.</p>\n\n<p>Returns:\n    a dictionary containing the dataset configuration.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_config_parsing", "modulename": "src.fairreckitlib.data.pipeline.data_config_parsing", "type": "module", "doc": "<p>This module contains a parser for the dataset configuration.</p>\n\n<p>Functions:</p>\n\n<pre><code>parse_data_config: parse (multiple) dataset configurations.\nparse_dataset_config: parse dataset configuration.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.pipeline.data_config_parsing.parse_data_config", "modulename": "src.fairreckitlib.data.pipeline.data_config_parsing", "qualname": "parse_data_config", "type": "function", "doc": "<p>Parse all dataset configurations.</p>\n\n<p>Args:\n    experiment_config: the experiment's total configuration.\n    data_registry: the data registry containing the available datasets.\n    data_factory: factory with available data modifier factories.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    a list of parsed DatasetConfig's or None when empty.</p>\n", "signature": "(\n    experiment_config: Dict[str, Any],\n    data_registry: src.fairreckitlib.data.set.dataset_registry.DataRegistry,\n    data_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> Optional[List[src.fairreckitlib.data.pipeline.data_config.DataMatrixConfig]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_config_parsing.parse_dataset_config", "modulename": "src.fairreckitlib.data.pipeline.data_config_parsing", "qualname": "parse_dataset_config", "type": "function", "doc": "<p>Parse a dataset configuration.</p>\n\n<p>Args:\n    dataset_config: the dataset's configuration.\n    data_registry: the data registry containing the available datasets.\n    data_factory: factory with available data modifier factories.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    parsed_config: the parsed configuration or None on failure.\n    dataset_name: the name of the parsed dataset or None on failure.</p>\n", "signature": "(\n    dataset_config: Dict[str, Any],\n    data_registry: src.fairreckitlib.data.set.dataset_registry.DataRegistry,\n    data_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> Union[Tuple[src.fairreckitlib.data.pipeline.data_config.DataMatrixConfig, str], Tuple[NoneType, NoneType]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_event", "modulename": "src.fairreckitlib.data.pipeline.data_event", "type": "module", "doc": "<p>This module contains all event ids, event args and a print switch for the data pipeline.</p>\n\n<p>Constants:</p>\n\n<pre><code>ON_BEGIN_DATA_PIPELINE: id of the event that is used when the data pipeline starts.\nON_BEGIN_FILTER_DATASET: id of the event that is used when dataset filtering starts.\nON_BEGIN_LOAD_DATASET: id of the event that is used when a dataset is being loaded.\nON_BEGIN_MODIFY_DATASET: id of the event that is used when dataset ratings are being modified.\nON_BEGIN_SAVE_SETS: id of the event that is used when the train and test sets are being saved.\nON_BEGIN_SPLIT_DATASET: id of the event that is used when a dataset is being split.\nON_END_DATA_PIPELINE: id of the event that is used when the data pipeline ends.\nON_END_FILTER_DATASET: id of the event that is used when dataset filtering finishes.\nON_END_LOAD_DATASET: id of the event that is used when a dataset has been loaded.\nON_END_MODIFY_DATASET: id of the event that is used when dataset ratings have been modified.\nON_END_SAVE_SETS: id of the event that is used when the train and test sets have been saved.\nON_END_SPLIT_DATASET: id of the event that is used when a dataset has been split.\n</code></pre>\n\n<p>Classes:</p>\n\n<pre><code>DatasetEventArgs: event args related to a dataset.\nDatasetMatrixEventArgs: event args related to a dataset matrix.\nSaveSetsEventArgs: event args related to saving a train and test set.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>get_data_events: list of data pipeline event IDs.\nget_data_event_print_switch: switch to print data pipeline event arguments by ID.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.pipeline.data_event.DatasetEventArgs", "modulename": "src.fairreckitlib.data.pipeline.data_event", "qualname": "DatasetEventArgs", "type": "class", "doc": "<p>Dataset Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the dataset event.\ndataset_name: the name of the dataset.</p>\n", "bases": "src.fairreckitlib.core.events.event_args.EventArgs"}, {"fullname": "src.fairreckitlib.data.pipeline.data_event.DatasetEventArgs.__init__", "modulename": "src.fairreckitlib.data.pipeline.data_event", "qualname": "DatasetEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, event_id: str, dataset_name: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_event.DatasetMatrixEventArgs", "modulename": "src.fairreckitlib.data.pipeline.data_event", "qualname": "DatasetMatrixEventArgs", "type": "class", "doc": "<p>Dataset Matrix Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the dataset matrix event.\ndataset_name: the name of the dataset.\nmatrix_name: the name of the dataset matrix.\nmatrix_file_path: the path to the file of the dataset matrix.</p>\n", "bases": "DatasetEventArgs"}, {"fullname": "src.fairreckitlib.data.pipeline.data_event.DatasetMatrixEventArgs.__init__", "modulename": "src.fairreckitlib.data.pipeline.data_event", "qualname": "DatasetMatrixEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    event_id: str,\n    dataset_name: str,\n    matrix_name: str,\n    matrix_file_path: str\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_event.SaveSetsEventArgs", "modulename": "src.fairreckitlib.data.pipeline.data_event", "qualname": "SaveSetsEventArgs", "type": "class", "doc": "<p>Save Sets Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the save sets event.\ntrain_set_path: the path to the file of the train set.\ntest_set_path: the path to the file of the test set.</p>\n", "bases": "src.fairreckitlib.core.events.event_args.EventArgs"}, {"fullname": "src.fairreckitlib.data.pipeline.data_event.SaveSetsEventArgs.__init__", "modulename": "src.fairreckitlib.data.pipeline.data_event", "qualname": "SaveSetsEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, event_id: str, train_set_path: str, test_set_path: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_event.get_data_events", "modulename": "src.fairreckitlib.data.pipeline.data_event", "qualname": "get_data_events", "type": "function", "doc": "<p>Get a list of data pipeline event IDs.</p>\n\n<p>Returns:\n    a list of unique data pipeline event IDs.</p>\n", "signature": "() -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_event.get_data_event_print_switch", "modulename": "src.fairreckitlib.data.pipeline.data_event", "qualname": "get_data_event_print_switch", "type": "function", "doc": "<p>Get a switch that prints data pipeline event IDs.</p>\n\n<p>Returns:\n    the print data pipeline event switch.</p>\n", "signature": "(\n    elapsed_time: float = None\n) -> Dict[str, Callable[[src.fairreckitlib.core.events.event_args.EventArgs], NoneType]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_pipeline", "modulename": "src.fairreckitlib.data.pipeline.data_pipeline", "type": "module", "doc": "<p>This module contains functionality of the complete data pipeline.</p>\n\n<p>Classes:</p>\n\n<pre><code>DataPipeline: class that performs dataset operations in preparation for the model pipeline.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.pipeline.data_pipeline.DataPipeline", "modulename": "src.fairreckitlib.data.pipeline.data_pipeline", "qualname": "DataPipeline", "type": "class", "doc": "<p>Data Pipeline to prepare a dataset for a transition to the ModelPipeline(s).</p>\n\n<p>The pipeline is intended to be reused multiple times depending on the specified\ndatasets. This is not limited to using a dataset only once as they are numbered\ninternally to distinguish them later.\nFor each dataset the following steps are performed in order:</p>\n\n<p>1) create output directory.\n2) load the dataset into a dataframe.\n3) filter rows based on 'user'/'item' columns. (optional)\n4) convert 'rating' column. (optional)\n5) split the dataframe into a train and test set.\n6) save the train and test set in the output directory.</p>\n\n<p>Public methods:</p>\n\n<p>run</p>\n", "bases": "src.fairreckitlib.core.pipeline.core_pipeline.CorePipeline"}, {"fullname": "src.fairreckitlib.data.pipeline.data_pipeline.DataPipeline.__init__", "modulename": "src.fairreckitlib.data.pipeline.data_pipeline", "qualname": "DataPipeline.__init__", "type": "function", "doc": "<p>Construct the DataPipeline.</p>\n\n<p>Args:\n    data_factory: the factory with available data modifier factories.\n    event_dispatcher: used to dispatch data/IO events when running the pipeline.</p>\n", "signature": "(\n    self,\n    data_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_pipeline.DataPipeline.run", "modulename": "src.fairreckitlib.data.pipeline.data_pipeline", "qualname": "DataPipeline.run", "type": "function", "doc": "<p>Run the entire data pipeline from beginning to end.</p>\n\n<p>Two errors can be raised during execution of the pipeline:\nFileNotFoundError is raised if the dataset matrix file does not exist.\nRuntimeError is raised if any data modifiers are not found in their respective factories.</p>\n\n<p>Args:\n    output_dir: the path of the directory to store the output.\n    dataset: the dataset to run the pipeline on.\n    data_config: the dataset matrix configurations.\n    is_running: function that returns whether the pipeline\n        is still running. Stops early when False is returned.</p>\n\n<p>Returns:\n    the data transition output of the pipeline.</p>\n", "signature": "(\n    self,\n    output_dir: str,\n    dataset: src.fairreckitlib.data.set.dataset.Dataset,\n    data_config: src.fairreckitlib.data.pipeline.data_config.DataMatrixConfig,\n    is_running: Callable[[], bool]\n) -> Optional[src.fairreckitlib.data.data_transition.DataTransition]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_pipeline.DataPipeline.create_data_output_dir", "modulename": "src.fairreckitlib.data.pipeline.data_pipeline", "qualname": "DataPipeline.create_data_output_dir", "type": "function", "doc": "<p>Create the data output directory for a dataset.</p>\n\n<p>Args:\n    output_dir: the path of the directory to store the output.\n    data_config: the dataset matrix configuration to create a directory for.</p>\n\n<p>Returns:\n    the path of the directory where the output data can be stored.</p>\n", "signature": "(\n    self,\n    output_dir: str,\n    data_config: src.fairreckitlib.data.pipeline.data_config.DataMatrixConfig\n) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_pipeline.DataPipeline.load_from_dataset", "modulename": "src.fairreckitlib.data.pipeline.data_pipeline", "qualname": "DataPipeline.load_from_dataset", "type": "function", "doc": "<p>Load in the desired dataset matrix into a dataframe.</p>\n\n<p>It raises a FileNotFoundError when the dataset matrix file does not exist.</p>\n\n<p>Args:\n    dataset: the dataset to load a matrix dataframe from.\n    matrix_name: the name of the matrix to load from the dataset.</p>\n\n<p>Returns:\n    dataframe: belonging to the specified dataset. The\n        dataframe contains at least three columns 'user', 'item', 'rating'.\n        In addition, the 'timestamp' column can be present when\n        available in the specified dataset.</p>\n", "signature": "(\n    self,\n    dataset: src.fairreckitlib.data.set.dataset.Dataset,\n    matrix_name: str\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_pipeline.DataPipeline.filter_rows", "modulename": "src.fairreckitlib.data.pipeline.data_pipeline", "qualname": "DataPipeline.filter_rows", "type": "function", "doc": "<p>Apply the specified filters to the dataframe.</p>\n\n<p>Args:\n    dataframe: the dataset to filter with at least\n        two columns: 'user', 'item'.\n    prefilters: list of user/item filters to apply to the dataframe.</p>\n\n<p>Returns:\n    the dataframe with the specified filters applied to it.</p>\n", "signature": "(\n    self,\n    dataframe: pandas.core.frame.DataFrame,\n    prefilters: List[Any]\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_pipeline.DataPipeline.convert_ratings", "modulename": "src.fairreckitlib.data.pipeline.data_pipeline", "qualname": "DataPipeline.convert_ratings", "type": "function", "doc": "<p>Convert the ratings in the dataframe with the specified rating modifier.</p>\n\n<p>It raises a RuntimeError when the converter specified by the configuration is not available.</p>\n\n<p>Args:\n    dataset: the dataset to load the matrix and rating_type from.\n    matrix_name: the name of the dataset matrix.\n    dataframe: the dataframe to convert the ratings of.\n        At the least a 'rating' column is expected to be present.\n    convert_config: the configuration of the converter to apply to the 'rating' column.</p>\n\n<p>Returns:\n    the converted dataframe and the type of rating, either 'explicit' or 'implicit'.</p>\n", "signature": "(\n    self,\n    dataset: src.fairreckitlib.data.set.dataset.Dataset,\n    matrix_name: str,\n    dataframe: pandas.core.frame.DataFrame,\n    convert_config: src.fairreckitlib.data.ratings.convert_config.ConvertConfig\n) -> Tuple[pandas.core.frame.DataFrame, str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_pipeline.DataPipeline.split", "modulename": "src.fairreckitlib.data.pipeline.data_pipeline", "qualname": "DataPipeline.split", "type": "function", "doc": "<p>Split the dataframe into a train and test set.</p>\n\n<p>This will be split 80/20 (or a similar ratio), and be done either random, or timestamp-wise.\nIt raises a RuntimeError when the splitter specified by the configuration is not available.</p>\n\n<p>Args:\n    dataframe: the dataset to split with at least\n        three columns: 'user', 'item', 'rating'. In addition, the 'timestamp' column\n        is required for temporal splits.\n    split_config: the dataset splitting configuration.</p>\n\n<p>Returns:\n    train_set: the train set split of the specified dataframe.\n    test_set: the test set split of the specified dataframe.</p>\n", "signature": "(\n    self,\n    dataframe: pandas.core.frame.DataFrame,\n    split_config: src.fairreckitlib.data.split.split_config.SplitConfig\n) -> Tuple[pandas.core.frame.DataFrame, pandas.core.frame.DataFrame]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_pipeline.DataPipeline.save_sets", "modulename": "src.fairreckitlib.data.pipeline.data_pipeline", "qualname": "DataPipeline.save_sets", "type": "function", "doc": "<p>Save the train and test sets to the desired output directory.</p>\n\n<p>Args:\n    output_dir: the path of the directory to store both sets.\n    train_set: the train set to save with at least\n        three columns: 'user', 'item', 'rating'.\n    test_set: the test set to save with at least\n        three columns: 'user', 'item', 'rating'.</p>\n\n<p>Returns:\n    the paths where the train and test set are stored.</p>\n", "signature": "(\n    self,\n    output_dir: str,\n    train_set: pandas.core.frame.DataFrame,\n    test_set: pandas.core.frame.DataFrame\n) -> Tuple[str, str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_run", "modulename": "src.fairreckitlib.data.pipeline.data_run", "type": "module", "doc": "<p>This module contains functionality to run the data pipeline.</p>\n\n<p>Classes:</p>\n\n<pre><code>DataPipelineConfig: configuration class to run the data pipelines.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>run_data_pipelines: run the pipeline using dataset configurations.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.pipeline.data_run.DataPipelineConfig", "modulename": "src.fairreckitlib.data.pipeline.data_run", "qualname": "DataPipelineConfig", "type": "class", "doc": "<p>Data Pipeline Configuration.</p>\n\n<p>output_dir: the directory to store the output.\ndata_registry: the registry with available datasets.\ndata_factory: the factory with available data modifier factories.\ndata_config: the dataset matrix configurations to compute.</p>\n"}, {"fullname": "src.fairreckitlib.data.pipeline.data_run.DataPipelineConfig.__init__", "modulename": "src.fairreckitlib.data.pipeline.data_run", "qualname": "DataPipelineConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    output_dir: str,\n    data_registry: src.fairreckitlib.data.set.dataset_registry.DataRegistry,\n    data_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    data_config: List[src.fairreckitlib.data.pipeline.data_config.DataMatrixConfig]\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.pipeline.data_run.run_data_pipelines", "modulename": "src.fairreckitlib.data.pipeline.data_run", "qualname": "run_data_pipelines", "type": "function", "doc": "<p>Run a Data Pipeline several times according to the specified data pipeline configuration.</p>\n\n<p>Args:\n    pipeline_config: the configuration on how to run the data pipelines.\n    event_dispatcher: used to dispatch data/IO events when running the pipeline.\n    is_running: function that returns whether the pipelines\n        are still running. Stops early when False is returned.</p>\n\n<p>Returns:\n    a list of DataTransition's.</p>\n", "signature": "(\n    pipeline_config: src.fairreckitlib.data.pipeline.data_run.DataPipelineConfig,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher,\n    is_running: Callable[[], bool]\n) -> List[src.fairreckitlib.data.data_transition.DataTransition]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings", "modulename": "src.fairreckitlib.data.ratings", "type": "module", "doc": "<p>This package contains functionality to convert ratings in a dataframe.</p>\n\n<p>Modules:</p>\n\n<pre><code>base_converter: base class for converting ratings.\nconvert_config: converter configuration class.\nconvert_config_parsing: parse converter configuration.\nconvert_constants: constants to be used in other modules.\nconvert_event: event args and a print function for a converter event.\ncount: count apc/alc.\nkl_converter: class for converting with kullback-leibler.\nrange_converter: class for converting with a scalar.\nrating_converter_factory: create converter factory with available rating converters.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.ratings.base_converter", "modulename": "src.fairreckitlib.data.ratings.base_converter", "type": "module", "doc": "<p>This module contains the base class for converting ratings.</p>\n\n<p>CLasses:</p>\n\n<pre><code>RatingConverter: the base class for converting ratings.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.ratings.base_converter.RatingConverter", "modulename": "src.fairreckitlib.data.ratings.base_converter", "qualname": "RatingConverter", "type": "class", "doc": "<p>Base class for FairRecKit rating converters.</p>\n\n<p>A converter is used to convert ratings of a dataframe.</p>\n", "bases": "src.fairreckitlib.data.data_modifier.DataModifier"}, {"fullname": "src.fairreckitlib.data.ratings.base_converter.RatingConverter.__init__", "modulename": "src.fairreckitlib.data.ratings.base_converter", "qualname": "RatingConverter.__init__", "type": "function", "doc": "<p>Construct the Rating Converter.</p>\n\n<p>Args:\n    name: the name of the converter.\n    params: the converter parameters.</p>\n", "signature": "(self, name: str, params: Dict[str, Any])", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.base_converter.RatingConverter.run", "modulename": "src.fairreckitlib.data.ratings.base_converter", "qualname": "RatingConverter.run", "type": "function", "doc": "<p>Run the converter on the specified dataframe.</p>\n\n<p>Args:\n    dataframe: with at least the 'rating' column.</p>\n\n<p>Returns:\n    the converted dataframe and the type of rating, either 'explicit' or 'implicit'.</p>\n", "signature": "(\n    self,\n    dataframe: pandas.core.frame.DataFrame\n) -> Tuple[pandas.core.frame.DataFrame, str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.convert_config", "modulename": "src.fairreckitlib.data.ratings.convert_config", "type": "module", "doc": "<p>This module contains the convert configuration.</p>\n\n<p>Classes:</p>\n\n<pre><code>ConvertConfig: convert configuration.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.ratings.convert_config.ConvertConfig", "modulename": "src.fairreckitlib.data.ratings.convert_config", "qualname": "ConvertConfig", "type": "class", "doc": "<p>Dataset rating conversion Configuration.</p>\n\n<p>name: the name of the rating converter.\nparams: the parameters of the rating converter.</p>\n", "bases": "src.fairreckitlib.core.config.config_object.ObjectConfig"}, {"fullname": "src.fairreckitlib.data.ratings.convert_config.ConvertConfig.__init__", "modulename": "src.fairreckitlib.data.ratings.convert_config", "qualname": "ConvertConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, name: str, params: Dict[str, Any])", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.convert_config_parsing", "modulename": "src.fairreckitlib.data.ratings.convert_config_parsing", "type": "module", "doc": "<p>This module contains a parser for the dataset rating conversion configuration.</p>\n\n<p>Functions:</p>\n\n<pre><code>parse_data_convert_config: parse convert configuration.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.ratings.convert_config_parsing.parse_data_convert_config", "modulename": "src.fairreckitlib.data.ratings.convert_config_parsing", "qualname": "parse_data_convert_config", "type": "function", "doc": "<p>Parse a dataset rating converter configuration.</p>\n\n<p>Args:\n    dataset_config: the dataset's total configuration.\n    dataset: the dataset related to the converter configuration.\n    matrix_name: the dataset's matrix name to use.\n    converter_factory: the converter factory containing available converters.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    the parsed configuration or None on failure.</p>\n", "signature": "(\n    dataset_config: Dict[str, Any],\n    dataset: src.fairreckitlib.data.set.dataset.Dataset,\n    matrix_name: str,\n    converter_factory: src.fairreckitlib.core.config.config_factories.Factory,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> Optional[src.fairreckitlib.data.ratings.convert_config.ConvertConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.convert_constants", "modulename": "src.fairreckitlib.data.ratings.convert_constants", "type": "module", "doc": "<p>This module contains rating conversion constants that are used in other modules.</p>\n\n<p>Constants:</p>\n\n<pre><code>KEY_RATING_CONVERTER: key that is used to identify rating converters.\nCONVERTER_RANGE: name of the range converter.\nCONVERTER_KL: name of the kl converter.\nRATING_TYPE_THRESHOLD: determines if the rating is assumed to be explicit or implicit.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.ratings.convert_event", "modulename": "src.fairreckitlib.data.ratings.convert_event", "type": "module", "doc": "<p>This module contains event args and a print function for a rating conversion event.</p>\n\n<p>Classes:</p>\n\n<pre><code>ConvertRatingsEventArgs: event args related to converting dataframe ratings.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>print_convert_event_args: print rating conversion event arguments.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.ratings.convert_event.ConvertRatingsEventArgs", "modulename": "src.fairreckitlib.data.ratings.convert_event", "qualname": "ConvertRatingsEventArgs", "type": "class", "doc": "<p>Convert Ratings Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the rating conversion event.\nconvert_config: the rating conversion configuration that is used.</p>\n", "bases": "src.fairreckitlib.core.events.event_args.EventArgs"}, {"fullname": "src.fairreckitlib.data.ratings.convert_event.ConvertRatingsEventArgs.__init__", "modulename": "src.fairreckitlib.data.ratings.convert_event", "qualname": "ConvertRatingsEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    event_id: str,\n    convert_config: src.fairreckitlib.data.ratings.convert_config.ConvertConfig\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.convert_event.print_convert_event_args", "modulename": "src.fairreckitlib.data.ratings.convert_event", "qualname": "print_convert_event_args", "type": "function", "doc": "<p>Print convert ratings event arguments.</p>\n\n<p>It is assumed that the event started when elapsed_time is None and is finished otherwise.</p>\n\n<p>Args:\n    event_args: the arguments to print.\n    elapsed_time: the time that has passed since the conversion started, expressed in seconds.</p>\n", "signature": "(\n    event_args: src.fairreckitlib.data.ratings.convert_event.ConvertRatingsEventArgs,\n    elapsed_time: float = None\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.count", "modulename": "src.fairreckitlib.data.ratings.count", "type": "module", "doc": "<p>This module contains counting functionality.</p>\n\n<p>Both APC and ALC can be used in the Kullback-Leibler formula,\nfor which the module is also in this package.\nAs of now, they don't specifically count the 'artist'\nplay and listen count, but just whatever is in the 'item' column.\nIf you pass a dataframe for which the 'item' column contains artists,\nit should work correctly, otherwise it will require changes to work properly.</p>\n\n<p>Functions:</p>\n\n<pre><code>get_item_dict: return dict with unique items.\ncalculate_apc: count the artist play count.\ncalculate_alc: count the artist listener count.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.ratings.count.get_item_dict", "modulename": "src.fairreckitlib.data.ratings.count", "qualname": "get_item_dict", "type": "function", "doc": "<p>Make a dict with all unique items from the dataframe and starting value 0.</p>\n\n<p>Args:\n    dataframe: the dataframe from which the items are taken.</p>\n\n<p>Returns:\n    a dictionary with unique items as keys and 0 as values.</p>\n", "signature": "(dataframe: pandas.core.frame.DataFrame) -> Dict[int, float]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.count.calculate_apc", "modulename": "src.fairreckitlib.data.ratings.count", "qualname": "calculate_apc", "type": "function", "doc": "<p>Sum up the total artist play count (apc).</p>\n\n<p>Used in the Kullback-Leibler formula for converting ratings.</p>\n\n<p>Args:\n    dataframe with an item and rating header.</p>\n\n<p>Returns:\n    a dictionary with key:item, value:apc.</p>\n", "signature": "(dataframe: pandas.core.frame.DataFrame) -> Dict[int, float]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.count.calculate_alc", "modulename": "src.fairreckitlib.data.ratings.count", "qualname": "calculate_alc", "type": "function", "doc": "<p>Sum up the total artist listener count (alc).</p>\n\n<p>Used in the Kullback-Leibler formula for converting ratings.</p>\n\n<p>Args:\n    dataframe with an item and rating header.</p>\n\n<p>Returns:\n    a dictionary with key:item, value:alc.</p>\n", "signature": "(dataframe: pandas.core.frame.DataFrame) -> Dict[int, float]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.kl_converter", "modulename": "src.fairreckitlib.data.ratings.kl_converter", "type": "module", "doc": "<p>This module contains the Kullback-Leibler converter.</p>\n\n<p>This way of converting is not implemented in the data pipeline.\nThe intended use of this stems from the following paper about mainstreaminess:</p>\n\n<p>https://www.christinebauer.eu/publications/bauer-2019-plosone-mainstreaminess/</p>\n\n<p>see pages 10-11.</p>\n\n<p>This paper describes an altered version of the Kullback-Leibler formla\nand converts implicit ratings to explicit ratings in the range [0,1].</p>\n\n<p>Classes:</p>\n\n<pre><code>KLConverter: can convert ratings using the Kullback-Leibler formula.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_kl_converter: create an instance of the class (factory creation compatible).\ncreate_kl_converter_params: create kl converter config parameters.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.ratings.kl_converter.KLConverter", "modulename": "src.fairreckitlib.data.ratings.kl_converter", "qualname": "KLConverter", "type": "class", "doc": "<p>Kullback-Leibler Converter on data ratings.</p>\n\n<p>Applies the Kullback-Leibler formula to the rating column of the dataframe.</p>\n", "bases": "src.fairreckitlib.data.ratings.base_converter.RatingConverter"}, {"fullname": "src.fairreckitlib.data.ratings.kl_converter.KLConverter.run", "modulename": "src.fairreckitlib.data.ratings.kl_converter", "qualname": "KLConverter.run", "type": "function", "doc": "<p>Apply the Kullback-Leibler formula to convert ratings.</p>\n\n<p>Args:\n    dataframe: with 'user', 'item' and 'rating' columns.</p>\n\n<p>Returns:\n    the converted dataframe and the type of rating, either 'explicit' or 'implicit'.</p>\n", "signature": "(\n    self,\n    dataframe: pandas.core.frame.DataFrame\n) -> Tuple[pandas.core.frame.DataFrame, str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.kl_converter.create_kl_converter", "modulename": "src.fairreckitlib.data.ratings.kl_converter", "qualname": "create_kl_converter", "type": "function", "doc": "<p>Create the KL Converter.</p>\n\n<p>Args:\n    name: the name of the converter.\n    params: containing the following name-value pairs:\n        method(str): the method to apply, either 'APC' or 'ALC'.</p>\n\n<p>Returns:\n    the data kl converter.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any]\n) -> src.fairreckitlib.data.ratings.kl_converter.KLConverter", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.kl_converter.create_kl_converter_params", "modulename": "src.fairreckitlib.data.ratings.kl_converter", "qualname": "create_kl_converter_params", "type": "function", "doc": "<p>Create the parameters of the kl converter.</p>\n\n<p>Returns:\n    the configuration parameters of the converter.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.range_converter", "modulename": "src.fairreckitlib.data.ratings.range_converter", "type": "module", "doc": "<p>This module contains the range converting functionality.</p>\n\n<p>Classes:</p>\n\n<pre><code>RangeConverter: can convert ratings to be within in a specified range.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_range_converter: create an instance of the class (factory creation compatible).\ncreate_range_converter_params: create range converter config parameters.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.ratings.range_converter.RangeConverter", "modulename": "src.fairreckitlib.data.ratings.range_converter", "qualname": "RangeConverter", "type": "class", "doc": "<p>Range Converter on data ratings.</p>\n\n<p>Converts the rating column of the dataframe to a specified range.</p>\n", "bases": "src.fairreckitlib.data.ratings.base_converter.RatingConverter"}, {"fullname": "src.fairreckitlib.data.ratings.range_converter.RangeConverter.run", "modulename": "src.fairreckitlib.data.ratings.range_converter", "qualname": "RangeConverter.run", "type": "function", "doc": "<p>Convert ratings in the dataframe.</p>\n\n<p>Takes the max value and divides all values so that\nthey all fall within a range of [0,1], unless another upper\nbound is given by the parameters on creation. The rating can then\nalso be multiplied by a scalar, e.g. when an implicit rating is needed.</p>\n\n<p>Args:\n    dataframe: a df that should contain a 'rating' column.</p>\n\n<p>Returns:\n    the converted dataframe and the type of rating, either 'explicit' or 'implicit'.</p>\n", "signature": "(\n    self,\n    dataframe: pandas.core.frame.DataFrame\n) -> Tuple[pandas.core.frame.DataFrame, str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.range_converter.create_range_converter", "modulename": "src.fairreckitlib.data.ratings.range_converter", "qualname": "create_range_converter", "type": "function", "doc": "<p>Create the Range Converter.</p>\n\n<p>Args:\n    name: the name of the converter.\n    params: containing the following name-value pairs:\n        upper_bound(float): the upper bound of the range restriction.</p>\n\n<p>Returns:\n    the data range converter.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any]\n) -> src.fairreckitlib.data.ratings.range_converter.RangeConverter", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.range_converter.create_range_converter_params", "modulename": "src.fairreckitlib.data.ratings.range_converter", "qualname": "create_range_converter_params", "type": "function", "doc": "<p>Create the parameters of the range converter.</p>\n\n<p>Returns:\n    the configuration parameters of the converter.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.ratings.rating_converter_factory", "modulename": "src.fairreckitlib.data.ratings.rating_converter_factory", "type": "module", "doc": "<p>This module contains functionality to create the rating converter factory.</p>\n\n<p>Functions:</p>\n\n<pre><code>create_rating_converter_factory: create a factory with rating converters.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.ratings.rating_converter_factory.create_rating_converter_factory", "modulename": "src.fairreckitlib.data.ratings.rating_converter_factory", "qualname": "create_rating_converter_factory", "type": "function", "doc": "<p>Create the rating converter factory.</p>\n\n<p>Returns:\n    the factory with all available converters.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_factories.Factory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set", "modulename": "src.fairreckitlib.data.set", "type": "module", "doc": "<p>This package contains functionality for dataset definitions.</p>\n\n<p>Modules:</p>\n\n<pre><code>dataset: class wrapper for accessing a dataset and related data tables.\ndataset_config: configuration structs that define the matrix/tables.\ndataset_config_parsing: parse dataset configuration structs.\ndataset_constants: constants to be used in other modules.\ndataset_registry: registry for available datasets and processing them into a standard format.\ndataset_sampling: create a sample of an existing dataset.\n</code></pre>\n\n<p>Packages:</p>\n\n<pre><code>processor: dataset processors for various movie/music datasets.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.dataset", "modulename": "src.fairreckitlib.data.set.dataset", "type": "module", "doc": "<p>This module contains a dataset definition for accessing a dataset and related data tables.</p>\n\n<p>Classes:</p>\n\n<pre><code>Dataset: class wrapper of the user events, user-item matrices and related tables.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>add_dataset_columns: add columns from the dataset matrix/user/item tables to a dataframe.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset", "type": "class", "doc": "<p>Wrapper class for a FairRecKit dataset.</p>\n\n<p>A dataset is used for carrying out recommender system experiments.\nEach dataset has a strong affinity with a database structure consisting of\nmultiple tables.\nThe standardized matrix is a pandas.DataFrame stored in a '.tsv' file.\nThe (derived sparse) matrix is used in experiments and needs to be\nin a CSR compatible format, meaning three fields:</p>\n\n<p>1) 'user': IDs range from 0 to the amount of unique users.\n2) 'item': IDs range from 0 to the amount of unique items. An item can be\n    various of things (e.g. an artist, an album, a track, a movie, etc.)\n3) 'rating': floating-point data describing the rating a user has given an item.\n    There are two types of ratings, namely explicit or implicit, and both\n    are expected to be greater than zero.</p>\n\n<p>The matrix has one optional field which is:</p>\n\n<p>4) 'timestamp': when present can be used to split the matrix on temporal basis.</p>\n\n<p>A dataset has two main tables that are connected to the 'user' and 'item' fields.\nIndirection arrays are available when user and/or item IDs do not match up in\ntheir corresponding tables. These two tables can be used in an experiment to\nfilter any rows based on various table header criteria.\nAny additional tables can be added for accessibility/compatibility with the FRK\nrecommender system.</p>\n\n<p>Public methods:</p>\n\n<p>get_available_columns\nget_available_matrices\nget_available_tables\nget_matrices_info\nget_matrix_config\nget_matrix_file_path\nget_name\nget_table_config\nget_table_info\nload_matrix\nread_matrix\nread_table\nresolve_item_ids\nresolve_user_ids</p>\n"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.__init__", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.__init__", "type": "function", "doc": "<p>Construct the dataset.</p>\n\n<p>Args:\n    data_dir: directory where the dataset is stored.\n    config: data configuration dictionary.</p>\n", "signature": "(\n    self,\n    data_dir: str,\n    config: src.fairreckitlib.data.set.dataset_config.DatasetConfig\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.get_available_columns", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.get_available_columns", "type": "function", "doc": "<p>Get the available table column names of this dataset.</p>\n\n<p>Args:\n    matrix_name: the name of the matrix to get the available columns of.</p>\n\n<p>Returns:\n    a dictionary with table name as keys and column names as values.</p>\n", "signature": "(self, matrix_name: str) -> Dict[str, List[str]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.get_available_matrices", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.get_available_matrices", "type": "function", "doc": "<p>Get the available matrix names in the dataset.</p>\n\n<p>Returns:\n    a list of matrix names.</p>\n", "signature": "(self) -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.get_available_tables", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.get_available_tables", "type": "function", "doc": "<p>Get the available table names in the dataset.</p>\n\n<p>Returns:\n    a list of table names.</p>\n", "signature": "(self) -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.get_matrices_info", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.get_matrices_info", "type": "function", "doc": "<p>Get the information on the dataset's available matrices.</p>\n\n<p>Returns:\n    a dictionary containing the matrices' information keyed by matrix name.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.get_matrix_config", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.get_matrix_config", "type": "function", "doc": "<p>Get the configuration of a dataset's matrix.</p>\n\n<p>Args:\n    matrix_name: the name of the matrix to get the configuration of.</p>\n\n<p>Returns:\n    the configuration of the matrix or None when not available.</p>\n", "signature": "(\n    self,\n    matrix_name: str\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.get_matrix_file_path", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.get_matrix_file_path", "type": "function", "doc": "<p>Get the file path where the matrix with the specified name is stored.</p>\n\n<p>Args:\n    matrix_name: the name of the matrix to get the file path of.</p>\n\n<p>Returns:\n    the path of the dataset's matrix file or None when not available.</p>\n", "signature": "(self, matrix_name: str) -> Optional[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.get_name", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.get_name", "type": "function", "doc": "<p>Get the name of the dataset.</p>\n\n<p>Returns:\n    the dataset name.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.get_table_config", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.get_table_config", "type": "function", "doc": "<p>Get the configuration of the dataset table with the specified name.</p>\n\n<p>Args:\n    table_name: name of the table to retrieve the configuration of.</p>\n\n<p>Returns:\n    the table configuration or None when not available.</p>\n", "signature": "(\n    self,\n    table_name: str\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.get_table_info", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.get_table_info", "type": "function", "doc": "<p>Get the information on the dataset's available tables.</p>\n\n<p>Returns:\n    a dictionary containing the table information keyed by table name.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.load_matrix", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.load_matrix", "type": "function", "doc": "<p>Load the standardized user-item matrix of the dataset.</p>\n\n<p>Args:\n    matrix_name: the name of the matrix to load.</p>\n\n<p>Returns:\n    the loaded user-item matrix or None when not available.</p>\n", "signature": "(self, matrix_name: str) -> Optional[pandas.core.frame.DataFrame]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.load_item_indices", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.load_item_indices", "type": "function", "doc": "<p>Load the item indices.</p>\n\n<p>Optional indirection array of the item IDs that do not match up in\nthe corresponding data table.</p>\n\n<p>Args:\n    matrix_name: the name of the matrix to load the item indices of.</p>\n\n<p>Returns:\n    the indirection array or None when not needed.</p>\n", "signature": "(self, matrix_name: str) -> Optional[List[int]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.load_user_indices", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.load_user_indices", "type": "function", "doc": "<p>Load the user indices.</p>\n\n<p>Optional indirection array of the user IDs that do not match up in\nthe corresponding data table.</p>\n\n<p>Args:\n    matrix_name: the name of the matrix to load the user indices of.</p>\n\n<p>Returns:\n    the indirection array or None when not needed.</p>\n", "signature": "(self, matrix_name: str) -> Optional[List[int]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.read_matrix", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.read_matrix", "type": "function", "doc": "<p>Read the matrix with the specified name from the dataset.</p>\n\n<p>Args:\n    matrix_name: the name of the matrix to load.\n    columns: subset list of columns to load or None to load all.\n        All elements must either be integer indices or\n        strings that correspond to the one of the available table columns.\n    chunk_size: reads the matrix in chunks as an iterator or\n        the entire table when None.</p>\n\n<p>Returns:\n    the resulting matrix dataframe (iterator) or None when not available.</p>\n", "signature": "(\n    self,\n    matrix_name: str,\n    columns: List[Union[str, int]] = None,\n    chunk_size: int = None\n) -> Optional[pandas.core.frame.DataFrame]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.read_table", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.read_table", "type": "function", "doc": "<p>Read the table with the specified name from the dataset.</p>\n\n<p>Args:\n    table_name: name of the table to read.\n    columns: subset list of columns to load or None to load all.\n        All elements must either be integer indices or\n        strings that correspond to the one of the available table columns.\n    chunk_size: reads the table in chunks as an iterator or\n        the entire table when None.</p>\n\n<p>Returns:\n    the resulting table dataframe (iterator) or None when not available.</p>\n", "signature": "(\n    self,\n    table_name: str,\n    columns: List[Union[str, int]] = None,\n    chunk_size: int = None\n) -> Optional[pandas.core.frame.DataFrame]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.resolve_item_ids", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.resolve_item_ids", "type": "function", "doc": "<p>Resolve the specified item ID(s).</p>\n\n<p>The item ID(s) of a dataset need to be resolved when it contains\nan indirection array, otherwise ID(s) are returned unchanged.</p>\n\n<p>Args:\n    matrix_name: the name of the matrix to resolve the item indices of.\n    items: source ID(s) to convert.</p>\n\n<p>Returns:\n    the resolved item ID(s).</p>\n", "signature": "(\n    self,\n    matrix_name: str,\n    items: Union[int, List[int]]\n) -> Union[int, List[int]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.Dataset.resolve_user_ids", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "Dataset.resolve_user_ids", "type": "function", "doc": "<p>Resolve the specified user ID(s).</p>\n\n<p>The user ID(s) of a dataset need to be resolved when it contains\nan indirection array, otherwise ID(s) are returned unchanged.</p>\n\n<p>Args:\n    matrix_name: the name of the matrix to resolve the user indices of.\n    users: source ID(s) to convert.</p>\n\n<p>Returns:\n    the resolved user ID(s).</p>\n", "signature": "(\n    self,\n    matrix_name: str,\n    users: Union[int, List[int]]\n) -> Union[int, List[int]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset.add_dataset_columns", "modulename": "src.fairreckitlib.data.set.dataset", "qualname": "add_dataset_columns", "type": "function", "doc": "<p>Add the specified columns from the dataset to the dataframe.</p>\n\n<p>Args:\n    dataset: the set related to the dataframe.\n    matrix_name: the name of the dataset matrix.\n    dataframe: with at least the 'user' and/or 'item' columns.\n    column_names: a list of strings to indicate which\n        user and/or item columns need to be added. Any values that are not\n        present in the dataset tables are ignored.</p>\n\n<p>Returns:\n    the resulting dataframe with the added columns that exist in the dataset.</p>\n", "signature": "(\n    dataset: src.fairreckitlib.data.set.dataset.Dataset,\n    matrix_name: str,\n    dataframe: pandas.core.frame.DataFrame,\n    column_names: List[str]\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config", "modulename": "src.fairreckitlib.data.set.dataset_config", "type": "module", "doc": "<p>This module contains the dataset configuration classes and creation functions.</p>\n\n<p>Constants:</p>\n\n<pre><code>DATASET_RATINGS_EXPLICIT: dataset matrix with explicit ratings.\nDATASET_RATINGS_IMPLICIT: dataset matrix with implicit ratings.\n</code></pre>\n\n<p>Classes:</p>\n\n<pre><code>DatasetFileConfig: the configuration of a dataset file.\nDatasetTableConfig: the configuration of a dataset table.\nDatasetIndexConfig: the configuration of a dataset matrix' user/item indices.\nDatasetMatrixConfig: the configuration of a dataset matrix.\nDatasetConfig: the configuration of a dataset.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_dataset_table_config: create configuration for a dataset table.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetFileConfig", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetFileConfig", "type": "class", "doc": "<p>Dataset File Configuration.</p>\n\n<p>name: the file name.\nsep: the separator in the file or None for \\t.\ncompression: the (optional) compression of the file.\nencoding: the encoding of the file or None for 'utf-8'.\nheader: is there a header on the first line of the file.\nindexed: are the row indices the table's primary key.</p>\n", "bases": "src.fairreckitlib.core.config.config_yml.YmlConfig"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetFileConfig.__init__", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetFileConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    name: str,\n    sep: Optional[str],\n    compression: Optional[str],\n    encoding: Optional[str],\n    header: bool,\n    indexed: bool\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetFileConfig.to_yml_format", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetFileConfig.to_yml_format", "type": "function", "doc": "<p>Format dataset file configuration to a yml compatible dictionary.</p>\n\n<p>Returns:\n    a dictionary containing the dataset file configuration.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetTableConfig", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetTableConfig", "type": "class", "doc": "<p>Dataset Table Configuration.</p>\n\n<p>The configuration expects the table to have the primary key as the first column(s) and in order\nin which they are specified. These are followed by the columns of relevant data and any foreign\nkeys should be in order as the last column(s). However, it is also allowed that the foreign\nkeys describe the primary key, but individually rather than the combination of.</p>\n\n<p>primary_key: list of column names that form the primary key of the table.\nforeign_keys: (optional) list of column names that are foreign keys in other tables.\ncolumns: list of column names that contain the relevant table data.\nnum_records: the number of records in the table.\nfile: the dataset file configuration of the table.</p>\n", "bases": "src.fairreckitlib.core.config.config_yml.YmlConfig"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetTableConfig.__init__", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetTableConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    primary_key: List[str],\n    foreign_keys: Optional[List[str]],\n    columns: List[str],\n    num_records: int,\n    file: src.fairreckitlib.data.set.dataset_config.DatasetFileConfig\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetTableConfig.read_table", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetTableConfig.read_table", "type": "function", "doc": "<p>Read the table from the specified directory.</p>\n\n<p>Args:\n    dataset_dir: the directory to read the table from.\n    columns: subset list of columns to load or None to load all.\n        All elements must either be integer indices or\n        strings that correspond to the 'names' argument.\n    chunk_size: loads the table in chunks as an iterator or\n        the entire table when None.</p>\n\n<p>Returns:\n    the resulting table (iterator).</p>\n", "signature": "(\n    self,\n    dataset_dir: str,\n    *,\n    columns: List[Union[str, int]] = None,\n    chunk_size=None\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetTableConfig.save_table", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetTableConfig.save_table", "type": "function", "doc": "<p>Save the table in the specified directory.</p>\n\n<p>Args:\n    dataset_table: the dataframe to save with this table configuration.\n    dataset_dir: the directory to save the table to.</p>\n", "signature": "(\n    self,\n    dataset_table: pandas.core.frame.DataFrame,\n    dataset_dir: str\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetTableConfig.to_yml_format", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetTableConfig.to_yml_format", "type": "function", "doc": "<p>Format dataset table configuration to a yml compatible dictionary.</p>\n\n<p>Returns:\n    a dictionary containing the dataset table configuration.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetIndexConfig", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetIndexConfig", "type": "class", "doc": "<p>Dataset Matrix' Index Configuration.</p>\n\n<p>file_name: (optional) file name that contains the user/item indirection array.\nkey: the key that is associated with the user/item.\nnum_records: the number of user/item records</p>\n", "bases": "src.fairreckitlib.core.config.config_yml.YmlConfig"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetIndexConfig.__init__", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetIndexConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, file_name: Optional[str], key: str, num_records: int)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetIndexConfig.load_indices", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetIndexConfig.load_indices", "type": "function", "doc": "<p>Load the indices from the specified directory.</p>\n\n<p>This function raises a FileNotFoundError when the file is not\nfound in the specified directory.</p>\n\n<p>Args:\n    dataset_dir: the directory to load the indices from.</p>\n\n<p>Returns:\n    the resulting indices or None when not available.</p>\n", "signature": "(self, dataset_dir: str) -> Optional[List[int]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetIndexConfig.save_indices", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetIndexConfig.save_indices", "type": "function", "doc": "<p>Save the indices to the specified directory.</p>\n\n<p>Args:\n    dataset_dir: the directory to save the indices to.\n    indices: the list of indices to save.</p>\n\n<p>Returns:\n    true when the indices are saved or false when the configuration has no file name.</p>\n", "signature": "(self, dataset_dir: str, indices: List[int]) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetIndexConfig.to_yml_format", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetIndexConfig.to_yml_format", "type": "function", "doc": "<p>Format dataset index configuration to a yml compatible dictionary.</p>\n\n<p>Returns:\n    a dictionary containing the dataset index configuration.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetMatrixConfig", "type": "class", "doc": "<p>Dataset Matrix Configuration.</p>\n\n<p>table: the table configuration of the matrix.\nrating_min: the minimum rating in the matrix.\nrating_max: the maximum rating in the matrix.\nrating_type: the type of the rating in the matrix, either 'explicit' or 'implicit'.\nuser: the dataset index configuration for the users in the matrix.\nitem: the dataset index configuration for the items in the matrix.</p>\n", "bases": "src.fairreckitlib.core.config.config_yml.YmlConfig"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig.__init__", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetMatrixConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    table: src.fairreckitlib.data.set.dataset_config.DatasetTableConfig,\n    rating_min: float,\n    rating_max: float,\n    rating_type: str,\n    user: src.fairreckitlib.data.set.dataset_config.DatasetIndexConfig,\n    item: src.fairreckitlib.data.set.dataset_config.DatasetIndexConfig\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig.load_matrix", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetMatrixConfig.load_matrix", "type": "function", "doc": "<p>Load the matrix from the specified directory.</p>\n\n<p>Args:\n    dataset_dir: directory path to where the dataset matrix is stored.</p>\n\n<p>Returns:\n    the resulting matrix (iterator).</p>\n", "signature": "(self, dataset_dir: str) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig.to_yml_format", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetMatrixConfig.to_yml_format", "type": "function", "doc": "<p>Format dataset matrix configuration to a yml compatible dictionary.</p>\n\n<p>Returns:\n    a dictionary containing the dataset matrix configuration.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetConfig", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetConfig", "type": "class", "doc": "<p>Dataset Configuration.</p>\n\n<p>dataset_name: the name of the dataset.\nevents: dictionary containing the available user event tables.\nmatrices: dictionary containing the available user-item matrices.\ntables: dictionary containing the (additionally) available tables.</p>\n", "bases": "src.fairreckitlib.core.config.config_yml.YmlConfig"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetConfig.__init__", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    dataset_name: str,\n    events: Dict[str, src.fairreckitlib.data.set.dataset_config.DatasetTableConfig],\n    matrices: Dict[str, src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig],\n    tables: Dict[str, src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetConfig.get_available_columns", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetConfig.get_available_columns", "type": "function", "doc": "<p>Get the available columns of the specified matrix.</p>\n\n<p>Only the table names and columns that have a one-to-one relation will be returned.\nThis function does not raise errors and will return an empty dictionary when\nthe specified matrix is not present in the dataset.</p>\n\n<p>Args:\n    matrix_name: the name of the matrix to get the available columns of.</p>\n\n<p>Returns:\n    a dictionary containing the table names as key and the available columns as value.</p>\n", "signature": "(self, matrix_name: str) -> Dict[str, List[str]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.DatasetConfig.to_yml_format", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "DatasetConfig.to_yml_format", "type": "function", "doc": "<p>Format dataset configuration to a yml compatible dictionary.</p>\n\n<p>Returns:\n    a dictionary containing the dataset configuration.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config.create_dataset_table_config", "modulename": "src.fairreckitlib.data.set.dataset_config", "qualname": "create_dataset_table_config", "type": "function", "doc": "<p>Create a dataset table configuration.</p>\n\n<p>Args:\n    file_name: name of the dataset table file.\n    primary_key: a list of strings that are combined the primary key of the table.\n    columns: a list of strings with other available columns in the table.\n    compression:  the (optional) compression of the file, 'bz2' is recommended.\n    encoding: the encoding for reading/writing the table contents or None for 'utf-8'.\n    foreign_keys: (optional) list of column names that are foreign keys in other tables.\n    header: whether the table file contains a header on the first line.\n    indexed: are the row indices the table's primary key.\n    num_records: the number of records in the table.\n    sep: the delimiter that is used in the table or None for a tab separator.</p>\n\n<p>Returns:\n    the resulting data table configuration.</p>\n", "signature": "(\n    file_name: str,\n    primary_key: List[str],\n    columns: List[str],\n    *,\n    compression: str = None,\n    encoding: str = None,\n    foreign_keys: List[str] = None,\n    header: bool = False,\n    indexed: bool = False,\n    num_records: int = 0,\n    sep: str = None\n) -> src.fairreckitlib.data.set.dataset_config.DatasetTableConfig", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config_parsing", "modulename": "src.fairreckitlib.data.set.dataset_config_parsing", "type": "module", "doc": "<p>This module contains a parser for the dataset configuration.</p>\n\n<p>Functions:</p>\n\n<pre><code>parse_dataset_file_config: parse dataset file configuration.\nparse_dataset_table_config: parse dataset table configuration.\nparse_dataset_index_config: parse dataset matrix' user/item configuration.\nparse_dataset_matrix_config: parse dataset matrix configuration.\nparse_dataset_config: parse dataset configuration.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.dataset_config_parsing.parse_dataset_file_config", "modulename": "src.fairreckitlib.data.set.dataset_config_parsing", "qualname": "parse_dataset_file_config", "type": "function", "doc": "<p>Parse a dataset file configuration.</p>\n\n<p>Args:\n    file_config: the dataset file configuration.</p>\n\n<p>Returns:\n    the parsed configuration or None on failure.</p>\n", "signature": "(\n    file_config: Dict[str, Any]\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetFileConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config_parsing.parse_dataset_table_config", "modulename": "src.fairreckitlib.data.set.dataset_config_parsing", "qualname": "parse_dataset_table_config", "type": "function", "doc": "<p>Parse a dataset table configuration.</p>\n\n<p>Args:\n    table_config: the dataset table configuration.</p>\n\n<p>Returns:\n    the parsed configuration or None on failure.</p>\n", "signature": "(\n    table_config: Dict[str, Any]\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config_parsing.parse_dataset_index_config", "modulename": "src.fairreckitlib.data.set.dataset_config_parsing", "qualname": "parse_dataset_index_config", "type": "function", "doc": "<p>Parse a dataset matrix' user/item index configuration.</p>\n\n<p>Args:\n    index_config: the dataset matrix index configuration.</p>\n\n<p>Returns:\n    the parsed configuration or None on failure.</p>\n", "signature": "(\n    index_config: Dict[str, Any]\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetIndexConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config_parsing.parse_dataset_matrix_config", "modulename": "src.fairreckitlib.data.set.dataset_config_parsing", "qualname": "parse_dataset_matrix_config", "type": "function", "doc": "<p>Parse a dataset matrix configuration.</p>\n\n<p>Args:\n    matrix_config: the dataset matrix configuration.</p>\n\n<p>Returns:\n    the parsed configuration or None on failure.</p>\n", "signature": "(\n    matrix_config: Dict[str, Any]\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_config_parsing.parse_dataset_config", "modulename": "src.fairreckitlib.data.set.dataset_config_parsing", "qualname": "parse_dataset_config", "type": "function", "doc": "<p>Parse a dataset configuration.</p>\n\n<p>Args:\n    dataset_config: the dataset configuration.</p>\n\n<p>Returns:\n    the parsed configuration or None on failure.</p>\n", "signature": "(\n    dataset_config: Dict[str, Any]\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_constants", "modulename": "src.fairreckitlib.data.set.dataset_constants", "type": "module", "doc": "<p>This module contains dataset (configuration) constants that are used in other modules.</p>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.dataset_registry", "modulename": "src.fairreckitlib.data.set.dataset_registry", "type": "module", "doc": "<p>This module contains the data registry class.</p>\n\n<p>Classes:</p>\n\n<pre><code>DataRegistry: registry for available datasets after processing them into a standard format.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.dataset_registry.DataRegistry", "modulename": "src.fairreckitlib.data.set.dataset_registry", "qualname": "DataRegistry", "type": "class", "doc": "<p>Data Registry with available datasets.</p>\n\n<p>The data directory is expected to exist or will raise an IOError.\nEach subdirectory is considered to store a single dataset. The name of\nthe subdirectory needs to be exactly the same as one of the available\nprocessors to trigger automatic data processing.</p>\n\n<p>Public methods:</p>\n\n<p>get_available_processors\nget_available_sets\nget_info\nget_set</p>\n"}, {"fullname": "src.fairreckitlib.data.set.dataset_registry.DataRegistry.__init__", "modulename": "src.fairreckitlib.data.set.dataset_registry", "qualname": "DataRegistry.__init__", "type": "function", "doc": "<p>Construct the data registry and scan for available datasets.</p>\n\n<p>Args:\n    data_dir: path to the directory that contains the datasets.</p>\n", "signature": "(self, data_dir: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_registry.DataRegistry.get_available_processors", "modulename": "src.fairreckitlib.data.set.dataset_registry", "qualname": "DataRegistry.get_available_processors", "type": "function", "doc": "<p>Get the names of the available processors in the registry.</p>\n\n<p>Returns:\n    a list of data processor names.</p>\n", "signature": "(self) -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_registry.DataRegistry.get_available_sets", "modulename": "src.fairreckitlib.data.set.dataset_registry", "qualname": "DataRegistry.get_available_sets", "type": "function", "doc": "<p>Get the names of the available datasets in the registry.</p>\n\n<p>Returns:\n    a list of dataset names.</p>\n", "signature": "(self) -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_registry.DataRegistry.get_info", "modulename": "src.fairreckitlib.data.set.dataset_registry", "qualname": "DataRegistry.get_info", "type": "function", "doc": "<p>Get the matrices' information for each available dataset.</p>\n\n<p>Returns:\n    a dictionary where the key corresponds to the dataset name and\n        the value corresponds to the matrices' information dictionary.</p>\n", "signature": "(self) -> Dict[str, Dict[str, Any]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_registry.DataRegistry.get_set", "modulename": "src.fairreckitlib.data.set.dataset_registry", "qualname": "DataRegistry.get_set", "type": "function", "doc": "<p>Get the dataset with the specified name.</p>\n\n<p>Args:\n    dataset_name: name of the dataset to retrieve.</p>\n\n<p>Returns:\n    the retrieved set or None when not present.</p>\n", "signature": "(\n    self,\n    dataset_name: str\n) -> Optional[src.fairreckitlib.data.set.dataset.Dataset]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_sampling", "modulename": "src.fairreckitlib.data.set.dataset_sampling", "type": "module", "doc": "<p>This module contains functionality to create a sample of an existing dataset.</p>\n\n<p>Functions:</p>\n\n<pre><code>create_dataset_sample: create a sample of a dataset.\ncreate_dataset_table_samples: create tables samples for a map of key indices.\ncreate_matrix_sample_config: create a sample matrix configuration.\ncreate_matrix_sample: create a sample of a dataset's matrix.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.dataset_sampling.create_dataset_sample", "modulename": "src.fairreckitlib.data.set.dataset_sampling", "qualname": "create_dataset_sample", "type": "function", "doc": "<p>Create a sample of the specified dataset.</p>\n\n<p>Look at the 'create_matrix_sample' function for specifics on how the\nmatrices of the dataset are sampled. All tables, except the events, that are related\nto the user/item keys that are present in the sample matrices are sampled as well.\nThe generated dataset sample is stored in the output directory before returning it.\nThis function raises an IOError when the specified output directory already exists.</p>\n\n<p>Args:\n    output_dir: the path to the directory where the dataset sample will be stored.\n    dataset: the dataset to create a sample of.\n    num_users: the number of users in the created sample matrices.\n    num_items: the number of items in the created sample matrices.</p>\n\n<p>Returns:\n    the resulting sample dataset.</p>\n", "signature": "(\n    output_dir: str,\n    dataset: src.fairreckitlib.data.set.dataset.Dataset,\n    num_users: int,\n    num_items: int\n) -> src.fairreckitlib.data.set.dataset.Dataset", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_sampling.create_dataset_table_samples", "modulename": "src.fairreckitlib.data.set.dataset_sampling", "qualname": "create_dataset_table_samples", "type": "function", "doc": "<p>Create table samples for the specified dataset and key map.</p>\n\n<p>The key map is used to identify which tables of the dataset are sampled.\nA table is considered to be a candidate if the key in the map matches the\nprimary key of the table. Any rows that do not contain the needed indices\nin the key map are filtered.</p>\n\n<p>Args:\n    output_dir: the path to the directory where the sample tables will be stored.\n    dataset: the dataset to create a sample tables from.\n    key_id_map: a dictionary containing a table key paired with a list of indices\n        that are related to these table keys.</p>\n\n<p>Returns:\n    a dictionary with the resulting table sample configurations, keyed by table names.</p>\n", "signature": "(\n    output_dir: str,\n    dataset: src.fairreckitlib.data.set.dataset.Dataset,\n    key_id_map: Dict[str, List[int]]\n) -> Dict[str, src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_sampling.create_matrix_sample_config", "modulename": "src.fairreckitlib.data.set.dataset_sampling", "qualname": "create_matrix_sample_config", "type": "function", "doc": "<p>Create a dataset matrix sample configuration.</p>\n\n<p>Look at the 'create_matrix_sample' function for specifics on how the\nmatrix is sampled. The generated matrix and user/item indirection arrays are\nstored in the output directory and the corresponding configuration is returned.</p>\n\n<p>Args:\n    output_dir: the path to the directory where the sample matrix will be stored.\n    dataset: the dataset to create a sample matrix from.\n    matrix_name: the name of the matrix to create a sample of.\n    num_users: the number of users in the created sample matrix.\n    num_items: the number of items in the created sample matrix.</p>\n\n<p>Returns:\n    the sample matrix configuration or None when the specified matrix does not exist.</p>\n", "signature": "(\n    output_dir: str,\n    dataset: src.fairreckitlib.data.set.dataset.Dataset,\n    matrix_name: str,\n    num_users: int,\n    num_items: int\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.dataset_sampling.create_matrix_sample", "modulename": "src.fairreckitlib.data.set.dataset_sampling", "qualname": "create_matrix_sample", "type": "function", "doc": "<p>Create a sample for the specified matrix.</p>\n\n<p>Extracts a sample with the first occurring users and items until the\nspecified amounts are reached, and therefore are only used as an indication.\nNo additional users/items are generated when the dataset matrix has\nless available amounts than is specified. Moreover, due to the sparsity of the\nmatrix it can turn out that the resulting matrix is very close, but not\nexactly the specified amounts.</p>\n\n<p>Args:\n    dataset: the dataset to create a sample matrix from.\n    matrix_name: the name of the matrix to create a sample of.\n    num_users: the number of users in the created sample matrix.\n    num_items: the number of items in the created sample matrix.</p>\n\n<p>Returns:\n    the sample matrix, the unique user and unique item indices.</p>\n", "signature": "(\n    dataset: src.fairreckitlib.data.set.dataset.Dataset,\n    matrix_name: str,\n    num_users: int,\n    num_items: int\n) -> Tuple[pandas.core.frame.DataFrame, List[int], List[int]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor", "modulename": "src.fairreckitlib.data.set.processor", "type": "module", "doc": "<p>This package contains dataset processors for various movie/music datasets.</p>\n\n<p>Modules:</p>\n\n<pre><code>dataset_processor_base: base class for all dataset processors.\ndataset_processor_lfm: base class for LastFM dataset processors.\ndataset_processor_lfm_1b: class to process the LastFM-1B dataset.\ndataset_processor_lfm_2b: class to process the LastFM-2B dataset.\ndataset_processor_lfm_360k: class to process the LastFM-360K dataset.\ndataset_processor_ml: base class for MovieLens dataset processors.\ndataset_processor_ml_25m: class to process the MovieLens-25M dataset.\ndataset_processor_ml_100k: class to process the MovieLens-100K dataset.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_base", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_base", "type": "module", "doc": "<p>This module contains the base functionality shared by all dataset processors.</p>\n\n<p>Classes:</p>\n\n<pre><code>DatasetProcessorBase: the base class for dataset processors.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_base.DatasetProcessorBase", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_base", "qualname": "DatasetProcessorBase", "type": "class", "doc": "<p>DataProcessor base class for all FairRecKit datasets.</p>\n\n<p>Datasets are preprocessed so that they will be of a recognized standard format\non the other side. A configuration file is produced in the resulting dataset\ndirectory that stores the metadata for achieving this. For further information\nit is advised to take a look at the Dataset(Config) class.</p>\n\n<p>The dataset configuration mainly consists of:</p>\n\n<p>1) event tables: contain user event tables that can be used to construct a matrix of.\n2) matrix tables: contain available matrices associated with the dataset.\n3) (other) tables: contain the shared tables associated with the dataset.</p>\n\n<p>For each of these three categories an abstract function is exposed in order to retrieve\n(table name, table configuration processor) tuples. The tables names are expected to be\nunique across all categories. The table configuration processors are allowed to return\nNone on failure and will be excluded from the final configuration. Moreover, tables that\ndo not contain any records are excluded as well.\nThe base dataset processor handles the processing logic. It needs to produce at least\none valid event table or one valid matrix configuration to be successful, concluding\nthat remaining tables are optional.</p>\n\n<p>Abstract methods:</p>\n\n<p>get_event_configs\nget_matrix_configs\nget_table_configs</p>\n\n<p>Public methods:</p>\n\n<p>run</p>\n"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_base.DatasetProcessorBase.__init__", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_base", "qualname": "DatasetProcessorBase.__init__", "type": "function", "doc": "<p>Construct the base DatasetProcessor.</p>\n\n<p>Args:\n    dataset_name: path of the dataset directory.\n    dataset_name: name of the dataset (processor).</p>\n", "signature": "(self, dataset_dir: str, dataset_name: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_base.DatasetProcessorBase.get_event_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_base", "qualname": "DatasetProcessorBase.get_event_configs", "type": "function", "doc": "<p>Get event table configuration processors.</p>\n\n<p>Returns:\n    a list of tuples consisting of the event table name and the event table processor.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_base.DatasetProcessorBase.get_matrix_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_base", "qualname": "DatasetProcessorBase.get_matrix_configs", "type": "function", "doc": "<p>Get matrix configuration processors.</p>\n\n<p>Returns:\n    a list of tuples consisting of the matrix name and the matrix processor.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_base.DatasetProcessorBase.get_table_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_base", "qualname": "DatasetProcessorBase.get_table_configs", "type": "function", "doc": "<p>Get table configuration processors.</p>\n\n<p>Returns:\n    a list of tuples consisting of the table name and the table processor.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_base.DatasetProcessorBase.run_event_table_processors", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_base", "qualname": "DatasetProcessorBase.run_event_table_processors", "type": "function", "doc": "<p>Run the dataset's event table processors.</p>\n\n<p>Returns:\n    a dictionary with valid event table name-configuration pairs.</p>\n", "signature": "(\n    self\n) -> Dict[str, src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_base.DatasetProcessorBase.run_matrix_table_processors", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_base", "qualname": "DatasetProcessorBase.run_matrix_table_processors", "type": "function", "doc": "<p>Run the dataset's matrix processors.</p>\n\n<p>Returns:\n    a dictionary with valid matrix name-configuration pairs.</p>\n", "signature": "(\n    self\n) -> Dict[str, src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_base.DatasetProcessorBase.run_table_processors", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_base", "qualname": "DatasetProcessorBase.run_table_processors", "type": "function", "doc": "<p>Run the dataset's additional table processors.</p>\n\n<p>Returns:\n    a dictionary with valid table name-configuration pairs.</p>\n", "signature": "(\n    self\n) -> Dict[str, src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_base.DatasetProcessorBase.run", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_base", "qualname": "DatasetProcessorBase.run", "type": "function", "doc": "<p>Run the dataset configuration processor.</p>\n\n<p>Returns:\n    the dataset configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm", "type": "module", "doc": "<p>This module contains the base processor for LastFM datasets.</p>\n\n<p>Classes:</p>\n\n<pre><code>DatasetProcessorLFM: the base class for LastFM dataset processors.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm.DatasetProcessorLFM", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm", "qualname": "DatasetProcessorLFM", "type": "class", "doc": "<p>DataProcessor base class for LastFM datasets.</p>\n\n<p>Provides an abstraction for processing the listening event table,\nand also for generalizing the user table data. An iterative matrix\nprocessor function is exposed for derived subclasses as the LastFM\ndataset matrices tend to be very big.</p>\n\n<p>Abstract methods:</p>\n\n<p>create_listening_events_config\ncreate_user_table_config</p>\n", "bases": "src.fairreckitlib.data.set.processor.dataset_processor_base.DatasetProcessorBase"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm.DatasetProcessorLFM.create_listening_events_config", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm", "qualname": "DatasetProcessorLFM.create_listening_events_config", "type": "function", "doc": "<p>Create the listening event table configuration.</p>\n\n<p>Returns:\n    the configuration of the listening event table or None when not available.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm.DatasetProcessorLFM.create_user_table_config", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm", "qualname": "DatasetProcessorLFM.create_user_table_config", "type": "function", "doc": "<p>Create the user table configuration.</p>\n\n<p>Returns:\n    the configuration of the user table.</p>\n", "signature": "(self) -> src.fairreckitlib.data.set.dataset_config.DatasetTableConfig", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm.DatasetProcessorLFM.get_event_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm", "qualname": "DatasetProcessorLFM.get_event_configs", "type": "function", "doc": "<p>Get event table configuration processors.</p>\n\n<p>Returns:\n    a list containing the listening event table processor.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm.DatasetProcessorLFM.get_table_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm", "qualname": "DatasetProcessorLFM.get_table_configs", "type": "function", "doc": "<p>Get table configuration processors.</p>\n\n<p>Derived implementations are expected to call the super implementation in\norder to include the user table in the configuration.</p>\n\n<p>Returns:\n    a list containing the user table processor.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm.DatasetProcessorLFM.process_listening_events", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm", "qualname": "DatasetProcessorLFM.process_listening_events", "type": "function", "doc": "<p>Process the listening event table.</p>\n\n<p>Returns:\n    the listening event table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm.DatasetProcessorLFM.process_matrix", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm", "qualname": "DatasetProcessorLFM.process_matrix", "type": "function", "doc": "<p>Process the matrix with the specified configuration.</p>\n\n<p>Args:\n    matrix_table_config: the configuration of the matrix to process.\n    user_idx_file: the file name of the user indices or None when not present.\n    item_idx_file: the file name of the item indices or None when not present.</p>\n\n<p>Returns:\n    the matrix configuration or None on failure.</p>\n", "signature": "(\n    self,\n    matrix_table_config: src.fairreckitlib.data.set.dataset_config.DatasetTableConfig,\n    user_idx_file: str = None,\n    item_idx_file: str = None\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm.DatasetProcessorLFM.process_user_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm", "qualname": "DatasetProcessorLFM.process_user_table", "type": "function", "doc": "<p>Process the user table.</p>\n\n<p>Changes the contents of the gender column to be more user-friendly,\nand the contents of the age column to -1 when above 100.</p>\n\n<p>Returns:\n    the user table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "type": "module", "doc": "<p>This modules contains the class to process the LastFM-1B dataset.</p>\n\n<p>Classes:</p>\n\n<pre><code>DatasetProcessorLFM1B: data processor implementation for the LFM-1B dataset.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B", "type": "class", "doc": "<p>DatasetProcessor for the LastFM-1B dataset.</p>\n\n<p>The dataset and UGP (user genre profile) can be downloaded from the website below.\nhttp://www.cp.jku.at/datasets/LFM-1b/</p>\n\n<p>The enriched artist gender information can be retrieved from:\nhttps://zenodo.org/record/3748787#.YowEBqhByUk</p>\n\n<p>The processor handles the following files:</p>\n\n<p>LFM-1b_albums.txt (optional)\nLFM-1b_artist_genres_allmusic.txt (optional)\nLFM-1b_artists.txt (optional)\nLFM-1b_LEs.mat (required)\nLFM-1b_LEs.txt (required)\nLFM-1b_tracks.txt (optional)\nLFM-1b_UGP_noPC_allmusic.txt (optional)\nLFM-1b_UGP_weightedPC_allmusic.txt (optional)\nLFM-1b_users.txt (optional)\nLFM-1b_users_additional.txt (optional)\nlfm-gender.json (optional)</p>\n", "bases": "src.fairreckitlib.data.set.processor.dataset_processor_lfm.DatasetProcessorLFM"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B.create_listening_events_config", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B.create_listening_events_config", "type": "function", "doc": "<p>Create the listening event table configuration.</p>\n\n<p>Returns:\n    the configuration of the listening event table.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B.create_user_table_config", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B.create_user_table_config", "type": "function", "doc": "<p>Create the user table configuration.</p>\n\n<p>Returns:\n    the configuration of the user table.</p>\n", "signature": "(self) -> src.fairreckitlib.data.set.dataset_config.DatasetTableConfig", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B.get_matrix_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B.get_matrix_configs", "type": "function", "doc": "<p>Get matrix configuration processors.</p>\n\n<p>Returns:\n    a list containing the user-artist-count matrix processor.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B.get_table_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B.get_table_configs", "type": "function", "doc": "<p>Get table configuration processors.</p>\n\n<p>Returns:\n    a list containing the album, allmusic genre, artist, track and user table processors.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B.load_artist_gender_json", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B.load_artist_gender_json", "type": "function", "doc": "<p>Load the artist gender json file.</p>\n\n<p>Returns:\n    the loaded artist id/gender table or None on failure.</p>\n", "signature": "(self) -> Optional[pandas.core.frame.DataFrame]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B.load_artist_genres_allmusic", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B.load_artist_genres_allmusic", "type": "function", "doc": "<p>Load the artist allmusic genres file.</p>\n\n<p>Returns:\n    the loaded artist name/genre table or None on failure.</p>\n", "signature": "(self) -> Optional[pandas.core.frame.DataFrame]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B.process_album_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B.process_album_table", "type": "function", "doc": "<p>Process the album table.</p>\n\n<p>Returns:\n    the album table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B.process_artist_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B.process_artist_table", "type": "function", "doc": "<p>Process the artist table.</p>\n\n<p>Extends the table with artist gender and genres information when available.</p>\n\n<p>Returns:\n    the artist table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B.process_genres_allmusic", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B.process_genres_allmusic", "type": "function", "doc": "<p>Process the allmusic genres table.</p>\n\n<p>Returns:\n    the allmusic genres table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B.process_track_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B.process_track_table", "type": "function", "doc": "<p>Process the track table.</p>\n\n<p>Returns:\n    the track table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B.process_user_artist_matrix", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B.process_user_artist_matrix", "type": "function", "doc": "<p>Process the user-artist-count matrix.</p>\n\n<p>The user-item matrix is stored in a matlab file in CSR compatible format,\ntogether with the user and item indices. The matrix is converted\nto a dataframe and the indices for the indirection arrays are flattened.</p>\n\n<p>Returns:\n    the matrix configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B.process_user_additional_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B.process_user_additional_table", "type": "function", "doc": "<p>Process the user additional table.</p>\n\n<p>Returns:\n    the user additional table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B.process_user_genre_allmusic_no_pc", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B.process_user_genre_allmusic_no_pc", "type": "function", "doc": "<p>Process the user allmusic genre table.</p>\n\n<p>Returns:\n    the user allmusic genre table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b.DatasetProcessorLFM1B.process_user_genre_allmusic_weighted_pc", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm1b", "qualname": "DatasetProcessorLFM1B.process_user_genre_allmusic_weighted_pc", "type": "function", "doc": "<p>Process the user allmusic genre table with weighted play count.</p>\n\n<p>Returns:\n    the user allmusic genre table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b", "type": "module", "doc": "<p>This modules contains the class to process the LastFM-2B dataset.</p>\n\n<p>Classes:</p>\n\n<pre><code>DatasetProcessorLFM2B: data processor implementation for the LFM-2B dataset.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b.DatasetProcessorLFM2B", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b", "qualname": "DatasetProcessorLFM2B", "type": "class", "doc": "<p>DatasetProcessor for the LastFM-2B dataset.</p>\n\n<p>The dataset can be downloaded from the website below.\nhttp://www.cp.jku.at/datasets/LFM-2b/</p>\n\n<p>Note that the compressed bz2 files can be used directly.\nThe processor handles the following files:</p>\n\n<p>albums.tsv.bz2 (optional)\nartists.tsv.bz2 (optional)\nlistening-counts.tsv.bz2 (required)\nlistening-events.tsv.bz2 (required)\nspotify-uris.tsv.bz2 (optional)\ntracks.tsv.bz2 (optional)\nusers.tsv.bz2 (optional)\nuser_artist_playcount.tsv (required)</p>\n", "bases": "src.fairreckitlib.data.set.processor.dataset_processor_lfm.DatasetProcessorLFM"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b.DatasetProcessorLFM2B.create_listening_events_config", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b", "qualname": "DatasetProcessorLFM2B.create_listening_events_config", "type": "function", "doc": "<p>Create the listening event table configuration.</p>\n\n<p>Returns:\n    the configuration of the listening event table.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b.DatasetProcessorLFM2B.create_user_table_config", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b", "qualname": "DatasetProcessorLFM2B.create_user_table_config", "type": "function", "doc": "<p>Create the user table configuration.</p>\n\n<p>Returns:\n    the configuration of the user table.</p>\n", "signature": "(self) -> src.fairreckitlib.data.set.dataset_config.DatasetTableConfig", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b.DatasetProcessorLFM2B.get_matrix_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b", "qualname": "DatasetProcessorLFM2B.get_matrix_configs", "type": "function", "doc": "<p>Get matrix configuration processors.</p>\n\n<p>Returns:\n    a list containing the user-artist-count and user-track-count matrix processors.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b.DatasetProcessorLFM2B.get_table_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b", "qualname": "DatasetProcessorLFM2B.get_table_configs", "type": "function", "doc": "<p>Get table configuration processors.</p>\n\n<p>Returns:\n    a list containing the album, artist, spotify, track and user table processors.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b.DatasetProcessorLFM2B.process_album_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b", "qualname": "DatasetProcessorLFM2B.process_album_table", "type": "function", "doc": "<p>Process the album table.</p>\n\n<p>The original file does not load correctly with pandas when splitting on\nnewlines \\n and \\t tabs.</p>\n\n<p>Returns:\n    the album table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b.DatasetProcessorLFM2B.process_artist_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b", "qualname": "DatasetProcessorLFM2B.process_artist_table", "type": "function", "doc": "<p>Process the artist table.</p>\n\n<p>Returns:\n    the artist table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b.DatasetProcessorLFM2B.process_corrupt_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b", "qualname": "DatasetProcessorLFM2B.process_corrupt_table", "type": "function", "doc": "<p>Process a corrupt table that does not load correctly with pandas.</p>\n\n<p>Loading with the 'python-fwf' engine does not have issues, however the\nrow values need to be manually split.</p>\n", "signature": "(self, table_name: str) -> Tuple[str, int]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b.DatasetProcessorLFM2B.process_spotify_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b", "qualname": "DatasetProcessorLFM2B.process_spotify_table", "type": "function", "doc": "<p>Process the spotify table.</p>\n\n<p>Returns:\n    the spotify table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b.DatasetProcessorLFM2B.process_track_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b", "qualname": "DatasetProcessorLFM2B.process_track_table", "type": "function", "doc": "<p>Process the track table.</p>\n\n<p>The original file does not load correctly with pandas when splitting on\nnewlines \\n and \\t tabs.</p>\n\n<p>Returns:\n    the track table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b.DatasetProcessorLFM2B.process_user_artist_matrix", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b", "qualname": "DatasetProcessorLFM2B.process_user_artist_matrix", "type": "function", "doc": "<p>Process the user-artist-count matrix.</p>\n\n<p>Returns:\n    the matrix configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b.DatasetProcessorLFM2B.process_user_track_matrix", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm2b", "qualname": "DatasetProcessorLFM2B.process_user_track_matrix", "type": "function", "doc": "<p>Process the user-track-count matrix.</p>\n\n<p>Returns:\n    the matrix configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k", "type": "module", "doc": "<p>This modules contains the class to process the LastFM-360K dataset.</p>\n\n<p>Classes:</p>\n\n<pre><code>DatasetProcessorLFM360K: data processor implementation for the LFM-360K dataset.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k.DatasetProcessorLFM360K", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k", "qualname": "DatasetProcessorLFM360K", "type": "class", "doc": "<p>DatasetProcessor for the LastFM-360K dataset.</p>\n\n<p>The dataset can be downloaded from the website below.\nhttps://www.upf.edu/web/mtg/lastfm360k</p>\n\n<p>The enriched artist gender information can be retrieved from:\nhttps://zenodo.org/record/3748787#.YowEBqhByUk</p>\n\n<p>The processor handles the following files:</p>\n\n<p>usersha1-artmbid-artname-plays.tsv (required)\nusersha1-profile.tsv (optional)\nlfm-360-gender.json (optional)</p>\n", "bases": "src.fairreckitlib.data.set.processor.dataset_processor_lfm.DatasetProcessorLFM"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k.DatasetProcessorLFM360K.__init__", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k", "qualname": "DatasetProcessorLFM360K.__init__", "type": "function", "doc": "<p>Construct the DatasetProcessorLFM360K.</p>\n\n<p>Args:\n    dataset_name: path of the dataset directory.\n    dataset_name: name of the dataset (processor).</p>\n", "signature": "(self, dataset_dir: str, dataset_name: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k.DatasetProcessorLFM360K.create_listening_events_config", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k", "qualname": "DatasetProcessorLFM360K.create_listening_events_config", "type": "function", "doc": "<p>Create the listening event table configuration.</p>\n\n<p>No listening events are available for this dataset.</p>\n\n<p>Returns:\n    None.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k.DatasetProcessorLFM360K.create_user_table_config", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k", "qualname": "DatasetProcessorLFM360K.create_user_table_config", "type": "function", "doc": "<p>Create the user table configuration.</p>\n\n<p>The base user configuration that contains the generated user ids\nand corresponding user sha.</p>\n\n<p>Returns:\n    the configuration of the user table.</p>\n", "signature": "(self) -> src.fairreckitlib.data.set.dataset_config.DatasetTableConfig", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k.DatasetProcessorLFM360K.get_matrix_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k", "qualname": "DatasetProcessorLFM360K.get_matrix_configs", "type": "function", "doc": "<p>Get matrix configuration processors.</p>\n\n<p>Returns:\n    a list containing the user-artist-count matrix processor.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k.DatasetProcessorLFM360K.get_table_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k", "qualname": "DatasetProcessorLFM360K.get_table_configs", "type": "function", "doc": "<p>Get table configuration processors.</p>\n\n<p>Returns:\n    a list containing the artist and user table processors.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k.DatasetProcessorLFM360K.load_artist_gender_json", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k", "qualname": "DatasetProcessorLFM360K.load_artist_gender_json", "type": "function", "doc": "<p>Load the artist gender json file.</p>\n\n<p>Returns:\n    the loaded artist musicbrainzID/gender table or None on failure.</p>\n", "signature": "(self) -> Optional[pandas.core.frame.DataFrame]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k.DatasetProcessorLFM360K.load_user_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k", "qualname": "DatasetProcessorLFM360K.load_user_table", "type": "function", "doc": "<p>Load the original user table.</p>\n\n<p>Changes the contents of the age and gender columns to be more user-friendly,\nand the contents of the country column to ISO 3166 Alpha-2 country codes.</p>\n\n<p>Returns:\n    the loaded user table on None on failure.</p>\n", "signature": "(self) -> Optional[pandas.core.frame.DataFrame]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k.DatasetProcessorLFM360K.process_artist_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k", "qualname": "DatasetProcessorLFM360K.process_artist_table", "type": "function", "doc": "<p>Process the artist table.</p>\n\n<p>Creates the artist table with the musicbrainzID and gender information when available.</p>\n\n<p>Returns:\n    the artist table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k.DatasetProcessorLFM360K.process_user_artist_matrix", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k", "qualname": "DatasetProcessorLFM360K.process_user_artist_matrix", "type": "function", "doc": "<p>Process the user-artist-count matrix.</p>\n\n<p>The user-item matrix is stored in a file that also contains a musicbrainzID.\nThe users are hashes and the items are names, both are converted to integers\nto comply to the CSR compatible format. In addition, any rows that contain\ncorrupt data are removed in the process.</p>\n\n<p>Returns:\n    the matrix configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k.DatasetProcessorLFM360K.process_user_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_lfm360k", "qualname": "DatasetProcessorLFM360K.process_user_table", "type": "function", "doc": "<p>Process the user table.</p>\n\n<p>Extends the original user table with unique user ids.</p>\n\n<p>Returns:\n    the user table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml", "type": "module", "doc": "<p>This module contains the base processor for MovieLens datasets.</p>\n\n<p>Classes:</p>\n\n<pre><code>DatasetProcessorML: the base class for MovieLens dataset processors.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml.DatasetProcessorML", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml", "qualname": "DatasetProcessorML", "type": "class", "doc": "<p>DataProcessor base class for MovieLens datasets.</p>\n\n<p>Provides an abstraction for processing the user-movie-rating matrix.\nMoreover, it is assumed that the datasets do not have any event tables.</p>\n\n<p>Abstract methods:</p>\n\n<p>create_user_movie_matrix_config</p>\n", "bases": "src.fairreckitlib.data.set.processor.dataset_processor_base.DatasetProcessorBase"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml.DatasetProcessorML.create_user_movie_matrix_config", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml", "qualname": "DatasetProcessorML.create_user_movie_matrix_config", "type": "function", "doc": "<p>Create the user-movie matrix configuration.</p>\n\n<p>Returns:\n    the table configuration of the matrix.</p>\n", "signature": "(self) -> src.fairreckitlib.data.set.dataset_config.DatasetTableConfig", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml.DatasetProcessorML.get_event_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml", "qualname": "DatasetProcessorML.get_event_configs", "type": "function", "doc": "<p>Get event table configuration processors.</p>\n\n<p>Returns:\n    an empty list.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml.DatasetProcessorML.get_matrix_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml", "qualname": "DatasetProcessorML.get_matrix_configs", "type": "function", "doc": "<p>Get matrix configuration processors.</p>\n\n<p>Returns:\n    a list with the user-movie-rating matrix processor.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml.DatasetProcessorML.process_user_movie_matrix", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml", "qualname": "DatasetProcessorML.process_user_movie_matrix", "type": "function", "doc": "<p>Process the user-movie-rating matrix.</p>\n\n<p>Returns:\n    the matrix configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetMatrixConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml100k", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml100k", "type": "module", "doc": "<p>This modules contains the class to process the MovieLens-100K dataset.</p>\n\n<p>Classes:</p>\n\n<pre><code>DatasetProcessorML100K: data processor implementation for the ML-100K dataset.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml100k.DatasetProcessorML100K", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml100k", "qualname": "DatasetProcessorML100K", "type": "class", "doc": "<p>DatasetProcessor for the MovieLens-100K dataset.</p>\n\n<p>The dataset can be downloaded from the link below.\nhttps://files.grouplens.org/datasets/movielens/ml-100k.zip</p>\n\n<p>The processor handles the following files:</p>\n\n<p>u.data (required)\nu.user (optional)\nu.item (optional)</p>\n", "bases": "src.fairreckitlib.data.set.processor.dataset_processor_ml.DatasetProcessorML"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml100k.DatasetProcessorML100K.create_user_movie_matrix_config", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml100k", "qualname": "DatasetProcessorML100K.create_user_movie_matrix_config", "type": "function", "doc": "<p>Create the user-movie matrix configuration.</p>\n\n<p>Returns:\n    the table configuration of the ML-100K matrix.</p>\n", "signature": "(self) -> src.fairreckitlib.data.set.dataset_config.DatasetTableConfig", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml100k.DatasetProcessorML100K.get_table_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml100k", "qualname": "DatasetProcessorML100K.get_table_configs", "type": "function", "doc": "<p>Get table configuration processors.</p>\n\n<p>Returns:\n    a list containing the user and movie table processors.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml100k.DatasetProcessorML100K.process_movie_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml100k", "qualname": "DatasetProcessorML100K.process_movie_table", "type": "function", "doc": "<p>Process the movie table.</p>\n\n<p>Removes an empty release date column that is included in the movie title.\nSimplifies the binary genre columns by concatenating the names using pipes.</p>\n\n<p>Returns:\n    the movie table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml100k.DatasetProcessorML100K.process_user_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml100k", "qualname": "DatasetProcessorML100K.process_user_table", "type": "function", "doc": "<p>Process the user table.</p>\n\n<p>Changes the contents of the gender and occupation columns to be more user-friendly.</p>\n\n<p>Returns:\n    the user table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m", "type": "module", "doc": "<p>This modules contains the class to process the MovieLens-25M dataset.</p>\n\n<p>Classes:</p>\n\n<pre><code>DatasetProcessorML25M: data processor implementation for the ML-25M dataset.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m.DatasetProcessorML25M", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m", "qualname": "DatasetProcessorML25M", "type": "class", "doc": "<p>DatasetProcessor for the MovieLens-25M dataset.</p>\n\n<p>The dataset can be downloaded from the link below.\nhttps://files.grouplens.org/datasets/movielens/ml-25m.zip</p>\n\n<p>The processor handles the following files:</p>\n\n<p>genome-scores.csv (optional)\ngenome-tags.csv (optional)\nlinks.csv (optional)\nmovies.csv (optional)\nratings.csv (required)\ntags.csv (optional)</p>\n", "bases": "src.fairreckitlib.data.set.processor.dataset_processor_ml.DatasetProcessorML"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m.DatasetProcessorML25M.create_user_movie_matrix_config", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m", "qualname": "DatasetProcessorML25M.create_user_movie_matrix_config", "type": "function", "doc": "<p>Create the user-movie matrix configuration.</p>\n\n<p>Returns:\n    the table configuration of the ML-25M matrix.</p>\n", "signature": "(self) -> src.fairreckitlib.data.set.dataset_config.DatasetTableConfig", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m.DatasetProcessorML25M.get_table_configs", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m", "qualname": "DatasetProcessorML25M.get_table_configs", "type": "function", "doc": "<p>Get table configuration processors.</p>\n\n<p>Returns:\n    a list containing the genome score, genome tag, movie and tag table processors.</p>\n", "signature": "(\n    self\n) -> List[Tuple[str, Callable[[], Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m.DatasetProcessorML25M.process_genome_score_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m", "qualname": "DatasetProcessorML25M.process_genome_score_table", "type": "function", "doc": "<p>Process the genome score table.</p>\n\n<p>Returns:\n    the genome score table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m.DatasetProcessorML25M.process_genome_tag_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m", "qualname": "DatasetProcessorML25M.process_genome_tag_table", "type": "function", "doc": "<p>Process the genome tag table.</p>\n\n<p>Returns:\n    the genome tag table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m.DatasetProcessorML25M.process_movie_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m", "qualname": "DatasetProcessorML25M.process_movie_table", "type": "function", "doc": "<p>Process the movie table.</p>\n\n<p>The movie and link tables are joined together for simplification.</p>\n\n<p>Returns:\n    the movie table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m.DatasetProcessorML25M.process_tag_table", "modulename": "src.fairreckitlib.data.set.processor.dataset_processor_ml25m", "qualname": "DatasetProcessorML25M.process_tag_table", "type": "function", "doc": "<p>Process the tag table.</p>\n\n<p>Returns:\n    the tag table configuration or None on failure.</p>\n", "signature": "(\n    self\n) -> Optional[src.fairreckitlib.data.set.dataset_config.DatasetTableConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.split", "modulename": "src.fairreckitlib.data.split", "type": "module", "doc": "<p>This package contains functionality for splitting dataframes into a train and test set.</p>\n\n<p>Modules:</p>\n\n<pre><code>base_splitter: base class for data splitters.\nrandom_splitter: class for splitting randomly.\nsplit_config: splitter configuration class.\nsplit_config_parsing: parse splitter configuration.\nsplit_constants: constants to be used in other modules.\nsplit_event: event args and a print function for a splitting event.\nsplit_factory: create splitter factory with available data splitters.\ntemporal_splitter: class for splitting on time.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.split.base_splitter", "modulename": "src.fairreckitlib.data.split.base_splitter", "type": "module", "doc": "<p>This module contains the base class for data splitting.</p>\n\n<p>Classes:</p>\n\n<pre><code>DataSplitter: the base class for data splitting.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.split.base_splitter.DataSplitter", "modulename": "src.fairreckitlib.data.split.base_splitter", "qualname": "DataSplitter", "type": "class", "doc": "<p>Base class for FairRecKit data splitters.</p>\n\n<p>A splitter is used to split a dataframe into a train and test set.</p>\n\n<p>Public methods:</p>\n\n<p>get_test_ratio</p>\n", "bases": "src.fairreckitlib.data.data_modifier.DataModifier"}, {"fullname": "src.fairreckitlib.data.split.base_splitter.DataSplitter.__init__", "modulename": "src.fairreckitlib.data.split.base_splitter", "qualname": "DataSplitter.__init__", "type": "function", "doc": "<p>Construct the base splitter.</p>\n\n<p>Args:\n    name: the name of the splitter.\n    params: a dictionary containing the parameters for the splitter.\n    test_ratio: the fraction of users to use for testing.</p>\n", "signature": "(self, name: str, params: Dict[str, Any], test_ratio: float)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.split.base_splitter.DataSplitter.get_test_ratio", "modulename": "src.fairreckitlib.data.split.base_splitter", "qualname": "DataSplitter.get_test_ratio", "type": "function", "doc": "<p>Get the test ratio used by the splitter when run.</p>\n\n<p>Returns:\n    the test ratio</p>\n", "signature": "(self) -> float", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.split.base_splitter.DataSplitter.run", "modulename": "src.fairreckitlib.data.split.base_splitter", "qualname": "DataSplitter.run", "type": "function", "doc": "<p>Run the splitter on the specified dataframe.</p>\n\n<p>Args:\n    dataframe: with at least the 'user' column.</p>\n\n<p>Returns:\n    the train and test set dataframes of the split.</p>\n", "signature": "(\n    self,\n    dataframe: pandas.core.frame.DataFrame\n) -> Tuple[pandas.core.frame.DataFrame, pandas.core.frame.DataFrame]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.split.random_splitter", "modulename": "src.fairreckitlib.data.split.random_splitter", "type": "module", "doc": "<p>This module contains random splitting functionality.</p>\n\n<p>Classes:</p>\n\n<pre><code>RandomSplitter: can split randomly.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_random_splitter: create an instance of the class (factory creation compatible).\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.split.random_splitter.RandomSplitter", "modulename": "src.fairreckitlib.data.split.random_splitter", "qualname": "RandomSplitter", "type": "class", "doc": "<p>Random Splitter.</p>\n\n<p>Splits the dataframe into a train and test set randomly user-by-user.</p>\n", "bases": "src.fairreckitlib.data.split.base_splitter.DataSplitter"}, {"fullname": "src.fairreckitlib.data.split.random_splitter.RandomSplitter.run", "modulename": "src.fairreckitlib.data.split.random_splitter", "qualname": "RandomSplitter.run", "type": "function", "doc": "<p>Split the dataframe into a train and test set.</p>\n\n<p>Args:\n    dataframe: with at least the 'user' column.</p>\n\n<p>Returns:\n    the train and test set dataframes of the split.</p>\n", "signature": "(\n    self,\n    dataframe: pandas.core.frame.DataFrame\n) -> Tuple[pandas.core.frame.DataFrame, pandas.core.frame.DataFrame]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.split.random_splitter.create_random_splitter", "modulename": "src.fairreckitlib.data.split.random_splitter", "qualname": "create_random_splitter", "type": "function", "doc": "<p>Create the Random Splitter.</p>\n\n<p>Returns:\n    the random data splitter.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.data.split.random_splitter.RandomSplitter", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.split.split_config", "modulename": "src.fairreckitlib.data.split.split_config", "type": "module", "doc": "<p>This module contains the split configuration.</p>\n\n<p>Classes:</p>\n\n<pre><code>SplitConfig: split configuration.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.split.split_config.SplitConfig", "modulename": "src.fairreckitlib.data.split.split_config", "qualname": "SplitConfig", "type": "class", "doc": "<p>Dataset Splitting Configuration.</p>\n\n<p>name: the name of the splitter.\nparams: the parameters of the splitter.\ntest_ratio: the test ratio used by the splitter.</p>\n", "bases": "src.fairreckitlib.core.config.config_object.ObjectConfig"}, {"fullname": "src.fairreckitlib.data.split.split_config.SplitConfig.__init__", "modulename": "src.fairreckitlib.data.split.split_config", "qualname": "SplitConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, name: str, params: Dict[str, Any], test_ratio: float)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.split.split_config.SplitConfig.get_split_ratio_string", "modulename": "src.fairreckitlib.data.split.split_config", "qualname": "SplitConfig.get_split_ratio_string", "type": "function", "doc": "<p>Get the split ratio percentages formatted as a string.</p>\n\n<p>Returns:\n    a string containing the split ratio in percentages.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.split.split_config.SplitConfig.to_yml_format", "modulename": "src.fairreckitlib.data.split.split_config", "qualname": "SplitConfig.to_yml_format", "type": "function", "doc": "<p>Format splitting configuration to a yml compatible dictionary.</p>\n\n<p>Returns:\n    a dictionary containing the splitting configuration.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.split.split_config_parsing", "modulename": "src.fairreckitlib.data.split.split_config_parsing", "type": "module", "doc": "<p>This module contains a parser for the dataset splitting configuration.</p>\n\n<p>Functions:</p>\n\n<pre><code>parse_data_split_config: parse split configuration.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.split.split_config_parsing.parse_data_split_config", "modulename": "src.fairreckitlib.data.split.split_config_parsing", "qualname": "parse_data_split_config", "type": "function", "doc": "<p>Parse a dataset splitting configuration.</p>\n\n<p>Args:\n    dataset_config: the dataset's total configuration.\n    dataset: the dataset related to the splitting configuration.\n    split_factory: the split factory containing available splitters.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    the parsed configuration or None on failure.</p>\n", "signature": "(\n    dataset_config: Dict[str, Any],\n    dataset: src.fairreckitlib.data.set.dataset.Dataset,\n    split_factory: src.fairreckitlib.core.config.config_factories.Factory,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> src.fairreckitlib.data.split.split_config.SplitConfig", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.split.split_constants", "modulename": "src.fairreckitlib.data.split.split_constants", "type": "module", "doc": "<p>This module contains splitting constants that are used in other modules.</p>\n\n<p>Constants:</p>\n\n<pre><code>KEY_SPLITTING: key that is used to identify splitters.\nKEY_SPLIT_TEST_RATIO: key that is used to identify the splitter test ratio.\nSPLIT_RANDOM: name of the random splitter.\nSPLIT_TEMPORAL: name of the temporal splitter.\nDEFAULT_SPLIT_NAME: the name of the default splitter.\nDEFAULT_SPLIT_TEST_RATIO: the default split test ratio.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.split.split_event", "modulename": "src.fairreckitlib.data.split.split_event", "type": "module", "doc": "<p>This module contains event args and a print function for a rating conversion event.</p>\n\n<p>Classes:</p>\n\n<pre><code>SplitDataframeEventArgs: event args related to splitting dataframes.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>print_split_event_args: print dataframe split event arguments.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.split.split_event.SplitDataframeEventArgs", "modulename": "src.fairreckitlib.data.split.split_event", "qualname": "SplitDataframeEventArgs", "type": "class", "doc": "<p>Split dataframe Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the splitting event.\nsplit_config: the splitting configuration that is used.</p>\n", "bases": "src.fairreckitlib.core.events.event_args.EventArgs"}, {"fullname": "src.fairreckitlib.data.split.split_event.SplitDataframeEventArgs.__init__", "modulename": "src.fairreckitlib.data.split.split_event", "qualname": "SplitDataframeEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    event_id: str,\n    split_config: src.fairreckitlib.data.split.split_config.SplitConfig\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.split.split_event.print_split_event_args", "modulename": "src.fairreckitlib.data.split.split_event", "qualname": "print_split_event_args", "type": "function", "doc": "<p>Print split dataframe event arguments.</p>\n\n<p>It is assumed that the event started when elapsed_time is None and is finished otherwise.</p>\n\n<p>Args:\n    event_args: the arguments to print.\n    elapsed_time: the time that has passed since the splitting started, expressed in seconds.</p>\n", "signature": "(\n    event_args: src.fairreckitlib.data.split.split_event.SplitDataframeEventArgs,\n    elapsed_time: float = None\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.split.split_factory", "modulename": "src.fairreckitlib.data.split.split_factory", "type": "module", "doc": "<p>This module contains functionality to create a splitters factory.</p>\n\n<p>Functions:</p>\n\n<pre><code>create_split_factory: create a factory with data splitters.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.split.split_factory.create_split_factory", "modulename": "src.fairreckitlib.data.split.split_factory", "qualname": "create_split_factory", "type": "function", "doc": "<p>Create a Factory with all data splitters.</p>\n\n<p>Returns:\n    the factory with all available splitters.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_factories.Factory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.split.temporal_splitter", "modulename": "src.fairreckitlib.data.split.temporal_splitter", "type": "module", "doc": "<p>This module contains time splitting functionality.</p>\n\n<p>Classes:</p>\n\n<pre><code>TemporalSplitter: can split on timestamp.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_temporal_splitter: create an instance of the class (factory creation compatible).\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.data.split.temporal_splitter.TemporalSplitter", "modulename": "src.fairreckitlib.data.split.temporal_splitter", "qualname": "TemporalSplitter", "type": "class", "doc": "<p>Temporal Splitter.</p>\n\n<p>Splits the dataframe into a train and test set based on time user-by-user.</p>\n", "bases": "src.fairreckitlib.data.split.base_splitter.DataSplitter"}, {"fullname": "src.fairreckitlib.data.split.temporal_splitter.TemporalSplitter.run", "modulename": "src.fairreckitlib.data.split.temporal_splitter", "qualname": "TemporalSplitter.run", "type": "function", "doc": "<p>Split the dataframe into a train and test set.</p>\n\n<p>For this function to work, it needs a 'user' and 'timestamp' column.</p>\n\n<p>Args:\n    dataframe: with at least the 'user' column.</p>\n\n<p>Returns:\n    the train and test set dataframes of the split.</p>\n", "signature": "(\n    self,\n    dataframe: pandas.core.frame.DataFrame\n) -> Tuple[pandas.core.frame.DataFrame, pandas.core.frame.DataFrame]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.data.split.temporal_splitter.create_temporal_splitter", "modulename": "src.fairreckitlib.data.split.temporal_splitter", "qualname": "create_temporal_splitter", "type": "function", "doc": "<p>Create the Temporal Splitter.</p>\n\n<p>Returns:\n    the temporal data splitter.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.data.split.temporal_splitter.TemporalSplitter", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation", "modulename": "src.fairreckitlib.evaluation", "type": "module", "doc": "<p>This package contains functionality for evaluation/metric computations.</p>\n\n<p>Modules:</p>\n\n<pre><code>evaluation_factory: create evaluation factory with available predictor/recommender factories.\n</code></pre>\n\n<p>Packages:</p>\n\n<pre><code>metrics: prediction/recommender metrics.\npipeline: run various metric computations with batching.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.evaluation_factory", "modulename": "src.fairreckitlib.evaluation.evaluation_factory", "type": "module", "doc": "<p>This module contains functionality to create an evaluation factory.</p>\n\n<p>Constants:</p>\n\n<pre><code>KEY_EVALUATION: key that is used to identify evaluation.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_metric_pipeline_factory: wrap metric factory with pipeline creation.\ncreate_evaluation_factory: create factory with prediction/recommendation factories.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.evaluation_factory.create_metric_pipeline_factory", "modulename": "src.fairreckitlib.evaluation.evaluation_factory", "qualname": "create_metric_pipeline_factory", "type": "function", "doc": "<p>Create a metric pipeline factory.</p>\n\n<p>Args:\n    metric_factory: the factory with available metrics.\n    create_pipeline: the pipeline creation function associated with the factory.</p>\n\n<p>Returns\n    the metric pipeline factory.</p>\n", "signature": "(\n    metric_factory: src.fairreckitlib.core.config.config_factories.Factory,\n    create_pipeline: Callable[[src.fairreckitlib.core.config.config_factories.Factory, src.fairreckitlib.core.events.event_dispatcher.EventDispatcher], src.fairreckitlib.evaluation.pipeline.evaluation_pipeline.EvaluationPipeline]\n) -> src.fairreckitlib.core.config.config_factories.Factory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.evaluation_factory.create_evaluation_factory", "modulename": "src.fairreckitlib.evaluation.evaluation_factory", "qualname": "create_evaluation_factory", "type": "function", "doc": "<p>Create a factory with all predictor and recommender metric category factories.</p>\n\n<p>Returns:\n    the group factory with available predictor and recommender factories.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_factories.GroupFactory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics", "modulename": "src.fairreckitlib.evaluation.metrics", "type": "module", "doc": "<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.metrics.common", "modulename": "src.fairreckitlib.evaluation.metrics.common", "type": "module", "doc": "<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.metrics.common.RecType", "modulename": "src.fairreckitlib.evaluation.metrics.common", "qualname": "RecType", "type": "class", "doc": "<p>Type of recommendation</p>\n", "bases": "enum.Enum"}, {"fullname": "src.fairreckitlib.evaluation.metrics.common.RecType.PREDICTION", "modulename": "src.fairreckitlib.evaluation.metrics.common", "qualname": "RecType.PREDICTION", "type": "variable", "doc": "<p></p>\n", "default_value": " = <RecType.PREDICTION: 'prediction'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.common.RecType.RECOMMENDATION", "modulename": "src.fairreckitlib.evaluation.metrics.common", "qualname": "RecType.RECOMMENDATION", "type": "variable", "doc": "<p></p>\n", "default_value": " = <RecType.RECOMMENDATION: 'recommendation'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.common.MetricCategory", "modulename": "src.fairreckitlib.evaluation.metrics.common", "qualname": "MetricCategory", "type": "class", "doc": "<p>Metric category of evaluation</p>\n", "bases": "enum.Enum"}, {"fullname": "src.fairreckitlib.evaluation.metrics.common.MetricCategory.ACCURACY", "modulename": "src.fairreckitlib.evaluation.metrics.common", "qualname": "MetricCategory.ACCURACY", "type": "variable", "doc": "<p></p>\n", "default_value": " = <MetricCategory.ACCURACY: 'Accuracy'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.common.MetricCategory.RATING", "modulename": "src.fairreckitlib.evaluation.metrics.common", "qualname": "MetricCategory.RATING", "type": "variable", "doc": "<p></p>\n", "default_value": " = <MetricCategory.RATING: 'Rating'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.common.MetricCategory.COVERAGE", "modulename": "src.fairreckitlib.evaluation.metrics.common", "qualname": "MetricCategory.COVERAGE", "type": "variable", "doc": "<p></p>\n", "default_value": " = <MetricCategory.COVERAGE: 'Coverage'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.common.MetricCategory.DIVERSITY", "modulename": "src.fairreckitlib.evaluation.metrics.common", "qualname": "MetricCategory.DIVERSITY", "type": "variable", "doc": "<p></p>\n", "default_value": " = <MetricCategory.DIVERSITY: 'Diversity'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.common.MetricCategory.NOVELTY", "modulename": "src.fairreckitlib.evaluation.metrics.common", "qualname": "MetricCategory.NOVELTY", "type": "variable", "doc": "<p></p>\n", "default_value": " = <MetricCategory.NOVELTY: 'Novelty'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.common.Metric", "modulename": "src.fairreckitlib.evaluation.metrics.common", "qualname": "Metric", "type": "class", "doc": "<p>Known metrics (names)</p>\n", "bases": "enum.Enum"}, {"fullname": "src.fairreckitlib.evaluation.metrics.common.Metric.NDCG", "modulename": "src.fairreckitlib.evaluation.metrics.common", "qualname": "Metric.NDCG", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.NDCG: 'NDCG@K'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.common.Metric.PRECISION", "modulename": "src.fairreckitlib.evaluation.metrics.common", "qualname": "Metric.PRECISION", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.PRECISION: 'P@K'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.common.Metric.RECALL", "modulename": "src.fairreckitlib.evaluation.metrics.common", "qualname": "Metric.RECALL", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.RECALL: 'R@K'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.common.Metric.MRR", "modulename": "src.fairreckitlib.evaluation.metrics.common", "qualname": "Metric.MRR", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.MRR: 'MRR'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.common.Metric.RMSE", "modulename": "src.fairreckitlib.evaluation.metrics.common", "qualname": "Metric.RMSE", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.RMSE: 'RMSE'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.common.Metric.MAE", "modulename": "src.fairreckitlib.evaluation.metrics.common", "qualname": "Metric.MAE", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.MAE: 'MAE'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.common.Metric.ITEM_COVERAGE", "modulename": "src.fairreckitlib.evaluation.metrics.common", "qualname": "Metric.ITEM_COVERAGE", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.ITEM_COVERAGE: 'Item Coverage'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.common.Metric.USER_COVERAGE", "modulename": "src.fairreckitlib.evaluation.metrics.common", "qualname": "Metric.USER_COVERAGE", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.USER_COVERAGE: 'User Coverage'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.common.Metric.GINI", "modulename": "src.fairreckitlib.evaluation.metrics.common", "qualname": "Metric.GINI", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.GINI: 'Gini Index'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.common.Metric.INTRA_LIST_SIMILARITY", "modulename": "src.fairreckitlib.evaluation.metrics.common", "qualname": "Metric.INTRA_LIST_SIMILARITY", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.INTRA_LIST_SIMILARITY: 'Intra-List Similarity'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.common.Metric.SIMILARITY_COS", "modulename": "src.fairreckitlib.evaluation.metrics.common", "qualname": "Metric.SIMILARITY_COS", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.SIMILARITY_COS: 'Similarity Cosine'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.common.Metric.SIMILARITY_EUCLID", "modulename": "src.fairreckitlib.evaluation.metrics.common", "qualname": "Metric.SIMILARITY_EUCLID", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.SIMILARITY_EUCLID: 'Similarity Euclidean'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.common.Metric.NOVELTY", "modulename": "src.fairreckitlib.evaluation.metrics.common", "qualname": "Metric.NOVELTY", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.NOVELTY: 'Novelty'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.common.Metric.DIR", "modulename": "src.fairreckitlib.evaluation.metrics.common", "qualname": "Metric.DIR", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.DIR: 'DIR'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.common.Metric.PAIRWISE_FAIRNESS", "modulename": "src.fairreckitlib.evaluation.metrics.common", "qualname": "Metric.PAIRWISE_FAIRNESS", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Metric.PAIRWISE_FAIRNESS: 'Pairwise Fairness'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.common.metric_matches_type", "modulename": "src.fairreckitlib.evaluation.metrics.common", "qualname": "metric_matches_type", "type": "function", "doc": "<p>Check whether the metric can be used on the recommendation result type</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>metric</strong>:  the metric to use for analysis</li>\n<li><strong>rec_type</strong>:  the type of the recommenaation result</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a Boolean which specifies whether the metric can be used for the result</p>\n</blockquote>\n", "signature": "(metric, rec_type)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.evaluator", "modulename": "src.fairreckitlib.evaluation.metrics.evaluator", "type": "module", "doc": "<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.metrics.evaluator.Evaluator", "modulename": "src.fairreckitlib.evaluation.metrics.evaluator", "qualname": "Evaluator", "type": "class", "doc": "<p>Evaluates results from model algorithm</p>\n", "bases": "abc.ABC"}, {"fullname": "src.fairreckitlib.evaluation.metrics.evaluator.Evaluator.evaluate", "modulename": "src.fairreckitlib.evaluation.metrics.evaluator", "qualname": "Evaluator.evaluate", "type": "function", "doc": "<p>Run analysis based on metric</p>\n", "signature": "(self, train_set, test_set, recs)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.evaluator.Evaluator.get_api_name", "modulename": "src.fairreckitlib.evaluation.metrics.evaluator", "qualname": "Evaluator.get_api_name", "type": "function", "doc": "<p>Return the evaluator API name</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.filter", "modulename": "src.fairreckitlib.evaluation.metrics.filter", "type": "module", "doc": "<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.metrics.filter.Filter", "modulename": "src.fairreckitlib.evaluation.metrics.filter", "qualname": "Filter", "type": "class", "doc": "<p>Data filter/selection</p>\n", "bases": "enum.Enum"}, {"fullname": "src.fairreckitlib.evaluation.metrics.filter.Filter.EQUALS", "modulename": "src.fairreckitlib.evaluation.metrics.filter", "qualname": "Filter.EQUALS", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Filter.EQUALS: 'equals'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.filter.Filter.CLAMP", "modulename": "src.fairreckitlib.evaluation.metrics.filter", "qualname": "Filter.CLAMP", "type": "variable", "doc": "<p></p>\n", "default_value": " = <Filter.CLAMP: 'clamp'>"}, {"fullname": "src.fairreckitlib.evaluation.metrics.filter.filter_data", "modulename": "src.fairreckitlib.evaluation.metrics.filter", "qualname": "filter_data", "type": "function", "doc": "<p>Filter a dataset using the specified list of filter passes</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dataframe</strong>:  The dataset (Pandas dataframe) to be filtered</li>\n<li><strong>filters</strong>:  The filters used</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The filtered dataframe</p>\n</blockquote>\n", "signature": "(dataframe, filters)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.lenskit", "modulename": "src.fairreckitlib.evaluation.metrics.lenskit", "type": "module", "doc": "<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_prediction_evaluator", "modulename": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_prediction_evaluator", "type": "module", "doc": "<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_prediction_evaluator.LensKitPredictionEvaluator", "modulename": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_prediction_evaluator", "qualname": "LensKitPredictionEvaluator", "type": "class", "doc": "<p>Predictor implementation for the LensKit framework.</p>\n", "bases": "src.fairreckitlib.evaluation.metrics.evaluator.Evaluator"}, {"fullname": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_prediction_evaluator.LensKitPredictionEvaluator.__init__", "modulename": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_prediction_evaluator", "qualname": "LensKitPredictionEvaluator.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, eval_func: Any, params: Dict[str, Any], **kwargs)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_prediction_evaluator.LensKitPredictionEvaluator.evaluate", "modulename": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_prediction_evaluator", "qualname": "LensKitPredictionEvaluator.evaluate", "type": "function", "doc": "<p>Run analysis based on metric</p>\n", "signature": "(self, train_set, test_set, recs)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_prediction_evaluator.LensKitPredictionEvaluator.get_api_name", "modulename": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_prediction_evaluator", "qualname": "LensKitPredictionEvaluator.get_api_name", "type": "function", "doc": "<p>Return the evaluator API name</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_recommendation_evaluator", "modulename": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_recommendation_evaluator", "type": "module", "doc": "<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_recommendation_evaluator.LensKitRecommendationEvaluator", "modulename": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_recommendation_evaluator", "qualname": "LensKitRecommendationEvaluator", "type": "class", "doc": "<p>Predictor implementation for the LensKit framework.</p>\n", "bases": "src.fairreckitlib.evaluation.metrics.evaluator.Evaluator"}, {"fullname": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_recommendation_evaluator.LensKitRecommendationEvaluator.__init__", "modulename": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_recommendation_evaluator", "qualname": "LensKitRecommendationEvaluator.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, eval_func: Any, params: Dict[str, Any], **kwargs)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_recommendation_evaluator.LensKitRecommendationEvaluator.evaluate", "modulename": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_recommendation_evaluator", "qualname": "LensKitRecommendationEvaluator.evaluate", "type": "function", "doc": "<p>Run analysis based on metric</p>\n", "signature": "(self, train_set, test_set, recs)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_recommendation_evaluator.LensKitRecommendationEvaluator.get_api_name", "modulename": "src.fairreckitlib.evaluation.metrics.lenskit.lenskit_recommendation_evaluator", "qualname": "LensKitRecommendationEvaluator.get_api_name", "type": "function", "doc": "<p>Return the evaluator API name</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_factory", "modulename": "src.fairreckitlib.evaluation.metrics.metric_factory", "type": "module", "doc": "<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_factory.create_accuracy_metric_factory", "modulename": "src.fairreckitlib.evaluation.metrics.metric_factory", "qualname": "create_accuracy_metric_factory", "type": "function", "doc": "<p>Create the factory with Accuracy metrics.</p>\n\n<p>Returns:\n    the factory with all available metrics.</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_factory.create_coverage_metric_factory", "modulename": "src.fairreckitlib.evaluation.metrics.metric_factory", "qualname": "create_coverage_metric_factory", "type": "function", "doc": "<p>Create the factory with Coverage metrics.</p>\n\n<p>Returns:\n    the factory with all available metrics.</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_factory.prepare_for_coverage", "modulename": "src.fairreckitlib.evaluation.metrics.metric_factory", "qualname": "prepare_for_coverage", "type": "function", "doc": "<p>Uses the train set and recommendations set to\ncreate a tuple that describes the possible user-item pairs in the train set\nand the user-item pairs in the result</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a tuple containing (A,B) where\n      a is a tuple (List,List) of possible users and items in the train set and\n      b is a list of user-item tuples in the recommendations</p>\n</blockquote>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_factory.create_diversity_metric_factory", "modulename": "src.fairreckitlib.evaluation.metrics.metric_factory", "qualname": "create_diversity_metric_factory", "type": "function", "doc": "<p>Create the factory with Diversity metrics.</p>\n\n<p>Returns:\n    the factory with all available metrics.</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_factory.create_novelty_metric_factory", "modulename": "src.fairreckitlib.evaluation.metrics.metric_factory", "qualname": "create_novelty_metric_factory", "type": "function", "doc": "<p>Create the factory with Novelty metrics.</p>\n\n<p>Returns:\n    the factory with all available metrics.</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_factory.create_rating_metric_factory", "modulename": "src.fairreckitlib.evaluation.metrics.metric_factory", "qualname": "create_rating_metric_factory", "type": "function", "doc": "<p>Create the factory with Rating metrics.</p>\n\n<p>Returns:\n    the factory with all available metrics.</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_factory.create_metric_params_k", "modulename": "src.fairreckitlib.evaluation.metrics.metric_factory", "qualname": "create_metric_params_k", "type": "function", "doc": "<p>Create the K param for K metrics</p>\n\n<p>Returns:\n    the configuration parameters of the metric.</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_factory.create_metric", "modulename": "src.fairreckitlib.evaluation.metrics.metric_factory", "qualname": "create_metric", "type": "function", "doc": "<p>Create a metric.</p>\n\n<p>Args:\n    name: the name of the metric.\n    params: parameters for the metric\nReturns:\n    an Evaluator that uses the metric function corresponding to the name.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.evaluation.metrics.evaluator.Evaluator", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.metric_factory.resolve_metric_factory", "modulename": "src.fairreckitlib.evaluation.metrics.metric_factory", "qualname": "resolve_metric_factory", "type": "function", "doc": "<p>Get metric factory from name and category factory.</p>\n\n<p>Args:\n    metric_name: name of the metric\n    metric_category_factory: factory of the metric category</p>\n\n<p>Returns:\n    the metric factory.</p>\n", "signature": "(metric_name, metric_category_factory)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.rexmex", "modulename": "src.fairreckitlib.evaluation.metrics.rexmex", "type": "module", "doc": "<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_evaluator", "modulename": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_evaluator", "type": "module", "doc": "<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_evaluator.RexmexEvaluator", "modulename": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_evaluator", "qualname": "RexmexEvaluator", "type": "class", "doc": "<p>Predictor implementation for the LensKit framework.</p>\n", "bases": "src.fairreckitlib.evaluation.metrics.evaluator.Evaluator"}, {"fullname": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_evaluator.RexmexEvaluator.__init__", "modulename": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_evaluator", "qualname": "RexmexEvaluator.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, eval_func: Any, params: Dict[str, Any], **kwargs)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_evaluator.RexmexEvaluator.evaluate", "modulename": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_evaluator", "qualname": "RexmexEvaluator.evaluate", "type": "function", "doc": "<p>Run analysis based on metric</p>\n", "signature": "(self, train_set, test_set, recs)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_evaluator.RexmexEvaluator.get_api_name", "modulename": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_evaluator", "qualname": "RexmexEvaluator.get_api_name", "type": "function", "doc": "<p>Return the evaluator API name</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_evaluator.prepare_for_coverage", "modulename": "src.fairreckitlib.evaluation.metrics.rexmex.rexmex_evaluator", "qualname": "prepare_for_coverage", "type": "function", "doc": "<p>Uses the train set and recommendations set to\ncreate a tuple that describes the possible user-item pairs in the train set\nand the user-item pairs in the result</p>\n\n<p>Returns: a tuple containing (A,B) where\n    a is a tuple (List,List) of possible users and items in the train set and\n    b is a list of user-item tuples in the recommendations</p>\n", "signature": "(train_set, recs)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline", "modulename": "src.fairreckitlib.evaluation.pipeline", "type": "module", "doc": "<p>This package contains functionality for running the evaluation pipeline.</p>\n\n<p>Modules:</p>\n\n<pre><code>evaluation_config: evaluation configuration class.\nevaluation_config_parsing: parse metric configuration(s).\nevaluation_event: event ids, event args and a print switch for the evaluation pipeline.\nevaluation_pipeline: the evaluation pipeline class.\nevaluation_run: run (multiple) model pipelines.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_config", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_config", "type": "module", "doc": "<p>This module contains the metric configuration.</p>\n\n<p>Classes:</p>\n\n<pre><code>MetricConfig: metric configuration.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_config.MetricConfig", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_config", "qualname": "MetricConfig", "type": "class", "doc": "<p>Metric Configuration.</p>\n\n<p>name: the name of the metric.\nparams: the parameters of the metric.\nprefilters: the prefilters of the metric.</p>\n", "bases": "src.fairreckitlib.core.config.config_object.ObjectConfig"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_config.MetricConfig.__init__", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_config", "qualname": "MetricConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, name: str, params: Dict[str, Any], prefilters: List[Any])", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_config.MetricConfig.to_yml_format", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_config", "qualname": "MetricConfig.to_yml_format", "type": "function", "doc": "<p>Format metric configuration to a yml compatible dictionary.</p>\n\n<p>Returns:\n    a dictionary containing the metric configuration.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_config_parsing", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_config_parsing", "type": "module", "doc": "<p>This module contains a parser for the evaluation and metric configuration(s).</p>\n\n<p>Functions:</p>\n\n<pre><code>parse_evaluation_config: parse all metric configurations.\nparse_metric_config: parse metric configuration.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_config_parsing.parse_evaluation_config", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_config_parsing", "qualname": "parse_evaluation_config", "type": "function", "doc": "<p>Parse all metric configurations.</p>\n\n<p>Args:\n    experiment_config: the experiment's total configuration.\n    metric_category_factory: the metric factory containing grouped available metrics.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    a list of parsed MetricConfig's which is possibly empty.</p>\n", "signature": "(\n    experiment_config: Dict[str, Any],\n    metric_category_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> List[src.fairreckitlib.evaluation.pipeline.evaluation_config.MetricConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_config_parsing.parse_metric_config", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_config_parsing", "qualname": "parse_metric_config", "type": "function", "doc": "<p>Parse a metric configuration.</p>\n\n<p>Args:\n    metric_config: the metrics configuration.\n    metric_category_factory: the metric factory containing grouped available metrics.\n    top_k: the top_K value for recommendation and None for prediction.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    the parsed configuration and the metric name or None on failure.</p>\n", "signature": "(\n    metric_config: Dict[str, Any],\n    metric_category_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    top_k: int,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> Tuple[Optional[src.fairreckitlib.evaluation.pipeline.evaluation_config.MetricConfig], Optional[str]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_event", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_event", "type": "module", "doc": "<p>This module contains all event ids, event args and a print switch for the evaluation pipeline.</p>\n\n<p>Constants:</p>\n\n<pre><code>ON_BEGIN_EVAL_PIPELINE: id of the event that is used when the evaluation pipeline starts.\nON_BEGIN_FILTER_RECS: id of the event that is used when recs filtering starts.\nON_BEGIN_LOAD_RECS_SET: id of the event that is used when a recs set is being loaded.\nON_BEGIN_LOAD_TEST_SET: id of the event that is used when a test set is being loaded.\nON_BEGIN_LOAD_TRAIN_SET: id of the event that is used when a train set is being loaded.\nON_BEGIN_METRIC: id of the event that is used when a metric computation started.\nON_END_EVAL_PIPELINE: id of the event that is used when the evaluation pipeline ends.\nON_END_FILTER_RECS: id of the event that is used when recs filtering finishes.\nON_END_LOAD_RECS_SET: id of the event that is used when a recs set has been loaded.\nON_END_LOAD_TEST_SET: id of the event that is used when a test set has been loaded.\nON_END_LOAD_TRAIN_SET: id of the event that is used when a train set has been loaded.\nON_END_METRIC: id of the event that is used when a metric computation finishes.\n</code></pre>\n\n<p>Classes:</p>\n\n<pre><code>EvaluationPipelineEventArgs: event args related to the evaluation pipeline.\nMetricEventArgs: event args related to a metric.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>get_eval_events: list of evaluation pipeline event IDs.\nget_eval_event_print_switch: switch to print evaluation pipeline event arguments by ID.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_event.EvaluationPipelineEventArgs", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_event", "qualname": "EvaluationPipelineEventArgs", "type": "class", "doc": "<p>Evaluation Pipeline Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the evaluation pipeline event.\nmetrics_config: list of metric configurations that is used in the evaluation pipeline.</p>\n", "bases": "src.fairreckitlib.core.events.event_args.EventArgs"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_event.EvaluationPipelineEventArgs.__init__", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_event", "qualname": "EvaluationPipelineEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    event_id: str,\n    metrics_config: List[src.fairreckitlib.evaluation.pipeline.evaluation_config.MetricConfig]\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_event.MetricEventArgs", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_event", "qualname": "MetricEventArgs", "type": "class", "doc": "<p>Evaluation Pipeline Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the metric event.\nmetric_config: the metric configuration that is used.</p>\n", "bases": "src.fairreckitlib.core.events.event_args.EventArgs"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_event.MetricEventArgs.__init__", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_event", "qualname": "MetricEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    event_id: str,\n    metric_config: src.fairreckitlib.evaluation.pipeline.evaluation_config.MetricConfig\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_event.get_eval_events", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_event", "qualname": "get_eval_events", "type": "function", "doc": "<p>Get a list of evaluation pipeline event IDs.</p>\n\n<p>Returns:\n    a list of unique evaluation pipeline event IDs.</p>\n", "signature": "() -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_event.get_eval_event_print_switch", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_event", "qualname": "get_eval_event_print_switch", "type": "function", "doc": "<p>Get a switch that prints evaluation pipeline event IDs.</p>\n\n<p>Returns:\n    the print evaluation pipeline event switch.</p>\n", "signature": "(\n    elapsed_time: float = None\n) -> Dict[str, Callable[[src.fairreckitlib.core.events.event_args.EventArgs], NoneType]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline", "type": "module", "doc": "<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline.EvaluationPipeline", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline", "qualname": "EvaluationPipeline", "type": "class", "doc": "<p>Evaluation Pipeline to run evaluations from a specific metric category.</p>\n", "bases": "src.fairreckitlib.core.pipeline.core_pipeline.CorePipeline"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline.EvaluationPipeline.__init__", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline", "qualname": "EvaluationPipeline.__init__", "type": "function", "doc": "<p>Construct the CorePipeline.</p>\n\n<p>Args:\n    event_dispatcher: used to dispatch events when running the core pipeline.</p>\n", "signature": "(\n    self,\n    metric_factory: src.fairreckitlib.core.config.config_factories.Factory,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline.EvaluationPipeline.run", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline", "qualname": "EvaluationPipeline.run", "type": "function", "doc": "<p>Args:\n    out_path:\n    recs_path:\n    data_transition:\n    metrics:\n    kwargs:</p>\n", "signature": "(\n    self,\n    out_path: str,\n    recs_path: str,\n    data_transition,\n    metrics,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline.EvaluationPipeline.filter", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline", "qualname": "EvaluationPipeline.filter", "type": "function", "doc": "<p>Run the evaluation on the non-filtered and filtered data\nArgs:</p>\n", "signature": "(self, evaluator, metric, *, set_paths, out_path, profile)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline.EvaluationPipeline.run_evaluation", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline", "qualname": "EvaluationPipeline.run_evaluation", "type": "function", "doc": "<p>Run the evaluation for the specified metric configuration.</p>\n\n<p>Args:\n   evaluator:\n   metric_config:</p>\n\n<p>Keyword Args:\n    sets:\n    out_path:</p>\n", "signature": "(\n    self,\n    evaluator: src.fairreckitlib.evaluation.metrics.evaluator.Evaluator,\n    metric_config: src.fairreckitlib.evaluation.pipeline.evaluation_config.MetricConfig,\n    *,\n    sets,\n    out_path\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline.EvaluationPipeline.load_data", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline", "qualname": "EvaluationPipeline.load_data", "type": "function", "doc": "<p>Load the train and test set, as well as the model recommendations/predictions.</p>\n\n<p>Returns:\n    the train set, test set and model results set (DataFrames)</p>\n", "signature": "(\n    self,\n    set_paths: Tuple[str, str, str],\n    *,\n    use_filter=False\n) -> Tuple[pandas.core.frame.DataFrame, pandas.core.frame.DataFrame, pandas.core.frame.DataFrame]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline.add_evaluation_to_file", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline", "qualname": "add_evaluation_to_file", "type": "function", "doc": "<p>Add an evaluation result to the list in the overview file.</p>\n\n<p>Args:\n    file_path: the path to the evaluations overview file.\n    evaluation_value: the evaluation result.\n    metric_config: the metric configuration used for the evaluation.</p>\n", "signature": "(file_path, evaluation_value, metric_config)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline.filter_pass", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_pipeline", "qualname": "filter_pass", "type": "function", "doc": "<p>Make temporary filtered data</p>\n\n<p>Args:\n    set_paths: paths to the train and test set and model result\n    profile: additional dataset information for filtering\n    filter_passes: list of filter passes to perform</p>\n\n<p>Returns:\n    the paths of the filtered data.</p>\n", "signature": "(set_paths, profile, filter_passes)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_run", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_run", "type": "module", "doc": "<p>This module contains functionality that wraps running the evaluation pipeline multiple times.</p>\n\n<p>Classes:</p>\n\n<pre><code>EvaluationPipelineConfig: configuration class to run the evaluation pipelines.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>run_evaluation_pipelines: run (multiple) pipelines for specified metric configurations.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_run.EvaluationPipelineConfig", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_run", "qualname": "EvaluationPipelineConfig", "type": "class", "doc": "<p>Evaluation Pipeline Configuration.</p>\n\n<p>output_dir: the directory to store the output.\ndata_transition: data input.\nevaluation_factory: the factory with available group metric factories.\nevaluation: list of metric configurations to compute.</p>\n"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_run.EvaluationPipelineConfig.__init__", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_run", "qualname": "EvaluationPipelineConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    model_dirs: List[str],\n    data_transition: src.fairreckitlib.data.data_transition.DataTransition,\n    evaluation_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    evaluation: List[src.fairreckitlib.evaluation.pipeline.evaluation_config.MetricConfig]\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.evaluation.pipeline.evaluation_run.run_evaluation_pipelines", "modulename": "src.fairreckitlib.evaluation.pipeline.evaluation_run", "qualname": "run_evaluation_pipelines", "type": "function", "doc": "<p>Run several evaluation pipelines according to the specified eval pipeline configuration.</p>\n\n<p>Args:\n    pipeline_config: the configuration on how to run the evaluation pipelines.\n    event_dispatcher: used to dispatch eval/IO events when running the evaluation pipelines.\n    is_running: function that returns whether the pipelines\n        are still running. Stops early when False is returned.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads an evaluation can use.\n    num_items(int): the number of item recommendations to produce, only\n        needed when running recommender pipelines.</p>\n", "signature": "(\n    pipeline_config: src.fairreckitlib.evaluation.pipeline.evaluation_run.EvaluationPipelineConfig,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher,\n    is_running: Callable[[], bool],\n    **kwargs\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment", "modulename": "src.fairreckitlib.experiment", "type": "module", "doc": "<p>This package contains functionality for running the experiment pipeline.</p>\n\n<p>Modules:</p>\n\n<pre><code>experiment_config: experiment configuration classes.\nexperiment_config_parsing: parse experiment configurations.\nexperiment_event: event ids, event args and a print switch for the experiment pipeline/thread.\nexperiment_pipeline: the experiment pipeline class.\nexperiment_run: run (multiple) experiment pipelines.\nexperiment_thread: execute the experiment pipelines on a thread.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.experiment.experiment_config", "modulename": "src.fairreckitlib.experiment.experiment_config", "type": "module", "doc": "<p>This module contains the experiment configurations.</p>\n\n<p>Classes:</p>\n\n<pre><code>ExperimentConfig: base experiment configuration.\nPredictorExperimentConfig: a prediction experiment configuration.\nRecommenderExperimentConfig: a recommender experiment configuration.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.experiment.experiment_config.ExperimentConfig", "modulename": "src.fairreckitlib.experiment.experiment_config", "qualname": "ExperimentConfig", "type": "class", "doc": "<p>Base Experiment Configuration.</p>\n"}, {"fullname": "src.fairreckitlib.experiment.experiment_config.ExperimentConfig.__init__", "modulename": "src.fairreckitlib.experiment.experiment_config", "qualname": "ExperimentConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    datasets: [<class 'src.fairreckitlib.data.pipeline.data_config.DataMatrixConfig'>],\n    models: Dict[str, List[src.fairreckitlib.model.pipeline.model_config.ModelConfig]],\n    evaluation: [<class 'src.fairreckitlib.evaluation.pipeline.evaluation_config.MetricConfig'>],\n    name: str,\n    type: str\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_config.ExperimentConfig.to_yml_format", "modulename": "src.fairreckitlib.experiment.experiment_config", "qualname": "ExperimentConfig.to_yml_format", "type": "function", "doc": "<p>Format experiment configuration to a yml compatible dictionary.</p>\n\n<p>Returns:\n    a dictionary containing the experiment configuration.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_config.PredictorExperimentConfig", "modulename": "src.fairreckitlib.experiment.experiment_config", "qualname": "PredictorExperimentConfig", "type": "class", "doc": "<p>Prediction Experiment Configuration.</p>\n", "bases": "ExperimentConfig"}, {"fullname": "src.fairreckitlib.experiment.experiment_config.PredictorExperimentConfig.__init__", "modulename": "src.fairreckitlib.experiment.experiment_config", "qualname": "PredictorExperimentConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    datasets: [<class 'src.fairreckitlib.data.pipeline.data_config.DataMatrixConfig'>],\n    models: Dict[str, List[src.fairreckitlib.model.pipeline.model_config.ModelConfig]],\n    evaluation: [<class 'src.fairreckitlib.evaluation.pipeline.evaluation_config.MetricConfig'>],\n    name: str,\n    type: str\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_config.RecommenderExperimentConfig", "modulename": "src.fairreckitlib.experiment.experiment_config", "qualname": "RecommenderExperimentConfig", "type": "class", "doc": "<p>Recommender Experiment Configuration.</p>\n", "bases": "ExperimentConfig"}, {"fullname": "src.fairreckitlib.experiment.experiment_config.RecommenderExperimentConfig.__init__", "modulename": "src.fairreckitlib.experiment.experiment_config", "qualname": "RecommenderExperimentConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    datasets: [<class 'src.fairreckitlib.data.pipeline.data_config.DataMatrixConfig'>],\n    models: Dict[str, List[src.fairreckitlib.model.pipeline.model_config.ModelConfig]],\n    evaluation: [<class 'src.fairreckitlib.evaluation.pipeline.evaluation_config.MetricConfig'>],\n    name: str,\n    type: str,\n    top_k: int,\n    rated_items_filter: bool\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_config.RecommenderExperimentConfig.to_yml_format", "modulename": "src.fairreckitlib.experiment.experiment_config", "qualname": "RecommenderExperimentConfig.to_yml_format", "type": "function", "doc": "<p>Format recommender experiment configuration to a yml compatible dictionary.</p>\n\n<p>Returns:\n    a dictionary containing the experiment configuration.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_config_parsing", "modulename": "src.fairreckitlib.experiment.experiment_config_parsing", "type": "module", "doc": "<p>This module contains a parser for the experiment configuration.</p>\n\n<p>Classes:</p>\n\n<pre><code>Parser: parse an experiment configuration from a dictionary or yml.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.experiment.experiment_config_parsing.Parser", "modulename": "src.fairreckitlib.experiment.experiment_config_parsing", "qualname": "Parser", "type": "class", "doc": "<p>Experiment Configuration Parser.</p>\n\n<p>Public methods:</p>\n\n<p>parse_experiment_config\nparse_experiment_config_from_yml</p>\n"}, {"fullname": "src.fairreckitlib.experiment.experiment_config_parsing.Parser.__init__", "modulename": "src.fairreckitlib.experiment.experiment_config_parsing", "qualname": "Parser.__init__", "type": "function", "doc": "<p>Construct the Parser.</p>\n\n<p>Args:\n    verbose: whether the parser should give verbose output.</p>\n", "signature": "(self, verbose: bool)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_config_parsing.Parser.parse_experiment_config", "modulename": "src.fairreckitlib.experiment.experiment_config_parsing", "qualname": "Parser.parse_experiment_config", "type": "function", "doc": "<p>Parse an experiment configuration.</p>\n\n<p>Args:\n    experiment_config: the experiment's total configuration.\n    data_registry: the data registry containing the available datasets.\n    experiment_factory: the factory containing all three pipeline factories.</p>\n\n<p>Returns:\n    the parsed configuration or None on failure.</p>\n", "signature": "(\n    self,\n    experiment_config: Dict[str, Any],\n    data_registry: src.fairreckitlib.data.set.dataset_registry.DataRegistry,\n    experiment_factory: src.fairreckitlib.core.config.config_factories.GroupFactory\n) -> Union[src.fairreckitlib.experiment.experiment_config.PredictorExperimentConfig, src.fairreckitlib.experiment.experiment_config.RecommenderExperimentConfig, NoneType]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_config_parsing.Parser.parse_experiment_config_from_yml", "modulename": "src.fairreckitlib.experiment.experiment_config_parsing", "qualname": "Parser.parse_experiment_config_from_yml", "type": "function", "doc": "<p>Parse an experiment configuration from a yml file.</p>\n\n<p>Args:\n    file_path: path to the yml file without extension.\n    data_registry: the data registry containing the available datasets.\n    experiment_factory: the factory containing all three pipeline factories.</p>\n\n<p>Returns:\n    the parsed configuration or None on failure.</p>\n", "signature": "(\n    self,\n    file_path: str,\n    data_registry: src.fairreckitlib.data.set.dataset_registry.DataRegistry,\n    experiment_factory: src.fairreckitlib.core.config.config_factories.GroupFactory\n) -> Union[src.fairreckitlib.experiment.experiment_config.PredictorExperimentConfig, src.fairreckitlib.experiment.experiment_config.RecommenderExperimentConfig, NoneType]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_config_parsing.Parser.parse_experiment_name", "modulename": "src.fairreckitlib.experiment.experiment_config_parsing", "qualname": "Parser.parse_experiment_name", "type": "function", "doc": "<p>Parse the name of the experiment.</p>\n\n<p>Args:\n    experiment_config(dict): the experiment's total configuration.</p>\n\n<p>Returns:\n    the name of the experiment or None on failure.</p>\n", "signature": "(self, experiment_config: Dict[str, Any]) -> Optional[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_config_parsing.Parser.parse_experiment_top_k", "modulename": "src.fairreckitlib.experiment.experiment_config_parsing", "qualname": "Parser.parse_experiment_top_k", "type": "function", "doc": "<p>Parse the top K of the recommender experiment.</p>\n\n<p>Args:\n    recommender_experiment_config: the experiment's total configuration.</p>\n\n<p>Returns:\n    the topK of the experiment or default_top_k on failure.</p>\n", "signature": "(self, recommender_experiment_config: Dict[str, Any]) -> int", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_config_parsing.Parser.parse_experiment_type", "modulename": "src.fairreckitlib.experiment.experiment_config_parsing", "qualname": "Parser.parse_experiment_type", "type": "function", "doc": "<p>Parse the type of the experiment.</p>\n\n<p>Args:\n    experiment_config: the experiment's total configuration.</p>\n\n<p>Returns:\n    the type of the experiment or None on failure.</p>\n", "signature": "(self, experiment_config: Dict[str, Any]) -> Optional[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_event", "modulename": "src.fairreckitlib.experiment.experiment_event", "type": "module", "doc": "<p>This module contains all event ids, event args and a print switch for the experiment pipeline.</p>\n\n<p>Constants:</p>\n\n<pre><code>ON_BEGIN_EXPERIMENT_PIPELINE: id of the event that is used when the experiment pipeline starts.\nON_END_EXPERIMENT_PIPELINE: id of the event that is used when the experiment pipeline ends.\nON_BEGIN_THREAD_EXPERIMENT: id of the event that is used when the experiment thread starts.\nON_END_THREAD_EXPERIMENT: id of the event that is used when the experiment thread ends.\n</code></pre>\n\n<p>Classes:</p>\n\n<pre><code>ExperimentEventArgs: event args related to an experiment.\nExperimentThreadEventArgs: event args related to an experiment thread.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>get_experiment_events: list of experiment pipeline event IDs.\nget_experiment_event_print_switch: switch to print experiment pipeline event arguments by ID.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.experiment.experiment_event.ExperimentEventArgs", "modulename": "src.fairreckitlib.experiment.experiment_event", "qualname": "ExperimentEventArgs", "type": "class", "doc": "<p>Experiment Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the experiment event.\nexperiment_name: the name of the experiment.</p>\n", "bases": "src.fairreckitlib.core.events.event_args.EventArgs"}, {"fullname": "src.fairreckitlib.experiment.experiment_event.ExperimentEventArgs.__init__", "modulename": "src.fairreckitlib.experiment.experiment_event", "qualname": "ExperimentEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, event_id: str, experiment_name: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_event.ExperimentThreadEventArgs", "modulename": "src.fairreckitlib.experiment.experiment_event", "qualname": "ExperimentThreadEventArgs", "type": "class", "doc": "<p>Experiment Thread Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the experiment event.\nexperiment_name: the name of the experiment.\nnum_runs: the amount of times the experiment will run.\nis_running: whether the experiment thread is running or aborted.</p>\n", "bases": "ExperimentEventArgs"}, {"fullname": "src.fairreckitlib.experiment.experiment_event.ExperimentThreadEventArgs.__init__", "modulename": "src.fairreckitlib.experiment.experiment_event", "qualname": "ExperimentThreadEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    event_id: str,\n    experiment_name: str,\n    num_runs: int,\n    is_running: bool = True\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_event.ExperimentThreadEventArgs.is_running", "modulename": "src.fairreckitlib.experiment.experiment_event", "qualname": "ExperimentThreadEventArgs.is_running", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": " = True"}, {"fullname": "src.fairreckitlib.experiment.experiment_event.get_experiment_events", "modulename": "src.fairreckitlib.experiment.experiment_event", "qualname": "get_experiment_events", "type": "function", "doc": "<p>Get a list of experiment pipeline event IDs.</p>\n\n<p>Returns:\n    a list of unique experiment pipeline event IDs.</p>\n", "signature": "() -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_event.get_experiment_print_switch", "modulename": "src.fairreckitlib.experiment.experiment_event", "qualname": "get_experiment_print_switch", "type": "function", "doc": "<p>Get a switch that prints experiment pipeline event IDs.</p>\n\n<p>Returns:\n    the print experiment pipeline event switch.</p>\n", "signature": "(\n    elapsed_time: float = None\n) -> Dict[str, Callable[[src.fairreckitlib.core.events.event_args.EventArgs], NoneType]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_factory", "modulename": "src.fairreckitlib.experiment.experiment_factory", "type": "module", "doc": "<p>This module contains functionality to create an experiment factory.</p>\n\n<p>Functions:</p>\n\n<pre><code>create_experiment_factory: create factory with pipeline factories.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.experiment.experiment_factory.create_experiment_factory", "modulename": "src.fairreckitlib.experiment.experiment_factory", "qualname": "create_experiment_factory", "type": "function", "doc": "<p>Create a group factory with all three pipeline factories.</p>\n\n<p>Consists of three factories:\n    1) data factory.\n    2) model factory.\n    3) evaluation factory.</p>\n\n<p>Returns:\n    the group factory containing the pipeline factories.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_factories.GroupFactory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_pipeline", "modulename": "src.fairreckitlib.experiment.experiment_pipeline", "type": "module", "doc": "<p>This module contains functionality of the complete experiment pipeline.</p>\n\n<p>Classes:</p>\n\n<pre><code>ExperimentPipeline: class that connects the data, model and evaluation pipelines.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>add_result_to_overview: add a computed result to the experiment result overview.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.experiment.experiment_pipeline.ExperimentPipeline", "modulename": "src.fairreckitlib.experiment.experiment_pipeline", "qualname": "ExperimentPipeline", "type": "class", "doc": "<p>ExperimentPipeline that consists of the data, model and evaluation pipelines.</p>\n\n<p>The experiment pipeline connects the three pipelines, by first running the data\npipeline for all the specified dataset configurations. Each of the\nresulting data transitions is forwarded through the model pipelines where all the\nspecified model configurations will compute rating results. These in turn are\nforwarded to the evaluation pipelines to compute the specified metric configurations\nof the performance of the models.</p>\n\n<p>Public methods:</p>\n\n<p>run</p>\n"}, {"fullname": "src.fairreckitlib.experiment.experiment_pipeline.ExperimentPipeline.__init__", "modulename": "src.fairreckitlib.experiment.experiment_pipeline", "qualname": "ExperimentPipeline.__init__", "type": "function", "doc": "<p>Construct the ExperimentPipeline.</p>\n\n<p>Args:\n    data_registry: the registry with available datasets.\n    experiment_factory: the factory containing all three pipeline factories.\n    event_dispatcher: to dispatch the experiment events.</p>\n", "signature": "(\n    self,\n    data_registry: src.fairreckitlib.data.set.dataset_registry.DataRegistry,\n    experiment_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_pipeline.ExperimentPipeline.run", "modulename": "src.fairreckitlib.experiment.experiment_pipeline", "qualname": "ExperimentPipeline.run", "type": "function", "doc": "<p>Run the experiment with the specified configuration.</p>\n\n<p>Args:\n    output_dir: the path of the directory to store the output.\n    experiment_config: the configuration of the experiment.\n    num_threads: the max number of threads the experiment can use.\n    is_running: function that returns whether the experiment\n        is still running. Stops early when False is returned.</p>\n", "signature": "(\n    self,\n    output_dir: str,\n    experiment_config: Union[src.fairreckitlib.experiment.experiment_config.PredictorExperimentConfig, src.fairreckitlib.experiment.experiment_config.RecommenderExperimentConfig],\n    num_threads: int,\n    is_running: Callable[[], bool]\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_pipeline.ExperimentPipeline.start_run", "modulename": "src.fairreckitlib.experiment.experiment_pipeline", "qualname": "ExperimentPipeline.start_run", "type": "function", "doc": "<p>Start the run, making the output dir and initializing the results' storage list.</p>\n\n<p>Args:\n    output_dir: directory in which to store the run storage output.\n    experiment_config: the configuration of the experiment.</p>\n\n<p>Returns:\n    the initial results list and the time the experiment started.</p>\n", "signature": "(\n    self,\n    output_dir: str,\n    experiment_config: src.fairreckitlib.experiment.experiment_config.ExperimentConfig\n) -> Tuple[List[Dict[str, str]], float]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_pipeline.ExperimentPipeline.end_run", "modulename": "src.fairreckitlib.experiment.experiment_pipeline", "qualname": "ExperimentPipeline.end_run", "type": "function", "doc": "<p>End the run, writing the storage file and storing the results.</p>\n\n<p>Args:\n    start_time: time the experiment started.\n    output_dir: directory in which to store the run storage output.\n    experiment_config: the configuration of the experiment.\n    results: the current results list.</p>\n", "signature": "(\n    self,\n    start_time: float,\n    output_dir: str,\n    experiment_config: src.fairreckitlib.experiment.experiment_config.ExperimentConfig,\n    results: List[Dict[str, str]]\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_pipeline.ExperimentPipeline.write_storage_file", "modulename": "src.fairreckitlib.experiment.experiment_pipeline", "qualname": "ExperimentPipeline.write_storage_file", "type": "function", "doc": "<p>Write a JSON file with overview of the results file paths.</p>\n\n<p>Args:\n    output_dir: path to the directory to store the result overview.\n    results: the result overview containing completed computations.</p>\n", "signature": "(self, output_dir: str, results: List[Dict[str, str]]) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_pipeline.add_result_to_overview", "modulename": "src.fairreckitlib.experiment.experiment_pipeline", "qualname": "add_result_to_overview", "type": "function", "doc": "<p>Add result to overview of results file paths.</p>\n\n<p>Args:\n    results: the accumulated result overview.\n    model_dirs: the completed computations to add to the overview.</p>\n\n<p>Returns:\n    the result overview appended with the completed computations.</p>\n", "signature": "(\n    results: List[Dict[str, str]],\n    model_dirs: List[str]\n) -> List[Dict[str, str]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_run", "modulename": "src.fairreckitlib.experiment.experiment_run", "type": "module", "doc": "<p>This module contains functionality to run the experiment pipelines.</p>\n\n<p>Classes:</p>\n\n<pre><code>ExperimentPipelineConfig: configuration class to run the experiment pipelines.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>run_experiment_pipelines: run the pipeline one or more runs.\nresolve_experiment_start_run: resolve the start run of an existing result directory.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.experiment.experiment_run.ExperimentPipelineConfig", "modulename": "src.fairreckitlib.experiment.experiment_run", "qualname": "ExperimentPipelineConfig", "type": "class", "doc": "<p>Experiment Pipeline Configuration.</p>\n\n<p>output_dir: the directory to store the output.\ndata_registry: the registry with available datasets.\nexperiment_factory: the factory with data/model/evaluation pipeline factories.\nexperiment_config: the experiment configuration to compute.\nstart_run: the experiment run to start with.\nnum_runs: the number of runs of the experiment.\nnum_threads: the max number of threads the experiment can use.</p>\n"}, {"fullname": "src.fairreckitlib.experiment.experiment_run.ExperimentPipelineConfig.__init__", "modulename": "src.fairreckitlib.experiment.experiment_run", "qualname": "ExperimentPipelineConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    output_dir: str,\n    data_registry: src.fairreckitlib.data.set.dataset_registry.DataRegistry,\n    experiment_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    experiment_config: Union[src.fairreckitlib.experiment.experiment_config.PredictorExperimentConfig, src.fairreckitlib.experiment.experiment_config.RecommenderExperimentConfig],\n    start_run: int,\n    num_runs: int,\n    num_threads: int\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_run.run_experiment_pipelines", "modulename": "src.fairreckitlib.experiment.experiment_run", "qualname": "run_experiment_pipelines", "type": "function", "doc": "<p>Run the experiment pipeline several runs according to the specified pipeline configuration.</p>\n\n<p>Args:\n    pipeline_config: the configuration on how to run the experiment pipelines.\n    event_dispatcher: used to dispatch model/IO events when running the experiment pipelines.\n    is_running: function that returns whether the pipelines\n        are still running. Stops early when False is returned.</p>\n", "signature": "(\n    pipeline_config: src.fairreckitlib.experiment.experiment_run.ExperimentPipelineConfig,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher,\n    is_running: Callable[[], bool]\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_run.resolve_experiment_start_run", "modulename": "src.fairreckitlib.experiment.experiment_run", "qualname": "resolve_experiment_start_run", "type": "function", "doc": "<p>Resolve which run will be next in the specified result directory.</p>\n\n<p>Args:\n    result_dir: path to the result directory to look into.</p>\n\n<p>Returns:\n    the next run index for this result directory.</p>\n", "signature": "(result_dir: str) -> int", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_thread", "modulename": "src.fairreckitlib.experiment.experiment_thread", "type": "module", "doc": "<p>This module contains functionality to execute the experiment pipelines on a thread.</p>\n\n<p>Classes:</p>\n\n<pre><code>ThreadExperiment: class that runs the experiment pipelines on a (closable) thread.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>handle_experiment_event: handles incoming experiment events.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.experiment.experiment_thread.ThreadExperiment", "modulename": "src.fairreckitlib.experiment.experiment_thread", "qualname": "ThreadExperiment", "type": "class", "doc": "<p>Thread that runs the same experiment one or more times.</p>\n", "bases": "src.fairreckitlib.core.threading.thread_base.ThreadBase"}, {"fullname": "src.fairreckitlib.experiment.experiment_thread.ThreadExperiment.__init__", "modulename": "src.fairreckitlib.experiment.experiment_thread", "qualname": "ThreadExperiment.__init__", "type": "function", "doc": "<p>Construct the ExperimentThread.</p>\n\n<p>Args:\n    name the name of the thread.\n    events: events to dispatch for this thread.\n    verbose: whether the thread should give verbose output.</p>\n\n<p>Keyword Args:\n    pipeline_config(ExperimentPipelineConfig): configuration of the experiment pipeline.</p>\n", "signature": "(\n    self,\n    name: str,\n    events: Dict[Any, Callable[[Any], NoneType]] = None,\n    verbose: bool = False,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_thread.ThreadExperiment.on_run", "modulename": "src.fairreckitlib.experiment.experiment_thread", "qualname": "ThreadExperiment.on_run", "type": "function", "doc": "<p>Run the experiment pipeline.</p>\n\n<p>Keyword Args:\n    pipeline_config(ExperimentPipelineConfig): configuration of the experiment pipeline.</p>\n", "signature": "(self, **kwargs)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.experiment.experiment_thread.handle_experiment_event", "modulename": "src.fairreckitlib.experiment.experiment_thread", "qualname": "handle_experiment_event", "type": "function", "doc": "<p>Handle incoming experiment events.</p>\n\n<p>It is assumed that the event finished when the elapsed_time keyword argument is available.</p>\n\n<p>Args:\n    experiment_thread: the listening experiment thread.\n    event_args: the event arguments to handle.</p>\n\n<p>Keyword Args:\n    elapsed_time(float): time that has passed since the event started, expressed in seconds.</p>\n", "signature": "(\n    experiment_thread: src.fairreckitlib.experiment.experiment_thread.ThreadExperiment,\n    event_args: src.fairreckitlib.core.events.event_args.EventArgs,\n    **kwargs\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model", "modulename": "src.fairreckitlib.model", "type": "module", "doc": "<p>This package contains functionality for algorithm/model computations.</p>\n\n<p>Modules:</p>\n\n<pre><code>model_factory: create model factory with available predictor/recommender factories.\n</code></pre>\n\n<p>Packages:</p>\n\n<pre><code>algorithms: prediction/recommender algorithms and implementations.\npipeline: run various model computations with batching.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms", "modulename": "src.fairreckitlib.model.algorithms", "type": "module", "doc": "<p>This package contains functionality for item predictions/recommendations using algorithms.</p>\n\n<p>Modules:</p>\n\n<pre><code>base_algorithm: base class for all algorithms.\nbase_predictor: (base) class for prediction algorithms.\nbase_recommender: (base) class for recommender algorithms.\ntop_k_recommender: class to wrap a predictor as a recommender.\n</code></pre>\n\n<p>Packages:</p>\n\n<pre><code>elliot: recommender implementations.\nimplicit: recommender implementations.\nlenskit: predictor/recommender implementations.\nsurprise: predictor/recommender implementations.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.base_algorithm", "modulename": "src.fairreckitlib.model.algorithms.base_algorithm", "type": "module", "doc": "<p>This module contains the base class for all algorithms.</p>\n\n<p>Classes:</p>\n\n<pre><code>BaseAlgorithm: the base class for algorithms.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm", "modulename": "src.fairreckitlib.model.algorithms.base_algorithm", "qualname": "BaseAlgorithm", "type": "class", "doc": "<p>Base class for FairRecKit algorithms.</p>\n\n<p>An algorithm is used for carrying out recommender system experiments.\nDerived algorithms are expected to implement the abstract interface.</p>\n\n<p>Abstract methods:</p>\n\n<p>on_train</p>\n\n<p>Public methods:</p>\n\n<p>get_items\nget_name\nget_num_threads\nget_params\nget_users\ntrain</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm.__init__", "modulename": "src.fairreckitlib.model.algorithms.base_algorithm", "qualname": "BaseAlgorithm.__init__", "type": "function", "doc": "<p>Construct the algorithm.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm.get_name", "modulename": "src.fairreckitlib.model.algorithms.base_algorithm", "qualname": "BaseAlgorithm.get_name", "type": "function", "doc": "<p>Get the name of the algorithm.</p>\n\n<p>Returns:\n    the algorithm name.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm.get_num_threads", "modulename": "src.fairreckitlib.model.algorithms.base_algorithm", "qualname": "BaseAlgorithm.get_num_threads", "type": "function", "doc": "<p>Get the max number of threads the algorithm can use.</p>\n\n<p>Returns:\n    the number of threads.</p>\n", "signature": "(self) -> int", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm.get_params", "modulename": "src.fairreckitlib.model.algorithms.base_algorithm", "qualname": "BaseAlgorithm.get_params", "type": "function", "doc": "<p>Get the parameters of the algorithm.</p>\n\n<p>Returns:\n    the algorithm parameters.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm.get_items", "modulename": "src.fairreckitlib.model.algorithms.base_algorithm", "qualname": "BaseAlgorithm.get_items", "type": "function", "doc": "<p>Get the (unique) items the algorithm was trained on.</p>\n\n<p>Returns:\n    a list of unique item IDs or None if the algorithm is not trained yet.</p>\n", "signature": "(self) -> Optional[List[int]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm.get_users", "modulename": "src.fairreckitlib.model.algorithms.base_algorithm", "qualname": "BaseAlgorithm.get_users", "type": "function", "doc": "<p>Get the (unique) users the algorithm was trained on.</p>\n\n<p>Returns:\n    a list of unique user IDs or None if the algorithm is not trained yet.</p>\n", "signature": "(self) -> Optional[List[int]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm.train", "modulename": "src.fairreckitlib.model.algorithms.base_algorithm", "qualname": "BaseAlgorithm.train", "type": "function", "doc": "<p>Train the algorithm on the specified train set.</p>\n\n<p>Args:\n    train_set: with at least three columns: 'user', 'item', 'rating'.</p>\n", "signature": "(self, train_set: pandas.core.frame.DataFrame) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm.on_train", "modulename": "src.fairreckitlib.model.algorithms.base_algorithm", "qualname": "BaseAlgorithm.on_train", "type": "function", "doc": "<p>Train the algorithm on the train set.</p>\n\n<p>Derived classes should implement the training logic\nof the algorithm.</p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_predictor", "modulename": "src.fairreckitlib.model.algorithms.base_predictor", "type": "module", "doc": "<p>This module contains the base class for predictors.</p>\n\n<p>Classes:</p>\n\n<pre><code>BasePredictor: base class for predictors.\nPredictor: implements basic shared functionality.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.base_predictor.BasePredictor", "modulename": "src.fairreckitlib.model.algorithms.base_predictor", "qualname": "BasePredictor", "type": "class", "doc": "<p>Base class for FairRecKit predictors.</p>\n\n<p>A predictor is used for prediction experiments. It computes predictions\nfor any user and item that it was trained on.\nDerived predictors are expected to implement the abstract interface.</p>\n\n<p>Abstract methods:</p>\n\n<p>on_predict\non_predict_batch (optional)</p>\n\n<p>Public methods:</p>\n\n<p>predict\npredict_batch</p>\n", "bases": "src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm"}, {"fullname": "src.fairreckitlib.model.algorithms.base_predictor.BasePredictor.__init__", "modulename": "src.fairreckitlib.model.algorithms.base_predictor", "qualname": "BasePredictor.__init__", "type": "function", "doc": "<p>Construct the predictor.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_predictor.BasePredictor.predict", "modulename": "src.fairreckitlib.model.algorithms.base_predictor", "qualname": "BasePredictor.predict", "type": "function", "doc": "<p>Compute a prediction for the specified user and item.</p>\n\n<p>A prediction is impossible when the user and/or item is not\npresent in the unique users and/or items it was trained on.\nMoreover, the prediction could also fail in the derived\nimplementation of the predictor.</p>\n\n<p>Args:\n    user: the user ID.\n    item: the item ID.</p>\n\n<p>Returns:\n    the predicted rating or NaN when impossible.</p>\n", "signature": "(self, user: int, item: int) -> float", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_predictor.BasePredictor.on_predict", "modulename": "src.fairreckitlib.model.algorithms.base_predictor", "qualname": "BasePredictor.on_predict", "type": "function", "doc": "<p>Compute a prediction for the specified user and item.</p>\n\n<p>The user and item are assumed to be present in the train\nset that the predictor was trained on.\nDerived implementations are allowed to return NaN when the\nprediction is impossible to compute.</p>\n\n<p>Args:\n    user: the user ID.\n    item: the item ID.</p>\n\n<p>Returns:\n    the predicted rating or NaN when impossible.</p>\n", "signature": "(self, user: int, item: int) -> float", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_predictor.BasePredictor.predict_batch", "modulename": "src.fairreckitlib.model.algorithms.base_predictor", "qualname": "BasePredictor.predict_batch", "type": "function", "doc": "<p>Compute the predictions for each of the specified user and item pairs.</p>\n\n<p>All the users and items in the pairs that are not present in the train set that\nthe predictor was trained on are filtered before predictions are made.</p>\n\n<p>Args:\n    user_item_pairs: with at least two columns: 'user' and 'item'.</p>\n\n<p>Returns:\n    a dataFrame with the columns: 'user', 'item', 'prediction'.</p>\n", "signature": "(\n    self,\n    user_item_pairs: pandas.core.frame.DataFrame\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_predictor.BasePredictor.on_predict_batch", "modulename": "src.fairreckitlib.model.algorithms.base_predictor", "qualname": "BasePredictor.on_predict_batch", "type": "function", "doc": "<p>Compute the predictions for each of the specified user and item pairs.</p>\n\n<p>All the users and items in the pairs are assumed to be present in the train\nset that the predictor was trained on.\nA standard batch implementation is provided, but derived classes are\nallowed to override batching with their own logic.</p>\n\n<p>Args:\n    user_item_pairs: with two columns: 'user' and 'item'.</p>\n\n<p>Returns:\n    a dataFrame with the columns: 'user', 'item', 'prediction'.</p>\n", "signature": "(\n    self,\n    user_item_pairs: pandas.core.frame.DataFrame\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_predictor.Predictor", "modulename": "src.fairreckitlib.model.algorithms.base_predictor", "qualname": "Predictor", "type": "class", "doc": "<p>Predictor that implements basic shared functionality.</p>\n", "bases": "BasePredictor"}, {"fullname": "src.fairreckitlib.model.algorithms.base_predictor.Predictor.__init__", "modulename": "src.fairreckitlib.model.algorithms.base_predictor", "qualname": "Predictor.__init__", "type": "function", "doc": "<p>Construct the predictor.</p>\n\n<p>Args:\n    name: the name of the predictor.\n    params: the parameters of the predictor.\n    num_threads: the max number of threads the predictor can use.</p>\n", "signature": "(self, name: str, params: Dict[str, Any], num_threads: int)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_predictor.Predictor.get_name", "modulename": "src.fairreckitlib.model.algorithms.base_predictor", "qualname": "Predictor.get_name", "type": "function", "doc": "<p>Get the name of the predictor.</p>\n\n<p>Returns:\n    the predictor name.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_predictor.Predictor.get_num_threads", "modulename": "src.fairreckitlib.model.algorithms.base_predictor", "qualname": "Predictor.get_num_threads", "type": "function", "doc": "<p>Get the max number of threads the predictor can use.</p>\n\n<p>Returns:\n    the number of threads.</p>\n", "signature": "(self) -> int", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_predictor.Predictor.get_params", "modulename": "src.fairreckitlib.model.algorithms.base_predictor", "qualname": "Predictor.get_params", "type": "function", "doc": "<p>Get the parameters of the predictor.</p>\n\n<p>Returns:\n    the predictor parameters.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_recommender", "modulename": "src.fairreckitlib.model.algorithms.base_recommender", "type": "module", "doc": "<p>This module contains the base class for recommenders.</p>\n\n<p>Classes:</p>\n\n<pre><code>BaseRecommender: base class for recommenders.\nRecommender: implements basic shared functionality.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.base_recommender.BaseRecommender", "modulename": "src.fairreckitlib.model.algorithms.base_recommender", "qualname": "BaseRecommender", "type": "class", "doc": "<p>Base class for FairRecKit recommenders.</p>\n\n<p>A recommender is used for recommender experiments. It computes a number of\nitem recommendations for any user that it was trained on.\nDerived recommenders are expected to implement the abstract interface.</p>\n\n<p>Abstract methods:</p>\n\n<p>on_recommend\non_recommend_batch (optional)</p>\n\n<p>Public methods:</p>\n\n<p>has_rated_items_filter\nrecommend\nrecommend_batch</p>\n", "bases": "src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm"}, {"fullname": "src.fairreckitlib.model.algorithms.base_recommender.BaseRecommender.__init__", "modulename": "src.fairreckitlib.model.algorithms.base_recommender", "qualname": "BaseRecommender.__init__", "type": "function", "doc": "<p>Construct the recommender.</p>\n\n<p>Args:\n    rated_items_filter: whether to filter already rated items when\n        producing item recommendations.</p>\n", "signature": "(self, rated_items_filter: bool)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_recommender.BaseRecommender.has_rated_items_filter", "modulename": "src.fairreckitlib.model.algorithms.base_recommender", "qualname": "BaseRecommender.has_rated_items_filter", "type": "function", "doc": "<p>Get if the recommender filters already rated items when producing recommendations.</p>\n\n<p>Returns:\n    whether the recommender filters already rated items.</p>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_recommender.BaseRecommender.recommend", "modulename": "src.fairreckitlib.model.algorithms.base_recommender", "qualname": "BaseRecommender.recommend", "type": "function", "doc": "<p>Compute item recommendations for the specified user.</p>\n\n<p>A recommendation is impossible when the user is not present in\nthe unique users it was trained on and will return an empty dataframe.</p>\n\n<p>Args:\n    user: the user ID to compute recommendations for.\n    num_items: the number of item recommendations to produce.</p>\n\n<p>Returns:\n    a dataframe with the columns: 'item' and 'score'.</p>\n", "signature": "(self, user: int, num_items: int = 10) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_recommender.BaseRecommender.on_recommend", "modulename": "src.fairreckitlib.model.algorithms.base_recommender", "qualname": "BaseRecommender.on_recommend", "type": "function", "doc": "<p>Compute item recommendations for the specified user.</p>\n\n<p>The user is assumed to be present in the train set that the\nrecommender was trained on.\nDerived implementations are expected to return a dataframe\nwith the 'score' column in descending order.</p>\n\n<p>Args:\n    user: the user ID to compute recommendations for.\n    num_items: the number of item recommendations to produce.</p>\n\n<p>Returns:\n    a dataframe with the columns: 'item' and 'score'.</p>\n", "signature": "(self, user: int, num_items: int) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_recommender.BaseRecommender.recommend_batch", "modulename": "src.fairreckitlib.model.algorithms.base_recommender", "qualname": "BaseRecommender.recommend_batch", "type": "function", "doc": "<p>Compute the items recommendations for each of the specified users.</p>\n\n<p>All the users that are not present in the train set that the recommender\nwas trained on are filtered before recommendations are made.</p>\n\n<p>Args:\n    users: the user ID's to compute recommendations for.\n    num_items: the number of item recommendations to produce.</p>\n\n<p>Returns:\n    a dataframe with the columns: 'rank', 'user', 'item', 'score'.</p>\n", "signature": "(\n    self,\n    users: List[int],\n    num_items: int = 10\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_recommender.BaseRecommender.on_recommend_batch", "modulename": "src.fairreckitlib.model.algorithms.base_recommender", "qualname": "BaseRecommender.on_recommend_batch", "type": "function", "doc": "<p>Compute the items recommendations for each of the specified users.</p>\n\n<p>All the users are assumed to be present in the train set that\nthe recommender was trained on.\nA standard batch implementation is provided, but derived classes are\nallowed to override batching with their own logic.</p>\n\n<p>Args:\n    users: the user ID's to compute recommendations for.\n    num_items: the number of item recommendations to produce.</p>\n\n<p>Returns:\n    a dataframe with the columns: 'rank', 'user', 'item', 'score'.</p>\n", "signature": "(self, users: List[int], num_items: int) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_recommender.Recommender", "modulename": "src.fairreckitlib.model.algorithms.base_recommender", "qualname": "Recommender", "type": "class", "doc": "<p>Recommender that implements basic shared functionality.</p>\n", "bases": "BaseRecommender"}, {"fullname": "src.fairreckitlib.model.algorithms.base_recommender.Recommender.__init__", "modulename": "src.fairreckitlib.model.algorithms.base_recommender", "qualname": "Recommender.__init__", "type": "function", "doc": "<p>Construct the recommender.</p>\n\n<p>Args:\n    name: the name of the recommender.\n    params: the parameters of the recommender.\n    num_threads: the max number of threads the recommender can use.\n    rated_items_filter: whether to filter already rated items when\n        producing item recommendations.</p>\n", "signature": "(\n    self,\n    name: str,\n    params: Dict[str, Any],\n    num_threads: int,\n    rated_items_filter: bool\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_recommender.Recommender.get_name", "modulename": "src.fairreckitlib.model.algorithms.base_recommender", "qualname": "Recommender.get_name", "type": "function", "doc": "<p>Get the name of the recommender.</p>\n\n<p>Returns:\n    the recommender name.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_recommender.Recommender.get_num_threads", "modulename": "src.fairreckitlib.model.algorithms.base_recommender", "qualname": "Recommender.get_num_threads", "type": "function", "doc": "<p>Get the max number of threads the recommender can use.</p>\n\n<p>Returns:\n    the number of threads.</p>\n", "signature": "(self) -> int", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.base_recommender.Recommender.get_params", "modulename": "src.fairreckitlib.model.algorithms.base_recommender", "qualname": "Recommender.get_params", "type": "function", "doc": "<p>Get the parameters of the recommender.</p>\n\n<p>Returns:\n    the recommender parameters.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot", "modulename": "src.fairreckitlib.model.algorithms.elliot", "type": "module", "doc": "<p>This package contains functionality for recommenders of the Elliot framework.</p>\n\n<p>Modules:</p>\n\n<pre><code>elliot_algorithms: name constants for implemented algorithms.\nelliot_factory: create recommender factory.\nelliot_params: create config parameters for implemented algorithms.\nelliot_recommender: class for recommender implementation and creation functions.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_algorithms", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_algorithms", "type": "module", "doc": "<p>This module contains name constants for implemented elliot algorithms.</p>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_factory", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_factory", "type": "module", "doc": "<p>This module contains functionality to create the elliot recommender factory.</p>\n\n<p>Functions:</p>\n\n<pre><code>create_recommender_factory: create factory with elliot recommenders.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_factory.create_recommender_factory", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_factory", "qualname": "create_recommender_factory", "type": "function", "doc": "<p>Create the factory with Elliot recommenders.</p>\n\n<p>Returns:\n    the factory with all available recommenders.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_factories.Factory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_params", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_params", "type": "module", "doc": "<p>This module contains the parameter creation functions for elliot recommenders.</p>\n\n<p>Functions:</p>\n\n<pre><code>create_params_funk_svd: create FunkSVD config parameters.\ncreate_params_knn: create ItemKNN/UserKNN config parameters.\ncreate_params_multi_vae: create MultiVAE config parameters.\ncreate_params_pure_svd: create PureSVD config parameters.\ncreate_params_svd_pp: create SVDpp config parameters.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_params.create_params_funk_svd", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_params", "qualname": "create_params_funk_svd", "type": "function", "doc": "<p>Create the parameters of the FunkSVD algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_params.create_params_knn", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_params", "qualname": "create_params_knn", "type": "function", "doc": "<p>Create the parameters of the ItemKNN/UserKNN algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_params.create_params_multi_vae", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_params", "qualname": "create_params_multi_vae", "type": "function", "doc": "<p>Create the parameters of the MultiVAE algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_params.create_params_pure_svd", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_params", "qualname": "create_params_pure_svd", "type": "function", "doc": "<p>Create the parameters of the PureSVD algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_params.create_params_svd_pp", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_params", "qualname": "create_params_svd_pp", "type": "function", "doc": "<p>Create the parameters of the SVDpp algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "type": "module", "doc": "<p>This module contains the elliot recommender and creation functions.</p>\n\n<p>Classes:</p>\n\n<pre><code>ElliotRecommender: recommender implementation for elliot.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_funk_svd: create FunkSVD recommender (factory creation compatible).\ncreate_item_knn: create ItemKNN recommender (factory creation compatible).\ncreate_most_pop: create MostPop recommender (factory creation compatible).\ncreate_multi_vae: create MultiVAE recommender (factory creation compatible).\ncreate_pure_svd: create PureSVD recommender (factory creation compatible).\ncreate_random: create Random recommender (factory creation compatible).\ncreate_user_knn: create UserKNN recommender (factory creation compatible).\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender.ElliotRecommender", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "qualname": "ElliotRecommender", "type": "class", "doc": "<p>Recommender implementation for the Elliot framework.</p>\n", "bases": "src.fairreckitlib.model.algorithms.base_recommender.Recommender"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender.ElliotRecommender.__init__", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "qualname": "ElliotRecommender.__init__", "type": "function", "doc": "<p>Construct the elliot recommender.</p>\n\n<p>The recommender is not procedural, instead it serves as a wrapper\nthat holds the correct parameters used by the framework which are\nused in the model pipeline.</p>\n\n<p>Args:\n    name: the name of the recommender.\n    params: the parameters of the recommender.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the recommender can use.\n    rated_items_filter(bool): whether to filter already rated items when\n        producing item recommendations.</p>\n", "signature": "(self, name: str, params: Dict[str, Any], **kwargs)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender.ElliotRecommender.on_train", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "qualname": "ElliotRecommender.on_train", "type": "function", "doc": "<p>Train the elliot model not supported.</p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender.ElliotRecommender.on_recommend", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "qualname": "ElliotRecommender.on_recommend", "type": "function", "doc": "<p>Recommend with the elliot model not supported.</p>\n", "signature": "(self, user: int, num_items: int) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender.ElliotRecommender.on_recommend_batch", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "qualname": "ElliotRecommender.on_recommend_batch", "type": "function", "doc": "<p>Recommend batching with the elliot model not supported.</p>\n", "signature": "(self, users: List[int], num_items: int) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender.create_funk_svd", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "qualname": "create_funk_svd", "type": "function", "doc": "<p>Create the FunkSVD recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        epochs(int): number of iterations.\n        factors(int): number of factors of feature embeddings.\n        learning_rate(float): the learning rate.\n        regularization_factors(float): regularization coefficient for latent factors.\n        regularization_bias(flot): regularization coefficient for bias.\n        seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the ElliotRecommender wrapper of FunkSVD.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.elliot.elliot_recommender.ElliotRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender.create_item_knn", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "qualname": "create_item_knn", "type": "function", "doc": "<p>Create the ItemKNN recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        neighbors(int): number of item neighbors.\n        similarity(str): similarity function to use.\n        implementation(str): implementation type (\u2018aiolli\u2019 or \u2018classical\u2019).</p>\n\n<p>Returns:\n    the ElliotRecommender wrapper of ItemKNN.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.elliot.elliot_recommender.ElliotRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender.create_most_pop", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "qualname": "create_most_pop", "type": "function", "doc": "<p>Create the MostPop recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: there are no parameters for this algorithm.</p>\n\n<p>Returns:\n    the ElliotRecommender wrapper of MostPop.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.elliot.elliot_recommender.ElliotRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender.create_multi_vae", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "qualname": "create_multi_vae", "type": "function", "doc": "<p>Create the MultiVAE recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        iterations(int): number of iterations.\n        factors(int): number of latent factors.\n        learning_rate(float): the learning rate.\n        intermediate_dimensions(int): number of intermediate dimension.\n        regularization_factors(float): regularization coefficient.\n        dropout_probability(float): the dropout probability.\n        seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the ElliotRecommender wrapper of MultiVAE.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.elliot.elliot_recommender.ElliotRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender.create_pure_svd", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "qualname": "create_pure_svd", "type": "function", "doc": "<p>Create the PureSVD recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        factors(int): number of latent factors.\n        seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the ElliotRecommender wrapper of PureSVD.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.elliot.elliot_recommender.ElliotRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender.create_random", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "qualname": "create_random", "type": "function", "doc": "<p>Create the Random recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the ElliotRecommender wrapper of Random.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.elliot.elliot_recommender.ElliotRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender.create_svd_pp", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "qualname": "create_svd_pp", "type": "function", "doc": "<p>Create the SVDpp recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        iterations(int): number of iterations.\n        factors(int): number of latent factors.\n        learning_rate(float): the learning rate.\n        regularization_factors(float): regularization coefficient for latent factors.\n        regularization_bias(float): regularization coefficient for bias.\n        seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the ElliotRecommender wrapper of SVDpp.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.elliot.elliot_recommender.ElliotRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender.create_user_knn", "modulename": "src.fairreckitlib.model.algorithms.elliot.elliot_recommender", "qualname": "create_user_knn", "type": "function", "doc": "<p>Create the UserKNN recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        neighbors(int): number of user neighbors.\n        similarity(str): similarity function to use.\n        implementation(str): implementation type (\u2018aiolli\u2019 or \u2018classical\u2019).</p>\n\n<p>Returns:\n    the ElliotRecommender wrapper of UserKNN.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.elliot.elliot_recommender.ElliotRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit", "modulename": "src.fairreckitlib.model.algorithms.implicit", "type": "module", "doc": "<p>This package contains functionality for recommenders of the Implicit package.</p>\n\n<p>Modules:</p>\n\n<pre><code>implicit_algorithms: name constants for implemented algorithms.\nimplicit_factory: create recommender factory.\nimplicit_params: create config parameters for implemented algorithms.\nimplicit_recommender: class for recommender implementation and creation functions.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_algorithms", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_algorithms", "type": "module", "doc": "<p>This module contains name constants for implemented implicit algorithms.</p>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_factory", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_factory", "type": "module", "doc": "<p>This module contains functionality to create the implicit recommender factory.</p>\n\n<p>Functions:</p>\n\n<pre><code>create_recommender_factory: create factory with implicit recommenders.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_factory.create_recommender_factory", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_factory", "qualname": "create_recommender_factory", "type": "function", "doc": "<p>Create the factory with Implicit recommenders.</p>\n\n<p>Returns:\n    the factory with all available recommenders.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_factories.Factory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_params", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_params", "type": "module", "doc": "<p>This module contains the parameter creation functions for implicit recommenders.</p>\n\n<p>Functions:</p>\n\n<pre><code>create_params_als: create AlternatingLeastSquares config parameters.\ncreate_params_bpr: create BayesianPersonalizedRanking config parameters.\ncreate_params_lmf: create LogisticMatrixFactorization config parameters.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_params.create_params_als", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_params", "qualname": "create_params_als", "type": "function", "doc": "<p>Create the parameters of the AlternatingLeastSquares algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_params.create_params_bpr", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_params", "qualname": "create_params_bpr", "type": "function", "doc": "<p>Create the parameters of the BayesianPersonalizedRanking algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_params.create_params_lmf", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_params", "qualname": "create_params_lmf", "type": "function", "doc": "<p>Create the parameters of the LogisticMatrixFactorization algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender", "type": "module", "doc": "<p>This module contains the implicit recommender and creation functions.</p>\n\n<p>Classes:</p>\n\n<pre><code>ImplicitRecommender: recommender implementation for implicit.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_als: create AlternatingLeastSquares recommender (factory creation compatible).\ncreate_bpr: create BayesianPersonalizedRanking recommender (factory creation compatible).\ncreate_lmf: create LogisticMatrixFactorization recommender (factory creation compatible).\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender.ImplicitRecommender", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender", "qualname": "ImplicitRecommender", "type": "class", "doc": "<p>Recommender implementation for the Implicit package.</p>\n", "bases": "src.fairreckitlib.model.algorithms.base_recommender.Recommender"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender.ImplicitRecommender.__init__", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender", "qualname": "ImplicitRecommender.__init__", "type": "function", "doc": "<p>Construct the implicit recommender.</p>\n\n<p>Args:\n    algo: the implicit recommender algorithm.\n    name: the name of the recommender.\n    params: the parameters of the recommender.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the recommender can use.\n    rated_items_filter(bool): whether to filter already rated items when\n        producing item recommendations.</p>\n", "signature": "(\n    self,\n    algo: implicit.recommender_base.RecommenderBase,\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender.ImplicitRecommender.on_train", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender", "qualname": "ImplicitRecommender.on_train", "type": "function", "doc": "<p>Train the algorithm on the train set.</p>\n\n<p>Implicit recommenders expect a CSR matrix, convert the train set and store\nit for recommending items.</p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender.ImplicitRecommender.on_recommend", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender", "qualname": "ImplicitRecommender.on_recommend", "type": "function", "doc": "<p>Compute item recommendations for the specified user.</p>\n\n<p>Implicit recommenders use the stored CSR train set to produce item recommendations.</p>\n\n<p>Args:\n    user: the user ID to compute recommendations for.\n    num_items: the number of item recommendations to produce.</p>\n\n<p>Returns:\n    dataframe with the columns: 'item' and 'score'.</p>\n", "signature": "(self, user: int, num_items: int) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender.ImplicitRecommender.on_recommend_batch", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender", "qualname": "ImplicitRecommender.on_recommend_batch", "type": "function", "doc": "<p>Compute the items recommendations for each of the specified users.</p>\n\n<p>Implicit recommenders use the stored CSR train set to produce item recommendations.\nMoreover, they allow for batching multiple users at the same time using multiple threads.</p>\n\n<p>Args:\n    users: the user ID's to compute recommendations for.\n    num_items: the number of item recommendations to produce.</p>\n\n<p>Returns:\n    dataframe with the columns: 'rank', 'user', 'item', 'score'.</p>\n", "signature": "(self, users: List[int], num_items: int) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender.create_als", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender", "qualname": "create_als", "type": "function", "doc": "<p>Create the AlternatingLeastSquares recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        factors(int): the number of latent factors to compute.\n        regularization(float): the regularization factor to use.\n        use_native(bool): use native extensions to speed up model fitting.\n        use_cg(bool): use a faster Conjugate Gradient solver to calculate factors.\n        iterations(int): the number of ALS iterations to use when fitting data.\n        calculate_training_loss(bool): whether to log out the training loss at each iteration.\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the algorithm can use.</p>\n\n<p>Returns:\n    the ImplicitRecommender wrapper of AlternatingLeastSquares.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.implicit.implicit_recommender.ImplicitRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender.create_bpr", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender", "qualname": "create_bpr", "type": "function", "doc": "<p>Create the BayesianPersonalizedRanking recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        factors(int): the number of latent factors to compute.\n        learning_rate(float): the learning rate to apply for SGD updates during training.\n        regularization(float): the regularization factor to use.\n        iterations(int): the number of training epochs to use when fitting the data.\n        verify_negative_samples(bool): when sampling negative items, check if the randomly\n            picked negative item has actually been liked by the user. This check increases\n            the time needed to train but usually leads to better predictions.\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the algorithm can use.</p>\n\n<p>Returns:\n    the ImplicitRecommender wrapper of BayesianPersonalizedRanking.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.implicit.implicit_recommender.ImplicitRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender.create_lmf", "modulename": "src.fairreckitlib.model.algorithms.implicit.implicit_recommender", "qualname": "create_lmf", "type": "function", "doc": "<p>Create the LogisticMatrixFactorization recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        factors(int): the number of latent factors to compute.\n        learning_rate(float): the learning rate to apply for updates during training.\n        regularization(float): the regularization factor to use.\n        iterations(int): the number of training epochs to use when fitting the data.\n        neg_prop(int): the proportion of negative samples.\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the algorithm can use.</p>\n\n<p>Returns:\n    the ImplicitRecommender wrapper of LogisticMatrixFactorization.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.implicit.implicit_recommender.ImplicitRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit", "modulename": "src.fairreckitlib.model.algorithms.lenskit", "type": "module", "doc": "<p>This package contains functionality for predictors/recommenders of the LensKit package.</p>\n\n<p>Modules:</p>\n\n<pre><code>lenskit_algorithms: name constants and creation wrappers for implemented algorithms.\nlenskit_factory: create predictor/recommender factory.\nlenskit_params: create config parameters for implemented algorithms.\nlenskit_predictor: class for predictor implementation and creation functions.\nlenskit_recommender: class for recommender implementation and creation functions.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_algorithms", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_algorithms", "type": "module", "doc": "<p>This module contains name constants and creation wrappers for implemented lenskit algorithms.</p>\n\n<p>Functions:</p>\n\n<pre><code>create_biased_mf: create lenskit BiasedMF algorithm.\ncreate_implicit_mf: create lenskit ImplicitMF algorithm.\ncreate_item_item: create lenskit ItemItem algorithm.\ncreate_pop_score: create lenskit PopScore algorithm.\ncreate_random: create lenskit Random algorithm.\ncreate_user_user: create lenskit UserUser algorithm.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_algorithms.create_biased_mf", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_algorithms", "qualname": "create_biased_mf", "type": "function", "doc": "<p>Create the lenskit BiasedMF algorithm.</p>\n\n<p>Args:\n    params: containing the following name-value pairs:\n        features(int): the number of features to train.\n        iterations(int): the number of iterations to train.\n        user_reg(float): the regularization factor for users.\n        item_reg(float): the regularization factor for items.\n        damping(float): damping factor for the underlying bias.\n        method(str): the solver to use ('cd' or 'lu').\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the lenskit BiasedMF algorithm.</p>\n", "signature": "(params: Dict[str, Any]) -> lenskit.algorithms.als.BiasedMF", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_algorithms.create_implicit_mf", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_algorithms", "qualname": "create_implicit_mf", "type": "function", "doc": "<p>Create the lenskit ImplicitMF algorithm.</p>\n\n<p>Args:\n    params: containing the following name-value pairs:\n        features(int): the number of features to train.\n        iterations(int): the number of iterations to train.\n        reg(float): the regularization factor.\n        weight(flot): the scaling weight for positive samples.\n        use_ratings(bool): whether to use the rating column or treat\n            every rated user-item pair as having a rating of 1.\n        method(str): the training method ('cg' or 'lu').\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the lenskit ImplicitMF algorithm.</p>\n", "signature": "(params: Dict[str, Any]) -> lenskit.algorithms.als.ImplicitMF", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_algorithms.create_item_item", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_algorithms", "qualname": "create_item_item", "type": "function", "doc": "<p>Create the lenskit ItemItem algorithm.</p>\n\n<p>Args:\n    params: containing the following name-value pairs:\n        max_neighbors(int): the maximum number of neighbors for scoring each item.\n        min_neighbors(int): the minimum number of neighbors for scoring each item.\n        min_similarity(float): minimum similarity threshold for considering a neighbor.\n        feedback(str): control how feedback should be interpreted ('explicit' or 'implicit').</p>\n\n<p>Returns:\n    the lenskit ItemItem algorithm.</p>\n", "signature": "(params: Dict[str, Any]) -> lenskit.algorithms.item_knn.ItemItem", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_algorithms.create_pop_score", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_algorithms", "qualname": "create_pop_score", "type": "function", "doc": "<p>Create the lenskit PopScore algorithm.</p>\n\n<p>Args:\n    params: containing the following name-value pairs:\n        score_method(str): for computing popularity scores ('quantile', 'rank' or 'count').</p>\n\n<p>Returns:\n    the lenskit PopScore algorithm.</p>\n", "signature": "(params: Dict[str, Any]) -> lenskit.algorithms.basic.PopScore", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_algorithms.create_random", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_algorithms", "qualname": "create_random", "type": "function", "doc": "<p>Create the lenskit Random algorithm.</p>\n\n<p>Args:\n    params: containing the following name-value pairs:\n        random_seed(int): the random seed or None for the current time as seed.\n    selector: that selects candidate items for recommendations.</p>\n\n<p>Returns:\n    the lenskit Random algorithm.</p>\n", "signature": "(\n    params: Dict[str, Any],\n    selector: lenskit.algorithms.CandidateSelector\n) -> lenskit.algorithms.basic.Random", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_algorithms.create_user_user", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_algorithms", "qualname": "create_user_user", "type": "function", "doc": "<p>Create the lenskit UserUser algorithm.</p>\n\n<p>Args:\n    params: containing the following name-value pairs:\n        max_neighbors(int): the maximum number of neighbors for scoring each item.\n        min_neighbors(int): the minimum number of neighbors for scoring each item.\n        min_similarity(float): minimum similarity threshold for considering a neighbor.\n        feedback(str): control how feedback should be interpreted ('explicit' or 'implicit').</p>\n\n<p>Returns:\n    the lenskit UserUser algorithm.</p>\n", "signature": "(params: Dict[str, Any]) -> lenskit.algorithms.user_knn.UserUser", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_factory", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_factory", "type": "module", "doc": "<p>This module contains functionality to create the lenskit predictor/recommender factory.</p>\n\n<p>Functions:</p>\n\n<pre><code>create_predictor_factory: create factory with lenskit predictors.\ncreate_recommender_factory: create factory with lenskit recommenders.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_factory.create_predictor_factory", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_factory", "qualname": "create_predictor_factory", "type": "function", "doc": "<p>Create the factory with LensKit predictors.</p>\n\n<p>Returns:\n    the factory with all available predictors.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_factories.Factory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_factory.create_recommender_factory", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_factory", "qualname": "create_recommender_factory", "type": "function", "doc": "<p>Create the factory with LensKit recommenders.</p>\n\n<p>Returns:\n    the factory with all available recommenders.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_factories.Factory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_params", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_params", "type": "module", "doc": "<p>This module contains the parameter creation functions for lenskit predictors/recommenders.</p>\n\n<p>Functions:</p>\n\n<pre><code>create_params_biased_mf: create BiasedMF config parameters.\ncreate_params_implicit_mf: create ImplicitMF config parameters.\ncreate_params_knn: create ItemItem/UserUser config parameters.\ncreate_params_pop_score: create PopScore config parameters.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_params.create_params_biased_mf", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_params", "qualname": "create_params_biased_mf", "type": "function", "doc": "<p>Create the parameters of the BiasedMF algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_params.create_params_implicit_mf", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_params", "qualname": "create_params_implicit_mf", "type": "function", "doc": "<p>Create the parameters of the ImplicitMF algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_params.create_params_knn", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_params", "qualname": "create_params_knn", "type": "function", "doc": "<p>Create the parameters of the k-NN algorithms.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_params.create_params_pop_score", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_params", "qualname": "create_params_pop_score", "type": "function", "doc": "<p>Create the parameters of the PopScore algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor", "type": "module", "doc": "<p>This module contains the lenskit predictor and creation functions.</p>\n\n<p>Classes:</p>\n\n<pre><code>LensKitPredictor: predictor implementation for lenskit.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_biased_mf: create BiasedMF predictor (factory creation compatible).\ncreate_implicit_mf: create ImplicitMF predictor (factory creation compatible).\ncreate_item_item: create ItemItem predictor (factory creation compatible).\ncreate_pop_score: create PopScore predictor (factory creation compatible).\ncreate_user_user: create UserUser predictor (factory creation compatible).\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.LensKitPredictor", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor", "qualname": "LensKitPredictor", "type": "class", "doc": "<p>Predictor implementation for the LensKit framework.</p>\n", "bases": "src.fairreckitlib.model.algorithms.base_predictor.Predictor"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.LensKitPredictor.__init__", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor", "qualname": "LensKitPredictor.__init__", "type": "function", "doc": "<p>Construct the lenskit predictor.</p>\n\n<p>Args:\n    algo: the lenskit prediction algorithm.\n    name: the name of the predictor.\n    params: the parameters of the predictor.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the predictor can use.</p>\n", "signature": "(\n    self,\n    algo: lenskit.algorithms.Predictor,\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.LensKitPredictor.on_train", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor", "qualname": "LensKitPredictor.on_train", "type": "function", "doc": "<p>Fit the lenskit algorithm on the train set.</p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.LensKitPredictor.on_predict", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor", "qualname": "LensKitPredictor.on_predict", "type": "function", "doc": "<p>Compute a prediction for the specified user and item.</p>\n\n<p>Lenskit predictors allow for predicting multiple items at the same time.\nTo conform with the interface only one item needs to be predicted and all\nthe extra data that it generates needs to be excluded.</p>\n\n<p>Args:\n    user: the user ID.\n    item: the item ID.</p>\n\n<p>Returns:\n    the predicted rating.</p>\n", "signature": "(self, user: int, item: int) -> float", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.LensKitPredictor.on_predict_batch", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor", "qualname": "LensKitPredictor.on_predict_batch", "type": "function", "doc": "<p>Compute the predictions for each of the specified user and item pairs.</p>\n\n<p>Lenskit predictors have a batch implementation available that allows for\npredicting ratings using multiple 'jobs'.</p>\n\n<p>Args:\n    user_item_pairs: with at least two columns: 'user', 'item'.</p>\n\n<p>Returns:\n    dataFrame with the columns: 'user', 'item', 'prediction'.</p>\n", "signature": "(\n    self,\n    user_item_pairs: pandas.core.frame.DataFrame\n) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.create_biased_mf", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor", "qualname": "create_biased_mf", "type": "function", "doc": "<p>Create the BiasedMF predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        features(int): the number of features to train.\n        iterations(int): the number of iterations to train.\n        user_reg(float): the regularization factor for users.\n        item_reg(float): the regularization factor for items.\n        damping(float): damping factor for the underlying bias.\n        method(str): the solver to use ('cd' or 'lu').\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the algorithm can use.</p>\n\n<p>Returns:\n    the LensKitPredictor wrapper of BiasedMF.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.LensKitPredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.create_implicit_mf", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor", "qualname": "create_implicit_mf", "type": "function", "doc": "<p>Create the ImplicitMF predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        features(int): the number of features to train.\n        iterations(int): the number of iterations to train.\n        reg(float): the regularization factor.\n        weight(flot): the scaling weight for positive samples.\n        use_ratings(bool): whether to use the rating column or treat\n            every rated user-item pair as having a rating of 1.\n        method(str): the training method ('cg' or 'lu').\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the algorithm can use.</p>\n\n<p>Returns:\n    the LensKitPredictor wrapper of ImplicitMF.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.LensKitPredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.create_item_item", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor", "qualname": "create_item_item", "type": "function", "doc": "<p>Create the ItemItem predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        max_neighbors(int): the maximum number of neighbors for scoring each item.\n        min_neighbors(int): the minimum number of neighbors for scoring each item.\n        min_similarity(float): minimum similarity threshold for considering a neighbor.\n        feedback(str): control how feedback should be interpreted ('explicit' or 'implicit').</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the algorithm can use.</p>\n\n<p>Returns:\n    the LensKitPredictor wrapper of ItemItem.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.LensKitPredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.create_pop_score", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor", "qualname": "create_pop_score", "type": "function", "doc": "<p>Create the PopScore predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        score_method(str): for computing popularity scores ('quantile', 'rank' or 'count').</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the algorithm can use.</p>\n\n<p>Returns:\n    the LensKitPredictor wrapper of PopScore.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.LensKitPredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.create_user_user", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor", "qualname": "create_user_user", "type": "function", "doc": "<p>Create the UserUser predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        max_neighbors(int): the maximum number of neighbors for scoring each item.\n        min_neighbors(int): the minimum number of neighbors for scoring each item.\n        min_similarity(float): minimum similarity threshold for considering a neighbor.\n        feedback(str): control how feedback should be interpreted ('explicit' or 'implicit').</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the algorithm can use.</p>\n\n<p>Returns:\n    the LensKitPredictor wrapper of UserUser.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.lenskit.lenskit_predictor.LensKitPredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender", "type": "module", "doc": "<p>This module contains the lenskit recommender and creation functions.</p>\n\n<p>Classes:</p>\n\n<pre><code>LensKitRecommender: recommender implementation for lenskit.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_candidate_selector: create CandidateSelector for a rated items filter.\ncreate_biased_mf: create BiasedMF recommender (factory creation compatible).\ncreate_implicit_mf: create ImplicitMF recommender (factory creation compatible).\ncreate_item_item: create ItemItem recommender (factory creation compatible).\ncreate_pop_score: create PopScore recommender (factory creation compatible).\ncreate_random: create Random recommender (factory creation compatible).\ncreate_user_user: create UserUser recommender (factory creation compatible).\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.LensKitRecommender", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender", "qualname": "LensKitRecommender", "type": "class", "doc": "<p>Recommender implementation for the LensKit framework.</p>\n", "bases": "src.fairreckitlib.model.algorithms.base_recommender.Recommender"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.LensKitRecommender.__init__", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender", "qualname": "LensKitRecommender.__init__", "type": "function", "doc": "<p>Construct the lenskit recommender.</p>\n\n<p>Args:\n    algo: the lenskit recommender algorithm.\n    name: the name of the recommender.\n    params: the parameters of the recommender.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the recommender can use.\n    rated_items_filter(bool): whether to filter already rated items when\n        producing item recommendations.</p>\n", "signature": "(\n    self,\n    algo: lenskit.algorithms.Recommender,\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.LensKitRecommender.on_train", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender", "qualname": "LensKitRecommender.on_train", "type": "function", "doc": "<p>Fit the lenskit algorithm on the train set.</p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.LensKitRecommender.on_recommend", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender", "qualname": "LensKitRecommender.on_recommend", "type": "function", "doc": "<p>Compute item recommendations for the specified user.</p>\n\n<p>Lenskit recommenders have an implementation that is exactly the\nsame as the required interface.</p>\n\n<p>Args:\n    user: the user ID to compute recommendations for.\n    num_items: the number of item recommendations to produce.</p>\n\n<p>Returns:\n    dataframe with the columns: 'item' and 'score'.</p>\n", "signature": "(self, user: int, num_items: int) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.LensKitRecommender.on_recommend_batch", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender", "qualname": "LensKitRecommender.on_recommend_batch", "type": "function", "doc": "<p>Compute the items recommendations for each of the specified users.</p>\n\n<p>Lenskit recommenders have a batch implementation available that allows for\nrecommending items using multiple 'jobs'.</p>\n\n<p>Args:\n    users: the user ID's to compute recommendations for.\n    num_items: the number of item recommendations to produce.</p>\n\n<p>Returns:\n    dataframe with the columns: 'rank', 'user', 'item', 'score'.</p>\n", "signature": "(self, users: List[int], num_items: int) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.create_candidate_selector", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender", "qualname": "create_candidate_selector", "type": "function", "doc": "<p>Create a candidate selector for the specified filter.</p>\n\n<p>Args:\n    rated_items_filter(bool): whether to filter already rated items when\n        producing item recommendations.</p>\n\n<p>Returns:\n    the corresponding lenskit candidate selector.</p>\n", "signature": "(rated_items_filter: bool) -> lenskit.algorithms.CandidateSelector", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.create_biased_mf", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender", "qualname": "create_biased_mf", "type": "function", "doc": "<p>Create the BiasedMF recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        features(int): the number of features to train.\n        iterations(int): the number of iterations to train.\n        user_reg(float): the regularization factor for users.\n        item_reg(float): the regularization factor for items.\n        damping(float): damping factor for the underlying bias.\n        method(str): the solver to use ('cd' or 'lu').\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the algorithm can use.\n    rated_items_filter(bool): whether to filter already rated items when\n        producing item recommendations.</p>\n\n<p>Returns:\n    the LensKitRecommender wrapper of BiasedMF.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.LensKitRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.create_implicit_mf", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender", "qualname": "create_implicit_mf", "type": "function", "doc": "<p>Create the ImplicitMF recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        features(int): the number of features to train.\n        iterations(int): the number of iterations to train.\n        reg(float): the regularization factor.\n        weight(flot): the scaling weight for positive samples.\n        use_ratings(bool): whether to use the rating column or treat\n            every rated user-item pair as having a rating of 1.\n        method(str): the training method ('cg' or 'lu').\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the algorithm can use.\n    rated_items_filter(bool): whether to filter already rated items when\n        producing item recommendations.</p>\n\n<p>Returns:\n    the LensKitRecommender wrapper of ImplicitMF.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.LensKitRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.create_item_item", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender", "qualname": "create_item_item", "type": "function", "doc": "<p>Create the ItemItem recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        max_neighbors(int): the maximum number of neighbors for scoring each item.\n        min_neighbors(int): the minimum number of neighbors for scoring each item.\n        min_similarity(float): minimum similarity threshold for considering a neighbor.\n        feedback(str): control how feedback should be interpreted ('explicit' or 'implicit').</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the algorithm can use.\n    rated_items_filter(bool): whether to filter already rated items when\n        producing item recommendations.</p>\n\n<p>Returns:\n    the LensKitRecommender wrapper of ItemItem.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.LensKitRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.create_pop_score", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender", "qualname": "create_pop_score", "type": "function", "doc": "<p>Create the PopScore recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        score_method(str): for computing popularity scores ('quantile', 'rank' or 'count').</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the algorithm can use.\n    rated_items_filter(bool): whether to filter already rated items when\n        producing item recommendations.</p>\n\n<p>Returns:\n    the LensKitRecommender wrapper of PopScore.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.LensKitRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.create_random", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender", "qualname": "create_random", "type": "function", "doc": "<p>Create the Random recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the algorithm can use.\n    rated_items_filter(bool): whether to filter already rated items when\n        producing item recommendations.</p>\n\n<p>Returns:\n    the LensKitRecommender wrapper of Random.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.LensKitRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.create_user_user", "modulename": "src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender", "qualname": "create_user_user", "type": "function", "doc": "<p>Create the UserUser recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        max_neighbors(int): the maximum number of neighbors for scoring each item.\n        min_neighbors(int): the minimum number of neighbors for scoring each item.\n        min_similarity(float): minimum similarity threshold for considering a neighbor.\n        feedback(str): control how feedback should be interpreted ('explicit' or 'implicit').</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the algorithm can use.\n    rated_items_filter(bool): whether to filter already rated items when\n        producing item recommendations.</p>\n\n<p>Returns:\n    the LensKitRecommender wrapper of UserUser.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.lenskit.lenskit_recommender.LensKitRecommender", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise", "modulename": "src.fairreckitlib.model.algorithms.surprise", "type": "module", "doc": "<p>This package contains functionality for predictors/recommenders of the Surprise package.</p>\n\n<p>Modules:</p>\n\n<pre><code>surprise_algorithms: name constants for implemented algorithms.\nsurprise_factory: create predictor/recommender factory.\nsurprise_params: create config parameters for implemented algorithms.\nsurprise_predictor: class for predictor implementation and creation functions.\nsurprise_recommender: top k predictor wrappers to be used as recommenders.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_algorithms", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_algorithms", "type": "module", "doc": "<p>This module contains name constants for implemented surprise algorithms.</p>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_factory", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_factory", "type": "module", "doc": "<p>This module contains functionality to create the surprise predictor/recommender factory.</p>\n\n<p>Functions:</p>\n\n<pre><code>create_predictor_factory: create factory with surprise predictors.\ncreate_recommender_factory: create factory with surprise recommenders.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_factory.create_predictor_factory", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_factory", "qualname": "create_predictor_factory", "type": "function", "doc": "<p>Create the factory with Surprise predictors.</p>\n\n<p>Returns:\n    the factory with all available predictors.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_factories.Factory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_factory.create_recommender_factory", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_factory", "qualname": "create_recommender_factory", "type": "function", "doc": "<p>Create the factory with Surprise recommenders.</p>\n\n<p>Returns:\n    the factory with all available recommenders.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_factories.Factory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "type": "module", "doc": "<p>This module contains the parameter creation functions for surprise predictors/recommenders.</p>\n\n<p>Functions:</p>\n\n<pre><code>add_baseline_als_params_to: add baseline config parameters that use ALS.\nadd_baseline_sgd_params_to: add baseline config parameters that use SGD.\ncreate_params_baseline_only_als: create BaselineOnly config parameters with ALS.\ncreate_params_baseline_only_sgd: create BaselineOnly config parameters with SGD.\ncreate_params_co_clustering: create CoClustering config parameters.\ncreate_params_knn: create KNN base config parameters.\ncreate_params_knn_baseline: create KNNBaseline base config parameters.\ncreate_params_knn_baseline_als: create KNNBaseline config parameters with ALS.\ncreate_params_knn_baseline_sgd: create KNNBaseline config parameters with SGD.\ncreate_params_knn_similarities: create KNN config parameters with similarities.\ncreate_params_nmf: create NMF config parameters.\ncreate_params_svd: create SVD config parameters.\ncreate_params_svd_pp: create SVDpp config parameters.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_params.add_baseline_als_params_to", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "qualname": "add_baseline_als_params_to", "type": "function", "doc": "<p>Add the parameters of the Baseline options with ALS.</p>\n\n<p>Args:\n    params: the parameters to add the baseline options to.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "(\n    params: src.fairreckitlib.core.config.config_parameters.ConfigParameters\n) -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_params.add_baseline_sgd_params_to", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "qualname": "add_baseline_sgd_params_to", "type": "function", "doc": "<p>Add the parameters of the Baseline options with SGD.</p>\n\n<p>Args:\n    params: the parameters to add the baseline options to.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "(\n    params: src.fairreckitlib.core.config.config_parameters.ConfigParameters\n) -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_params.create_params_baseline_only_als", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "qualname": "create_params_baseline_only_als", "type": "function", "doc": "<p>Create the parameters of the BaselineOnly ALS algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_params.create_params_baseline_only_sgd", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "qualname": "create_params_baseline_only_sgd", "type": "function", "doc": "<p>Create the parameters of the BaselineOnly SGD algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_params.create_params_co_clustering", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "qualname": "create_params_co_clustering", "type": "function", "doc": "<p>Create the parameters of the CoClustering algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_params.create_params_knn", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "qualname": "create_params_knn", "type": "function", "doc": "<p>Create the base parameters of all KNN algorithms.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_params.create_params_knn_baseline", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "qualname": "create_params_knn_baseline", "type": "function", "doc": "<p>Create the base parameters of both KNN Baseline algorithms.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_params.create_params_knn_baseline_als", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "qualname": "create_params_knn_baseline_als", "type": "function", "doc": "<p>Create the parameters of the KNN Baseline algorithm with ALS.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_params.create_params_knn_baseline_sgd", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "qualname": "create_params_knn_baseline_sgd", "type": "function", "doc": "<p>Create the parameters of the KNN Baseline algorithm with SGD.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_params.create_params_knn_similarities", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "qualname": "create_params_knn_similarities", "type": "function", "doc": "<p>Create the parameters of the KNN algorithm with similarities.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_params.create_params_nmf", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "qualname": "create_params_nmf", "type": "function", "doc": "<p>Create the parameters of the NMF algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_params.create_params_svd", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "qualname": "create_params_svd", "type": "function", "doc": "<p>Create the parameters of the SVD algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_params.create_params_svd_pp", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_params", "qualname": "create_params_svd_pp", "type": "function", "doc": "<p>Create the parameters of the SVDpp algorithm.</p>\n\n<p>Returns:\n    the configuration parameters of the algorithm.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_parameters.ConfigParameters", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "type": "module", "doc": "<p>This module contains the surprise predictor and creation functions.</p>\n\n<p>Classes:</p>\n\n<pre><code>SurprisePredictor: predictor implementation for surprise.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_baseline_only_als: create BaselineOnly ALS predictor (factory creation compatible).\ncreate_baseline_only_sgd: create BaselineOnly SGD predictor (factory creation compatible).\ncreate_co_clustering: create CoClustering predictor (factory creation compatible).\ncreate_knn_basic: create KNNBasic predictor (factory creation compatible).\ncreate_knn_baseline_als: create KNNBaseline ALS predictor (factory creation compatible).\ncreate_knn_baseline_sgd: create KNNBaseline SGD predictor (factory creation compatible).\ncreate_knn_with_means: create KNNWithMeans predictor (factory creation compatible).\ncreate_knn_with_zscore: create KNNWithZScore predictor (factory creation compatible).\ncreate_nmf: create NMF predictor (factory creation compatible).\ncreate_normal_predictor: create NormalPredictor predictor (factory creation compatible).\ncreate_slope_one: create SlopeOne predictor (factory creation compatible).\ncreate_svd: create SVD predictor (factory creation compatible).\ncreate_svd_pp: create SVDpp predictor (factory creation compatible).\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "SurprisePredictor", "type": "class", "doc": "<p>Predictor implementation for the Surprise package.</p>\n", "bases": "src.fairreckitlib.model.algorithms.base_predictor.Predictor"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor.__init__", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "SurprisePredictor.__init__", "type": "function", "doc": "<p>Construct the surprise predictor.</p>\n\n<p>Args:\n    algo: the surprise prediction algorithm.\n    name: the name of the predictor.\n    params: the parameters of the predictor.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads the predictor can use.\n    rating_scale(Tuple[float, float]): consisting of the min_rating and max_rating on\n        which the algorithm will perform training.</p>\n", "signature": "(\n    self,\n    algo: surprise.prediction_algorithms.algo_base.AlgoBase,\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor.on_train", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "SurprisePredictor.on_train", "type": "function", "doc": "<p>Train the algorithm on the train set.</p>\n\n<p>Surprise predictors expect the train set as a Dataset class,\nso the original train set needs to be converted before training can be done.</p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor.on_predict", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "SurprisePredictor.on_predict", "type": "function", "doc": "<p>Compute a prediction for the specified user and item.</p>\n\n<p>Surprise predictors clip the predicted ratings by default to the original rating scale\nthat is provided during training. It is turned off to conform with the expected interface.</p>\n\n<p>Args:\n    user: the user ID.\n    item: the item ID.</p>\n\n<p>Returns:\n    the predicted rating.</p>\n", "signature": "(self, user: int, item: int) -> float", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.create_baseline_only_als", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "create_baseline_only_als", "type": "function", "doc": "<p>Create the BaselineOnly ALS predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        epochs(int): The number of iteration of the ALS procedure.\n        reg_i(int): the regularization parameter for items.\n        reg_u(int): The regularization parameter for items.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of BaselineOnly with method 'als'.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.create_baseline_only_sgd", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "create_baseline_only_sgd", "type": "function", "doc": "<p>Create the BaselineOnly SGD predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        epochs(int): the number of iteration of the SGD procedure.\n        regularization(float): the regularization parameter\n            of the cost function that is optimized.\n        learning_rate(float): the learning rate of SGD.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of BaselineOnly with method 'sgd'.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.create_co_clustering", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "create_co_clustering", "type": "function", "doc": "<p>Create the CoClustering predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        epochs(int): number of iteration of the optimization loop.\n        user_clusters(int): number of user clusters.\n        item_clusters(int): number of item clusters.\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of CoClustering.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.create_knn_basic", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "create_knn_basic", "type": "function", "doc": "<p>Create the KNNBasic predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        max_k(int): the maximum number of neighbors to take into account for aggregation.\n        min_k(int): the minimum number of neighbors to take into account for aggregation.\n        user_based(bool): whether similarities will be computed between users or between\n            items, this has a huge impact on the performance.\n        min_support(int): the minimum number of common items or users, depending on the\n            user_based parameter.\n        similarity(str): the name of the similarity to use ('MSD', 'cosine' or 'pearson').</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of KNNBasic.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.create_knn_baseline_als", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "create_knn_baseline_als", "type": "function", "doc": "<p>Create the KNNBaseline ALS predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        max_k(int): the maximum number of neighbors to take into account for aggregation.\n        min_k(int): the minimum number of neighbors to take into account for aggregation.\n        user_based(bool): whether similarities will be computed between users or between\n            items, this has a huge impact on the performance.\n        min_support(int): the minimum number of common items or users, depending on the\n            user_based parameter.\n        epochs(int): The number of iteration of the ALS procedure.\n        reg_i(int): the regularization parameter for items.\n        reg_u(int): The regularization parameter for items.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of KNNBaseline with method 'als'.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.create_knn_baseline_sgd", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "create_knn_baseline_sgd", "type": "function", "doc": "<p>Create the KNNBaseline SGD predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        max_k(int): the maximum number of neighbors to take into account for aggregation.\n        min_k(int): the minimum number of neighbors to take into account for aggregation.\n        user_based(bool): whether similarities will be computed between users or between\n            items, this has a huge impact on the performance.\n        min_support(int): the minimum number of common items or users, depending on the\n            user_based parameter.\n        shrinkage(int): shrinkage parameter to apply.\n        epochs(int): the number of iteration of the SGD procedure.\n        regularization(float): the regularization parameter\n            of the cost function that is optimized.\n        learning_rate(float): the learning rate of SGD.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of KNNBaseline with method 'sgd'.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.create_knn_with_means", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "create_knn_with_means", "type": "function", "doc": "<p>Create the KNNWithMeans predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        max_k(int): the maximum number of neighbors to take into account for aggregation.\n        min_k(int): the minimum number of neighbors to take into account for aggregation.\n        user_based(bool): whether similarities will be computed between users or between\n            items, this has a huge impact on the performance.\n        min_support(int): the minimum number of common items or users, depending on the\n            user_based parameter.\n        similarity(str): the name of the similarity to use ('MSD', 'cosine' or 'pearson').</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of KNNWithMeans.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.create_knn_with_zscore", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "create_knn_with_zscore", "type": "function", "doc": "<p>Create the KNNWithZScore predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        max_k(int): the maximum number of neighbors to take into account for aggregation.\n        min_k(int): the minimum number of neighbors to take into account for aggregation.\n        user_based(bool): whether similarities will be computed between users or between\n            items, this has a huge impact on the performance.\n        min_support(int): the minimum number of common items or users, depending on the\n            user_based parameter.\n        similarity(str): the name of the similarity to use ('MSD', 'cosine' or 'pearson').</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of KNNWithZScore.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.create_nmf", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "create_nmf", "type": "function", "doc": "<p>Create the NMF predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        factors(int): the number of factors.\n        epochs(int): the number of iteration of the SGD procedure.\n        reg_pu(float): the regularization term for users.\n        reg_qi(float): the regularization term for items.\n        init_low(int): lower bound for random initialization of factors.\n        init_high(int): higher bound for random initialization of factors.\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of NMF.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.create_normal_predictor", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "create_normal_predictor", "type": "function", "doc": "<p>Create the NormalPredictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: there are no parameters for this algorithm.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of NormalPredictor.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.create_slope_one", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "create_slope_one", "type": "function", "doc": "<p>Create the SlopeOne predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: there are no parameters for this algorithm.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of SlopeOne.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.create_svd", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "create_svd", "type": "function", "doc": "<p>Create the SVD predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        factors(int): the number of factors.\n        epochs(int): the number of iteration of the SGD procedure.\n        biased(bool): whether to use baselines (or biases).\n        init_mean(int): the mean of the normal distribution for factor vectors initialization.\n        init_std_dev(float): the standard deviation of the normal distribution for\n            factor vectors initialization.\n        learning_rate(float): the learning rate for users and items.\n        regularization(float): the regularization term for users and items.\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of SVD.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor.create_svd_pp", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_predictor", "qualname": "create_svd_pp", "type": "function", "doc": "<p>Create the SVDpp predictor.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        factors(int): the number of factors.\n        epochs(int): the number of iteration of the SGD procedure.\n        init_mean(int): the mean of the normal distribution for factor vectors initialization.\n        init_std_dev(float): the standard deviation of the normal distribution for\n            factor vectors initialization.\n        learning_rate(float): the learning rate for users and items.\n        regularization(float): the regularization term for users and items.\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of SVDpp.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.surprise.surprise_predictor.SurprisePredictor", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "type": "module", "doc": "<p>This module contains the surprise top k predictor creation functions.</p>\n\n<p>Functions:</p>\n\n<pre><code>create_baseline_only_als: create BaselineOnly ALS recommender (factory creation compatible).\ncreate_baseline_only_sgd: create BaselineOnly SGD recommender (factory creation compatible).\ncreate_co_clustering: create CoClustering recommender (factory creation compatible).\ncreate_knn_basic: create KNNBasic recommender (factory creation compatible).\ncreate_knn_baseline_als: create KNNBaseline ALS recommender (factory creation compatible).\ncreate_knn_baseline_sgd: create KNNBaseline SGD recommender (factory creation compatible).\ncreate_knn_with_means: create KNNWithMeans recommender (factory creation compatible).\ncreate_knn_with_zscore: create KNNWithZScore recommender (factory creation compatible).\ncreate_nmf: create NMF recommender (factory creation compatible).\ncreate_normal_predictor: create NormalPredictor recommender (factory creation compatible).\ncreate_slope_one: create SlopeOne recommender (factory creation compatible).\ncreate_svd: create SVD recommender (factory creation compatible).\ncreate_svd_pp: create SVDpp recommender (factory creation compatible).\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender.create_baseline_only_als", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "qualname": "create_baseline_only_als", "type": "function", "doc": "<p>Create the BaselineOnly ALS recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        epochs(int): The number of iteration of the ALS procedure.\n        reg_i(int): the regularization parameter for items.\n        reg_u(int): The regularization parameter for items.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of BaselineOnly with method 'als' as a TopK recommender.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.top_k_recommender.TopK", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender.create_baseline_only_sgd", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "qualname": "create_baseline_only_sgd", "type": "function", "doc": "<p>Create the BaselineOnly SGD recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        epochs(int): the number of iteration of the SGD procedure.\n        regularization(float): the regularization parameter\n            of the cost function that is optimized.\n        learning_rate(float): the learning rate of SGD.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of BaselineOnly with method 'sgd' as a TopK recommender.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.top_k_recommender.TopK", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender.create_co_clustering", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "qualname": "create_co_clustering", "type": "function", "doc": "<p>Create the CoClustering recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        epochs(int): number of iteration of the optimization loop.\n        user_clusters(int): number of user clusters.\n        item_clusters(int): number of item clusters.\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of CoClustering as a TopK recommender.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.top_k_recommender.TopK", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender.create_knn_basic", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "qualname": "create_knn_basic", "type": "function", "doc": "<p>Create the KNNBasic recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        max_k(int): the maximum number of neighbors to take into account for aggregation.\n        min_k(int): the minimum number of neighbors to take into account for aggregation.\n        user_based(bool): whether similarities will be computed between users or between\n            items, this has a huge impact on the performance.\n        min_support(int): the minimum number of common items or users, depending on the\n            user_based parameter.\n        similarity(str): the name of the similarity to use ('MSD', 'cosine' or 'pearson').</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of KNNBasic as a TopK recommender.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.top_k_recommender.TopK", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender.create_knn_baseline_als", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "qualname": "create_knn_baseline_als", "type": "function", "doc": "<p>Create the KNNBaseline ALS recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        max_k(int): the maximum number of neighbors to take into account for aggregation.\n        min_k(int): the minimum number of neighbors to take into account for aggregation.\n        user_based(bool): whether similarities will be computed between users or between\n            items, this has a huge impact on the performance.\n        min_support(int): the minimum number of common items or users, depending on the\n            user_based parameter.\n        epochs(int): The number of iteration of the ALS procedure.\n        reg_i(int): the regularization parameter for items.\n        reg_u(int): The regularization parameter for items.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of KNNBaseline with method 'als' as a TopK recommender.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.top_k_recommender.TopK", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender.create_knn_baseline_sgd", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "qualname": "create_knn_baseline_sgd", "type": "function", "doc": "<p>Create the KNNBaseline SGD recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        max_k(int): the maximum number of neighbors to take into account for aggregation.\n        min_k(int): the minimum number of neighbors to take into account for aggregation.\n        user_based(bool): whether similarities will be computed between users or between\n            items, this has a huge impact on the performance.\n        min_support(int): the minimum number of common items or users, depending on the\n            user_based parameter.\n        shrinkage(int): shrinkage parameter to apply.\n        epochs(int): the number of iteration of the SGD procedure.\n        regularization(float): the regularization parameter\n            of the cost function that is optimized.\n        learning_rate(float): the learning rate of SGD.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of KNNBaseline with method 'sgd' as a TopK recommender.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.top_k_recommender.TopK", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender.create_knn_with_means", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "qualname": "create_knn_with_means", "type": "function", "doc": "<p>Create the KNNWithMeans recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        max_k(int): the maximum number of neighbors to take into account for aggregation.\n        min_k(int): the minimum number of neighbors to take into account for aggregation.\n        user_based(bool): whether similarities will be computed between users or between\n            items, this has a huge impact on the performance.\n        min_support(int): the minimum number of common items or users, depending on the\n            user_based parameter.\n        similarity(str): the name of the similarity to use ('MSD', 'cosine' or 'pearson').</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of KNNWithMeans as a TopK recommender.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.top_k_recommender.TopK", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender.create_knn_with_zscore", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "qualname": "create_knn_with_zscore", "type": "function", "doc": "<p>Create the KNNWithZScore recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        max_k(int): the maximum number of neighbors to take into account for aggregation.\n        min_k(int): the minimum number of neighbors to take into account for aggregation.\n        user_based(bool): whether similarities will be computed between users or between\n            items, this has a huge impact on the performance.\n        min_support(int): the minimum number of common items or users, depending on the\n            user_based parameter.\n        similarity(str): the name of the similarity to use ('MSD', 'cosine' or 'pearson').</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of KNNWithZScore as a TopK recommender.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.top_k_recommender.TopK", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender.create_nmf", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "qualname": "create_nmf", "type": "function", "doc": "<p>Create the NMF recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        factors(int): the number of factors.\n        epochs(int): the number of iteration of the SGD procedure.\n        reg_pu(float): the regularization term for users.\n        reg_qi(float): the regularization term for items.\n        init_low(int): lower bound for random initialization of factors.\n        init_high(int): higher bound for random initialization of factors.\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of NMF as a TopK recommender.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.top_k_recommender.TopK", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender.create_normal_predictor", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "qualname": "create_normal_predictor", "type": "function", "doc": "<p>Create the NormalPredictor recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: there are no parameters for this algorithm.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of NormalPredictor as a TopK recommender.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.top_k_recommender.TopK", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender.create_slope_one", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "qualname": "create_slope_one", "type": "function", "doc": "<p>Create the SlopeOne recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: there are no parameters for this algorithm.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of SlopeOne as a TopK recommender.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.top_k_recommender.TopK", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender.create_svd", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "qualname": "create_svd", "type": "function", "doc": "<p>Create the SVD recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        factors(int): the number of factors.\n        epochs(int): the number of iteration of the SGD procedure.\n        biased(bool): whether to use baselines (or biases).\n        init_mean(int): the mean of the normal distribution for factor vectors initialization.\n        init_std_dev(float): the standard deviation of the normal distribution for\n            factor vectors initialization.\n        learning_rate(float): the learning rate for users and items.\n        regularization(float): the regularization term for users and items.\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of SVD as a TopK recommender.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.top_k_recommender.TopK", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender.create_svd_pp", "modulename": "src.fairreckitlib.model.algorithms.surprise.surprise_recommender", "qualname": "create_svd_pp", "type": "function", "doc": "<p>Create the SVDpp recommender.</p>\n\n<p>Args:\n    name: the name of the algorithm.\n    params: containing the following name-value pairs:\n        factors(int): the number of factors.\n        epochs(int): the number of iteration of the SGD procedure.\n        init_mean(int): the mean of the normal distribution for factor vectors initialization.\n        init_std_dev(float): the standard deviation of the normal distribution for\n            factor vectors initialization.\n        learning_rate(float): the learning rate for users and items.\n        regularization(float): the regularization term for users and items.\n        random_seed(int): the random seed or None for the current time as seed.</p>\n\n<p>Returns:\n    the SurprisePredictor wrapper of SVDpp as a TopK recommender.</p>\n", "signature": "(\n    name: str,\n    params: Dict[str, Any],\n    **kwargs\n) -> src.fairreckitlib.model.algorithms.top_k_recommender.TopK", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.top_k_recommender", "modulename": "src.fairreckitlib.model.algorithms.top_k_recommender", "type": "module", "doc": "<p>This module contains a recommender that utilizes a predictor to produce item recommendations.</p>\n\n<p>Classes:</p>\n\n<pre><code>TopK: wrap a predictor to be used as a recommender.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.algorithms.top_k_recommender.TopK", "modulename": "src.fairreckitlib.model.algorithms.top_k_recommender", "qualname": "TopK", "type": "class", "doc": "<p>Recommender that implements top K recommendations using a predictor.</p>\n", "bases": "src.fairreckitlib.model.algorithms.base_recommender.BaseRecommender"}, {"fullname": "src.fairreckitlib.model.algorithms.top_k_recommender.TopK.__init__", "modulename": "src.fairreckitlib.model.algorithms.top_k_recommender", "qualname": "TopK.__init__", "type": "function", "doc": "<p>Construct the TopK recommender.</p>\n\n<p>Args:\n    predictor: the underlying predictor to use for recommendations.\n    rated_items_filter: whether to filter already rated items when\n        producing item recommendations.</p>\n", "signature": "(\n    self,\n    predictor: src.fairreckitlib.model.algorithms.base_predictor.BasePredictor,\n    rated_items_filter: bool\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.top_k_recommender.TopK.get_name", "modulename": "src.fairreckitlib.model.algorithms.top_k_recommender", "qualname": "TopK.get_name", "type": "function", "doc": "<p>Get the name of the underlying predictor.</p>\n\n<p>Returns:\n    the name of the underlying predictor.</p>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.top_k_recommender.TopK.get_num_threads", "modulename": "src.fairreckitlib.model.algorithms.top_k_recommender", "qualname": "TopK.get_num_threads", "type": "function", "doc": "<p>Get the max number of threads the underlying predictor can use.</p>\n\n<p>Returns:\n    the number of threads.</p>\n", "signature": "(self) -> int", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.top_k_recommender.TopK.get_params", "modulename": "src.fairreckitlib.model.algorithms.top_k_recommender", "qualname": "TopK.get_params", "type": "function", "doc": "<p>Get the parameters of the underlying predictor.</p>\n\n<p>Returns:\n    the parameters of the underlying predictor.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.top_k_recommender.TopK.get_items", "modulename": "src.fairreckitlib.model.algorithms.top_k_recommender", "qualname": "TopK.get_items", "type": "function", "doc": "<p>Get the (unique) items the underlying predictor was trained on.</p>\n\n<p>Returns:\n    a list of unique item IDs or None if the algorithm is not trained yet.</p>\n", "signature": "(self) -> Optional[List[int]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.top_k_recommender.TopK.get_users", "modulename": "src.fairreckitlib.model.algorithms.top_k_recommender", "qualname": "TopK.get_users", "type": "function", "doc": "<p>Get the (unique) users the underlying predictor was trained on.</p>\n\n<p>Returns:\n    a list of unique user IDs or None if the algorithm is not trained yet.</p>\n", "signature": "(self) -> Optional[List[int]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.top_k_recommender.TopK.on_train", "modulename": "src.fairreckitlib.model.algorithms.top_k_recommender", "qualname": "TopK.on_train", "type": "function", "doc": "<p>Train the underlying predictor on the train set.</p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.algorithms.top_k_recommender.TopK.on_recommend", "modulename": "src.fairreckitlib.model.algorithms.top_k_recommender", "qualname": "TopK.on_recommend", "type": "function", "doc": "<p>Compute item recommendations using the underlying predictor.</p>\n\n<p>Go through all user-item combinations for the specified user and\npredict a score. Sort in descending order and return the topK items.</p>\n\n<p>Args:\n    user: the user ID to compute recommendations for.\n    num_items: the number of item recommendations to produce.</p>\n\n<p>Returns:\n    dataframe with the columns: 'item' and 'score'.</p>\n", "signature": "(self, user: int, num_items: int) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.model_factory", "modulename": "src.fairreckitlib.model.model_factory", "type": "module", "doc": "<p>This module contains functionality to create a model factory.</p>\n\n<p>Constants:</p>\n\n<pre><code>KEY_MODELS: key that is used to identify models.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>create_algorithm_pipeline_factory: wrap algorithm factory with pipeline creation.\ncreate_model_factory: create factory with prediction/recommendation factories.\ncreate_prediction_model_factory: create factory with predictor API factories.\ncreate_recommendation_model_factory: create factory with recommender API factories.\n</code></pre>\n\n<p>Deprecated:</p>\n\n<p>from .algorithms.elliot import elliot_factory\nfrom .pipeline.recommendation_pipeline_elliot import RecommendationPipelineElliot</p>\n\n<p>def create_recommendation_model_factory() -> GroupFactory:\n    ...\n    # elliot recommenders\n    model_factory.add_factory(create_algorithm_pipeline_factory(\n        elliot_factory.create_recommender_factory(),\n        RecommendationPipelineElliot\n    ))\n    ...</p>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.model_factory.create_algorithm_pipeline_factory", "modulename": "src.fairreckitlib.model.model_factory", "qualname": "create_algorithm_pipeline_factory", "type": "function", "doc": "<p>Create an algorithm pipeline factory.</p>\n\n<p>Args:\n    algo_factory: the factory with available algorithms.\n    create_pipeline: the pipeline creation function associated with the factory.</p>\n\n<p>Returns\n    the algorithm pipeline factory.</p>\n", "signature": "(\n    algo_factory: src.fairreckitlib.core.config.config_factories.Factory,\n    create_pipeline: Callable[[src.fairreckitlib.core.config.config_factories.Factory, src.fairreckitlib.core.events.event_dispatcher.EventDispatcher], src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline]\n) -> src.fairreckitlib.core.config.config_factories.Factory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.model_factory.create_model_factory", "modulename": "src.fairreckitlib.model.model_factory", "qualname": "create_model_factory", "type": "function", "doc": "<p>Create a model factory with all predictor and recommender algorithms.</p>\n\n<p>Returns:\n    the group factory with all predictors and recommenders.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_factories.GroupFactory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.model_factory.create_prediction_model_factory", "modulename": "src.fairreckitlib.model.model_factory", "qualname": "create_prediction_model_factory", "type": "function", "doc": "<p>Create a model factory with all predictor algorithms.</p>\n\n<p>Consists of algorithms from two APIs:\n    1) LensKit predictor algorithms.\n    2) Surprise predictor algorithms.</p>\n\n<p>Returns:\n    the group factory with all predictors.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_factories.GroupFactory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.model_factory.create_recommendation_model_factory", "modulename": "src.fairreckitlib.model.model_factory", "qualname": "create_recommendation_model_factory", "type": "function", "doc": "<p>Create a model factory with all recommender algorithms.</p>\n\n<p>Consists of algorithms from four APIs:\n    1) LensKit recommender algorithms.\n    2) Implicit recommender algorithms.\n    3) Surprise recommender algorithms.</p>\n\n<p>Returns:\n    the group factory with all recommenders.</p>\n", "signature": "() -> src.fairreckitlib.core.config.config_factories.GroupFactory", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline", "modulename": "src.fairreckitlib.model.pipeline", "type": "module", "doc": "<p>This package contains functionality for running the model pipeline.</p>\n\n<p>Modules:</p>\n\n<pre><code>model_config: model configuration class.\nmodel_config_parsing: parse model configuration(s).\nmodel_event: event ids, event args and a print switch for the model pipeline.\nmodel_pipeline: base model pipeline class.\nmodel_run: run (multiple) model pipelines.\nprediction_pipeline: model pipeline class for predictions.\nrecommendation_pipeline: model pipeline class for recommendations.\nrecommendation_pipeline_elliot: recommender pipeline class for the elliot framework.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.pipeline.model_config", "modulename": "src.fairreckitlib.model.pipeline.model_config", "type": "module", "doc": "<p>This module contains the model configuration.</p>\n\n<p>Classes:</p>\n\n<pre><code>ModelConfig: model configuration.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>api_models_to_yml_format: format model configurations from different APIs to be yml compatible.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.pipeline.model_config.ModelConfig", "modulename": "src.fairreckitlib.model.pipeline.model_config", "qualname": "ModelConfig", "type": "class", "doc": "<p>Model Configuration.</p>\n\n<p>name: the name of the model.\nparams: the parameters of the model.</p>\n", "bases": "src.fairreckitlib.core.config.config_object.ObjectConfig"}, {"fullname": "src.fairreckitlib.model.pipeline.model_config.ModelConfig.__init__", "modulename": "src.fairreckitlib.model.pipeline.model_config", "qualname": "ModelConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, name: str, params: Dict[str, Any])", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_config.api_models_to_yml_format", "modulename": "src.fairreckitlib.model.pipeline.model_config", "qualname": "api_models_to_yml_format", "type": "function", "doc": "<p>Format API models configuration list to a yml compatible dictionary.</p>\n\n<p>Returns:\n    a dictionary containing the lists of model configurations.</p>\n", "signature": "(\n    api_models: Dict[str, List[src.fairreckitlib.model.pipeline.model_config.ModelConfig]]\n) -> Dict[str, List[Dict[str, Any]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_config_parsing", "modulename": "src.fairreckitlib.model.pipeline.model_config_parsing", "type": "module", "doc": "<p>This module contains a parser for the model configuration(s).</p>\n\n<p>Functions:</p>\n\n<pre><code>parse_models_config: parse model configurations for multiple APIs.\nparse_api_models: parse a list of model configurations for one API.\nparse_model: parse model configuration.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.pipeline.model_config_parsing.parse_models_config", "modulename": "src.fairreckitlib.model.pipeline.model_config_parsing", "qualname": "parse_models_config", "type": "function", "doc": "<p>Parse all model configurations.</p>\n\n<p>Args:\n    experiment_config: the experiment's total configuration.\n    model_factory: the model factory containing the available models.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    a dictionary of parsed ModelConfig's keyed by API name or None when empty.</p>\n", "signature": "(\n    experiment_config: Dict[str, Any],\n    model_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> Optional[Dict[str, List[src.fairreckitlib.model.pipeline.model_config.ModelConfig]]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_config_parsing.parse_api_models", "modulename": "src.fairreckitlib.model.pipeline.model_config_parsing", "qualname": "parse_api_models", "type": "function", "doc": "<p>Parse the model configurations for the specified API name.</p>\n\n<p>Args:\n    api_name: name of the API that will be parsed.\n    model_configs: list of model configurations.\n    model_factory: the model factory containing the available models for each API.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    a list of parsed ModelConfig's.</p>\n", "signature": "(\n    api_name: str,\n    model_configs: List[Dict[str, Any]],\n    model_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> List[src.fairreckitlib.model.pipeline.model_config.ModelConfig]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_config_parsing.parse_model", "modulename": "src.fairreckitlib.model.pipeline.model_config_parsing", "qualname": "parse_model", "type": "function", "doc": "<p>Parse a single model configuration.</p>\n\n<p>Args:\n    model_config: dictionary with the model's configuration.\n    algo_factory: the algorithm factory related to the model config.\n    event_dispatcher: to dispatch the parse event on failure.</p>\n\n<p>Returns:\n    the parsed configuration and model name or None on failure.</p>\n", "signature": "(\n    model_config: Dict[str, Any],\n    algo_factory: src.fairreckitlib.core.config.config_factories.Factory,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n) -> Union[Tuple[src.fairreckitlib.model.pipeline.model_config.ModelConfig, str], Tuple[NoneType, NoneType]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_event", "modulename": "src.fairreckitlib.model.pipeline.model_event", "type": "module", "doc": "<p>This module contains all event ids, event args and a print switch for the model pipeline.</p>\n\n<p>Constants:</p>\n\n<pre><code>ON_BEGIN_LOAD_TEST_SET: id of the event that is used when a test set is being loaded.\nON_BEGIN_LOAD_TRAIN_SET: id of the event that is used when a train set is being loaded.\nON_BEGIN_MODEL_PIPELINE: id of the event that is used when the model pipeline starts.\nON_BEGIN_TEST_MODEL: id of the event that is used when testing a model started.\nON_BEGIN_TRAIN_MODEL: id of the event that is used when training a model started.\nON_BEGIN_MODEL: id of the event that is used when a model computation started.\nON_END_LOAD_TEST_SET: id of the event that is used when a test set has been loaded.\nON_END_LOAD_TRAIN_SET: id of the event that is used when a train set has been loaded.\nON_END_MODEL_PIPELINE: id of the event that is used when the model pipeline ends.\nON_END_TEST_MODEL: id of the event that is used when testing a model finishes.\nON_END_TRAIN_MODEL: id of the event that is used when training a model finishes.\nON_END_MODEL: id of the event that is used when a model computation finishes.\n</code></pre>\n\n<p>Classes:</p>\n\n<pre><code>ModelPipelineEventArgs: event args related to the model pipeline.\nModelEventArgs: event args related to a model.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>get_model_events: list of model pipeline event IDs.\nget_model_event_print_switch: switch to print model pipeline event arguments by ID.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.pipeline.model_event.ModelPipelineEventArgs", "modulename": "src.fairreckitlib.model.pipeline.model_event", "qualname": "ModelPipelineEventArgs", "type": "class", "doc": "<p>Model Pipeline Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the model pipeline event.\napi_name: the name of the api that is used in the model pipeline.\nmodels_config: list of model configurations that is used in the model pipeline.</p>\n", "bases": "src.fairreckitlib.core.events.event_args.EventArgs"}, {"fullname": "src.fairreckitlib.model.pipeline.model_event.ModelPipelineEventArgs.__init__", "modulename": "src.fairreckitlib.model.pipeline.model_event", "qualname": "ModelPipelineEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    event_id: str,\n    api_name: str,\n    models_config: List[src.fairreckitlib.model.pipeline.model_config.ModelConfig]\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_event.ModelEventArgs", "modulename": "src.fairreckitlib.model.pipeline.model_event", "qualname": "ModelEventArgs", "type": "class", "doc": "<p>Model Event Arguments.</p>\n\n<p>event_id: the unique ID that classifies the model event.\nmodel_name: the name of the model.\nmodel_params: the parameters of the model.</p>\n", "bases": "src.fairreckitlib.core.events.event_args.EventArgs"}, {"fullname": "src.fairreckitlib.model.pipeline.model_event.ModelEventArgs.__init__", "modulename": "src.fairreckitlib.model.pipeline.model_event", "qualname": "ModelEventArgs.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, event_id: str, model_name: str, model_params: Dict[str, Any])", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_event.get_model_events", "modulename": "src.fairreckitlib.model.pipeline.model_event", "qualname": "get_model_events", "type": "function", "doc": "<p>Get a list of model pipeline event IDs.</p>\n\n<p>Returns:\n    a list of unique model pipeline event IDs.</p>\n", "signature": "() -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_event.get_model_event_print_switch", "modulename": "src.fairreckitlib.model.pipeline.model_event", "qualname": "get_model_event_print_switch", "type": "function", "doc": "<p>Get a switch that prints model pipeline event IDs.</p>\n\n<p>Returns:\n    the print model pipeline event switch.</p>\n", "signature": "(\n    elapsed_time: float = None\n) -> Dict[str, Callable[[src.fairreckitlib.core.events.event_args.EventArgs], NoneType]]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "type": "module", "doc": "<p>This module contains base functionality of the complete model pipeline.</p>\n\n<p>Classes:</p>\n\n<pre><code>ModelPipeline: class that batches multiple model computations for a specific API.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>write_computed_ratings: append computed ratings to a result file.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline", "type": "class", "doc": "<p>Model Pipeline to run computations for algorithms from a specific API.</p>\n\n<p>Wraps the common functionality that applies to all models disregarding the type.\nLoading the train and test is only done once each time the pipeline is run.\nAfter the previously mentioned sets are done loading, the pipeline loops\nthrough all specified models and executes the following steps:</p>\n\n<p>1) create the output directory.\n2) create the model.\n3) save the model's creation settings.\n4) train the model using the train set.\n5) test the model using the test set.\n6) add original ratings to the result.</p>\n\n<p>Abstract methods:</p>\n\n<p>get_ratings_dataframe\ntest_model_ratings</p>\n\n<p>Public methods:</p>\n\n<p>run</p>\n", "bases": "src.fairreckitlib.core.pipeline.core_pipeline.CorePipeline"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.__init__", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.__init__", "type": "function", "doc": "<p>Construct the model pipeline.</p>\n\n<p>Args:\n    algo_factory: factory of available algorithms for this API.\n    event_dispatcher: used to dispatch model/IO events when running the pipeline.</p>\n", "signature": "(\n    self,\n    algo_factory: src.fairreckitlib.core.config.config_factories.Factory,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.run", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.run", "type": "function", "doc": "<p>Run the entire pipeline from beginning to end.</p>\n\n<p>Effectively running all computations of the specified models.\nThe pipeline raises a FileNotFoundError when it fails to load\nthe train and/or test set.</p>\n\n<p>Args:\n    output_dir: the path of the directory to store the output.\n    data_transition: data input.\n    models_config: list of ModelConfig objects.\n    is_running: function that returns whether the pipeline\n        is still running. Stops early when False is returned.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads an algorithm can use.\n    num_items(int): the number of item recommendations to produce, only\n        needed when running the pipeline for recommender algorithms.\n    rated_items_filter(bool): whether to filter already rated items when\n        producing item recommendations.</p>\n\n<p>Returns:\n    a list of model directories where computation results are stored.</p>\n", "signature": "(\n    self,\n    output_dir: str,\n    data_transition: src.fairreckitlib.data.data_transition.DataTransition,\n    models_config: List[src.fairreckitlib.model.pipeline.model_config.ModelConfig],\n    is_running: Callable[[], bool],\n    **kwargs\n) -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.run_model", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.run_model", "type": "function", "doc": "<p>Run the model computation for the specified model configuration.</p>\n\n<p>Several possible errors can be raised during the model computation run:\nArithmeticError, MemoryError and RuntimeError.</p>\n\n<p>Args:\n    output_dir: the path of the directory to store the output.\n    data_transition: data input.\n    model_config: the algorithm model configuration.\n    is_running: function that returns whether the pipeline\n        is still running. Stops early when False is returned.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads an algorithm can use.\n    num_items(int): the number of item recommendations to produce, only\n        needed when running the pipeline for recommender algorithms.\n    rated_items_filter(bool): whether to filter already rated items when\n        producing item recommendations.</p>\n\n<p>Returns:\n    the directory where the model's computed ratings are stored.</p>\n", "signature": "(\n    self,\n    output_dir: str,\n    data_transition: src.fairreckitlib.data.data_transition.DataTransition,\n    model_config: src.fairreckitlib.model.pipeline.model_config.ModelConfig,\n    is_running: Callable[[], bool],\n    **kwargs\n) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.begin_model", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.begin_model", "type": "function", "doc": "<p>Prepare the model computation.</p>\n\n<p>Resolves the output directory to create for the model computation,\nso that it is unique and creates the model. It raises a RuntimeError\nwhen the model's algorithm fails to create.</p>\n\n<p>Args:\n    model_name: name of the model's algorithm.\n    model_params: parameters of the algorithm.\n    output_dir: the path of the directory to store the output.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads an algorithm can use.\n    rated_items_filter(bool): whether to filter already rated items when\n        producing item recommendations.</p>\n\n<p>Returns:\n    model_dir: the path of the directory where the computed ratings can be stored.\n    model: the created model according the specified name and parameters.\n    start: the time when the model computation started.</p>\n", "signature": "(\n    self,\n    model_name: str,\n    model_params: Dict[str, Any],\n    output_dir: str,\n    **kwargs\n) -> Tuple[str, src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm, float]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.create_model_output_dir", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.create_model_output_dir", "type": "function", "doc": "<p>Create the output directory for a model.</p>\n\n<p>Args:\n    output_dir: the path of the directory to store the output.\n    model_name: name of the model's algorithm.</p>\n\n<p>Returns:\n    the path of the directory where the model's computed ratings can be stored.</p>\n", "signature": "(self, output_dir: str, model_name: str) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.end_model", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.end_model", "type": "function", "doc": "<p>Finalize the model computation.</p>\n\n<p>Updates the number of tested models so that additional\ncomputations remain unique for this model.</p>\n\n<p>Args:\n    model: the model that finished.\n    start: the time when the model computation started.</p>\n", "signature": "(\n    self,\n    model: src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm,\n    start: float\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.get_ratings_dataframe", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.get_ratings_dataframe", "type": "function", "doc": "<p>Get the dataframe that contains the original ratings.</p>\n\n<p>Returns:\n    dataframe containing the 'user', 'item', 'rating', columns.</p>\n", "signature": "(self) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.load_test_set", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.load_test_set", "type": "function", "doc": "<p>Load the test set that all models can use for testing.</p>\n\n<p>Args:\n    test_set_path: path to where the test set is stored.</p>\n", "signature": "(self, test_set_path: str) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.load_train_set", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.load_train_set", "type": "function", "doc": "<p>Load the train set that all models can use for training.</p>\n\n<p>Args:\n    train_set_path: path to where the train set is stored.</p>\n", "signature": "(self, train_set_path: str) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.load_train_and_test_set", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.load_train_and_test_set", "type": "function", "doc": "<p>Load the train and test set that all models can use.</p>\n\n<p>Args:\n    train_set_path: path to where the train set is stored.\n    test_set_path: path to where the test set is stored.</p>\n", "signature": "(self, train_set_path: str, test_set_path: str) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.reconstruct_ratings", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.reconstruct_ratings", "type": "function", "doc": "<p>Reconstruct the original ratings in the specified result file.</p>\n\n<p>Args:\n    result_file_path: path to the file that needs the ratings to be added.</p>\n", "signature": "(self, result_file_path: str) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.test_model", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.test_model", "type": "function", "doc": "<p>Test the specified model using the test set.</p>\n\n<p>This function wraps the event dispatching and functionality\nthat both predictor and recommender models have in common.</p>\n\n<p>Args:\n    model: the model that needs to be tested.\n    model_dir: the path of the directory where the computed ratings can be stored.</p>\n\n<p>Keyword Args:\n    num_items(int): the number of item recommendations to produce, only\n        needed when running the pipeline for recommender algorithms.</p>\n\n<p>Returns:\n    the path to the file where the model's computed ratings are stored.</p>\n", "signature": "(\n    self,\n    model: src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm,\n    model_dir: str,\n    is_running: Callable[[], bool],\n    **kwargs\n) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.test_model_ratings", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.test_model_ratings", "type": "function", "doc": "<p>Test the specified model for rating predictions or recommendations.</p>\n\n<p>Args:\n    model: the model that needs to be tested.\n    output_path: path to the file where the ratings will be stored.\n    batch_size: number of users to test ratings for in a batch.\n    is_running: function that returns whether the pipeline\n        is still running. Stops early when False is returned.</p>\n\n<p>Keyword Args:\n    num_items(int): the number of item recommendations to produce, only\n        needed when running the pipeline for recommender algorithms.</p>\n", "signature": "(\n    self,\n    model: src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm,\n    output_path: str,\n    batch_size: int,\n    is_running: Callable[[], bool],\n    **kwargs\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.train_model", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.train_model", "type": "function", "doc": "<p>Train the specified model using the train set.</p>\n\n<p>Args:\n    model: the model that needs to be trained.</p>\n", "signature": "(\n    self,\n    model: src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline.train_and_test_model", "modulename": "src.fairreckitlib.model.pipeline.model_pipeline", "qualname": "ModelPipeline.train_and_test_model", "type": "function", "doc": "<p>Train and test the specified model.</p>\n\n<p>Several possible errors can be raised during the executing of both training and\ntesting the model: namely ArithmeticError, MemoryError and RuntimeError.</p>\n\n<p>Args:\n    model: the model that needs to be trained.\n    model_dir: the path of the directory where the computed ratings can be stored.\n    is_running: function that returns whether the pipeline\n        is still running. Stops early when False is returned.</p>\n\n<p>Keyword Args:\n    num_items(int): the number of item recommendations to produce, only\n        needed when running the pipeline for recommender algorithms.</p>\n\n<p>Returns:\n    the path to the file where the model's computed ratings are stored.</p>\n", "signature": "(\n    self,\n    model: src.fairreckitlib.model.algorithms.base_algorithm.BaseAlgorithm,\n    model_dir: str,\n    is_running: Callable[[], bool],\n    **kwargs\n) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_run", "modulename": "src.fairreckitlib.model.pipeline.model_run", "type": "module", "doc": "<p>This module contains functionality that wraps running the model pipeline multiple times.</p>\n\n<p>Classes:</p>\n\n<pre><code>ModelPipelineConfig: configuration class to run the model pipelines.\n</code></pre>\n\n<p>Functions:</p>\n\n<pre><code>run_model_pipelines: run (multiple) pipelines for specified model configurations.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.pipeline.model_run.ModelPipelineConfig", "modulename": "src.fairreckitlib.model.pipeline.model_run", "qualname": "ModelPipelineConfig", "type": "class", "doc": "<p>Model Pipeline Configuration.</p>\n\n<p>output_dir: the directory to store the output.\ndata_transition: data input.\nmodel_factory: the factory with available algorithm factories.\nmodels: dictionary with api model configurations to compute.</p>\n"}, {"fullname": "src.fairreckitlib.model.pipeline.model_run.ModelPipelineConfig.__init__", "modulename": "src.fairreckitlib.model.pipeline.model_run", "qualname": "ModelPipelineConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    output_dir: str,\n    data_transition: src.fairreckitlib.data.data_transition.DataTransition,\n    model_factory: src.fairreckitlib.core.config.config_factories.GroupFactory,\n    models: Dict[str, List[src.fairreckitlib.model.pipeline.model_config.ModelConfig]]\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.model_run.run_model_pipelines", "modulename": "src.fairreckitlib.model.pipeline.model_run", "qualname": "run_model_pipelines", "type": "function", "doc": "<p>Run several model pipelines according to the specified model pipeline configuration.</p>\n\n<p>Args:\n    pipeline_config: the configuration on how to run the model pipelines.\n    event_dispatcher: used to dispatch model/IO events when running the model pipelines.\n    is_running: function that returns whether the pipelines\n        are still running. Stops early when False is returned.</p>\n\n<p>Keyword Args:\n    num_threads(int): the max number of threads a model can use.\n    num_items(int): the number of item recommendations to produce, only\n        needed when running recommender pipelines.\n    rated_items_filter(bool): whether to filter already rated items when\n        producing item recommendations.</p>\n\n<p>Returns:\n    list of directories where the computed model ratings are stored.</p>\n", "signature": "(\n    pipeline_config: src.fairreckitlib.model.pipeline.model_run.ModelPipelineConfig,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher,\n    is_running: Callable[[], bool],\n    **kwargs\n) -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.prediction_pipeline", "modulename": "src.fairreckitlib.model.pipeline.prediction_pipeline", "type": "module", "doc": "<p>This module contains a model pipeline that predicts known item ratings.</p>\n\n<p>Classes:</p>\n\n<pre><code>PredictionPipeline: can batch predictions from multiple models for a specific API.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.pipeline.prediction_pipeline.PredictionPipeline", "modulename": "src.fairreckitlib.model.pipeline.prediction_pipeline", "qualname": "PredictionPipeline", "type": "class", "doc": "<p>Prediction Pipeline that computes user/item rating predictions.</p>\n\n<p>The (user,item) prediction will be computed and for each pair that is present in the test set.</p>\n", "bases": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline"}, {"fullname": "src.fairreckitlib.model.pipeline.prediction_pipeline.PredictionPipeline.get_ratings_dataframe", "modulename": "src.fairreckitlib.model.pipeline.prediction_pipeline", "qualname": "PredictionPipeline.get_ratings_dataframe", "type": "function", "doc": "<p>Get the dataframe that contains the original ratings.</p>\n\n<p>For the prediction pipeline only the ratings from the test set are necessary.</p>\n\n<p>Returns:\n    dataframe containing the 'user', 'item', 'rating', columns.</p>\n", "signature": "(self) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.prediction_pipeline.PredictionPipeline.test_model_ratings", "modulename": "src.fairreckitlib.model.pipeline.prediction_pipeline", "qualname": "PredictionPipeline.test_model_ratings", "type": "function", "doc": "<p>Test the specified model for rating predictions.</p>\n\n<p>Predict ratings for each user-item pair that is present in the test set.</p>\n\n<p>Args:\n    model: the model that needs to be tested.\n    output_path: path to the file where the ratings will be stored.\n    batch_size: number of users to test ratings for in a batch.\n    is_running: function that returns whether the pipeline\n        is still running. Stops early when False is returned.</p>\n", "signature": "(\n    self,\n    model: src.fairreckitlib.model.algorithms.base_predictor.BasePredictor,\n    output_path: str,\n    batch_size: int,\n    is_running: Callable[[], bool],\n    **kwargs\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.recommendation_pipeline", "modulename": "src.fairreckitlib.model.pipeline.recommendation_pipeline", "type": "module", "doc": "<p>This module contains a model pipeline that recommends items based on rating predictions.</p>\n\n<p>Classes:</p>\n\n<pre><code>RecommendationPipeline: can batch recommendations from multiple models for a specific API.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.pipeline.recommendation_pipeline.RecommendationPipeline", "modulename": "src.fairreckitlib.model.pipeline.recommendation_pipeline", "qualname": "RecommendationPipeline", "type": "class", "doc": "<p>Recommendation Pipeline that computes item recommendations.</p>\n\n<p>The topK item recommendations will be computed for each user that is present in the test set.</p>\n", "bases": "src.fairreckitlib.model.pipeline.model_pipeline.ModelPipeline"}, {"fullname": "src.fairreckitlib.model.pipeline.recommendation_pipeline.RecommendationPipeline.get_ratings_dataframe", "modulename": "src.fairreckitlib.model.pipeline.recommendation_pipeline", "qualname": "RecommendationPipeline.get_ratings_dataframe", "type": "function", "doc": "<p>Get the dataframe that contains the original ratings.</p>\n\n<p>For the recommendation pipeline the ratings is the combination of the train and test set.</p>\n\n<p>Returns:\n    dataframe containing the 'user', 'item', 'rating', columns.</p>\n", "signature": "(self) -> pandas.core.frame.DataFrame", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.recommendation_pipeline.RecommendationPipeline.test_model_ratings", "modulename": "src.fairreckitlib.model.pipeline.recommendation_pipeline", "qualname": "RecommendationPipeline.test_model_ratings", "type": "function", "doc": "<p>Test the specified model for rating recommendations.</p>\n\n<p>Produce a top K number of item scores for each user that is present in the test set.</p>\n\n<p>Args:\n    model: the model that needs to be tested.\n    output_path: path to the file where the ratings will be stored.\n    batch_size: number of users to test ratings for in a batch.\n    is_running: function that returns whether the pipeline\n        is still running. Stops early when False is returned.</p>\n\n<p>Keyword Args:\n    num_items(int): the number of item recommendations to produce.</p>\n", "signature": "(\n    self,\n    model: src.fairreckitlib.model.algorithms.base_recommender.BaseRecommender,\n    output_path: str,\n    batch_size: int,\n    is_running: Callable[[], bool],\n    **kwargs\n) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.recommendation_pipeline_elliot", "modulename": "src.fairreckitlib.model.pipeline.recommendation_pipeline_elliot", "type": "module", "doc": "<p>This module contains a model pipeline that recommends items using the Elliot framework.</p>\n\n<p>Classes:</p>\n\n<pre><code>RecommendationPipelineElliot: can batch recommendations from multiple elliot models.\n</code></pre>\n\n<p>Deprecated:</p>\n\n<p>from elliot.run import run_experiment</p>\n\n<p>class RecommendationPipelineElliot(RecommendationPipeline):\n    ...\n    def train_and_test_model(\n            self,\n            model: ElliotRecommender,\n            model_dir: str,\n            is_running: Callable[[], bool],\n            **kwargs) -> str:\n        ...\n        create_yml(yml_path, data, self.event_dispatcher)</p>\n\n<pre><code>    run_experiment(yml_path)\n\n    delete_dir(temp_dir, self.event_dispatcher)\n    ...\n...\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.model.pipeline.recommendation_pipeline_elliot.RecommendationPipelineElliot", "modulename": "src.fairreckitlib.model.pipeline.recommendation_pipeline_elliot", "qualname": "RecommendationPipelineElliot", "type": "class", "doc": "<p>Recommendation Pipeline implementation for the Elliot framework.</p>\n", "bases": "src.fairreckitlib.model.pipeline.recommendation_pipeline.RecommendationPipeline"}, {"fullname": "src.fairreckitlib.model.pipeline.recommendation_pipeline_elliot.RecommendationPipelineElliot.__init__", "modulename": "src.fairreckitlib.model.pipeline.recommendation_pipeline_elliot", "qualname": "RecommendationPipelineElliot.__init__", "type": "function", "doc": "<p>Construct the elliot recommendation pipeline.</p>\n\n<p>Args:\n    factory: factory of available elliot recommenders.\n    event_dispatcher: used to dispatch model/IO events when running the pipeline.</p>\n", "signature": "(\n    self,\n    factory: src.fairreckitlib.core.config.config_factories.Factory,\n    event_dispatcher: src.fairreckitlib.core.events.event_dispatcher.EventDispatcher\n)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.recommendation_pipeline_elliot.RecommendationPipelineElliot.load_train_and_test_set", "modulename": "src.fairreckitlib.model.pipeline.recommendation_pipeline_elliot", "qualname": "RecommendationPipelineElliot.load_train_and_test_set", "type": "function", "doc": "<p>Load the train and test set that all models can use.</p>\n\n<p>The loading is done by the Elliot framework, delay until after it is done.</p>\n\n<p>Args:\n    train_set_path: path to where the train set is stored.\n    test_set_path: path to where the test set is stored.</p>\n", "signature": "(self, train_set_path: str, test_set_path: str) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.recommendation_pipeline_elliot.RecommendationPipelineElliot.train_and_test_model", "modulename": "src.fairreckitlib.model.pipeline.recommendation_pipeline_elliot", "qualname": "RecommendationPipelineElliot.train_and_test_model", "type": "function", "doc": "<p>Train and test the specified model.</p>\n\n<p>Convert the model configuration into a yml file that is accepted by the framework.\nFeed it to the framework to obtain results, clear unwanted artifacts and modify the\nratings file so that it conforms to the standard convention.</p>\n\n<p>Args:\n    model: the model that needs to be trained.\n    model_dir: the path of the directory where the computed ratings can be stored.\n    is_running: function that returns whether the pipeline\n        is still running. Stops early when False is returned.</p>\n\n<p>Keyword Args:\n    num_items(int): the number of item recommendations to produce.</p>\n\n<p>Returns:\n    the path to the file where the model's computed ratings are stored.</p>\n", "signature": "(\n    self,\n    model: src.fairreckitlib.model.algorithms.elliot.elliot_recommender.ElliotRecommender,\n    model_dir: str,\n    is_running: Callable[[], bool],\n    **kwargs\n) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.recommendation_pipeline_elliot.RecommendationPipelineElliot.clear_unused_epochs", "modulename": "src.fairreckitlib.model.pipeline.recommendation_pipeline_elliot", "qualname": "RecommendationPipelineElliot.clear_unused_epochs", "type": "function", "doc": "<p>Clear unused epochs from the model output directory.</p>\n\n<p>Recommenders with an 'epochs' parameter will generate computed ratings\nfor each epoch. Only the final epoch is needed.</p>\n\n<p>Args:\n    num_epochs: the number of epochs that was run by the algorithm.\n    model_dir: the directory where the computed ratings are stored.</p>\n", "signature": "(self, num_epochs: int, model_dir: str) -> None", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.recommendation_pipeline_elliot.RecommendationPipelineElliot.reconstruct_rank_column", "modulename": "src.fairreckitlib.model.pipeline.recommendation_pipeline_elliot", "qualname": "RecommendationPipelineElliot.reconstruct_rank_column", "type": "function", "doc": "<p>Reconstruct the rank column in the result file that the framework generated.</p>\n\n<p>Args:\n    model_dir: the directory where the computed ratings are stored.\n    top_k: the topK that was used to compute the ratings.</p>\n\n<p>Returns:\n    the path to the computed ratings file.</p>\n", "signature": "(self, model_dir: str, top_k: int) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.model.pipeline.recommendation_pipeline_elliot.RecommendationPipelineElliot.rename_result", "modulename": "src.fairreckitlib.model.pipeline.recommendation_pipeline_elliot", "qualname": "RecommendationPipelineElliot.rename_result", "type": "function", "doc": "<p>Rename the computed ratings file to be consistent with other pipelines.</p>\n\n<p>Args:\n    model_dir: the directory where the computed ratings are stored.</p>\n\n<p>Returns:\n    the file path of the result after renaming.</p>\n", "signature": "(model_dir: str) -> str", "funcdef": "def"}, {"fullname": "src.fairreckitlib.recommender_system", "modulename": "src.fairreckitlib.recommender_system", "type": "module", "doc": "<p>This module contains the FairRecKit recommender system.</p>\n\n<p>Classes:</p>\n\n<pre><code>RecommenderSystem: class that includes the entire recommender system.\n</code></pre>\n\n<p>This program has been developed by students from the bachelor Computer Science at\nUtrecht University within the Software Project course.\n\u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)</p>\n"}, {"fullname": "src.fairreckitlib.recommender_system.RecommenderSystem", "modulename": "src.fairreckitlib.recommender_system", "qualname": "RecommenderSystem", "type": "class", "doc": "<p>The FairReckit Recommender System.</p>\n\n<p>Defines the top level API intended for use by applications.</p>\n\n<p>Public methods:</p>\n\n<p>abort_computation\nrun_experiment\nrun_experiment_from_yml\nvalidate_experiment\nget_active_computations\nget_available_algorithms\nget_available_datasets\nget_available_data_filters\nget_available_metrics\nget_available_rating_converters\nget_available_splitters</p>\n"}, {"fullname": "src.fairreckitlib.recommender_system.RecommenderSystem.__init__", "modulename": "src.fairreckitlib.recommender_system", "qualname": "RecommenderSystem.__init__", "type": "function", "doc": "<p>Construct the RecommenderSystem.</p>\n\n<p>Initializes the data registry with available datasets on which the\nrecommender system depends. It raises an IOError when the specified\ndata directory does not exist. The result directory however is\ncreated when non-existing.</p>\n\n<p>Args:\n    data_dir: path to the directory that contains the datasets.\n    result_dir: path to the directory to store computation results.</p>\n", "signature": "(self, data_dir: str, result_dir: str)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.recommender_system.RecommenderSystem.abort_computation", "modulename": "src.fairreckitlib.recommender_system", "qualname": "RecommenderSystem.abort_computation", "type": "function", "doc": "<p>Attempt to abort a running computation thread.</p>\n\n<p>The name of the computation is the same as specified in the configuration\nfile when the computation is run. If the computation with the specified\nname does not exist this function returns False.\nNote that the computation is only requested to abort as soon as possible,\ntherefore it might take a while until the computation actually stops.</p>\n\n<p>Args:\n    computation_name: name of the active computation thread to abort.</p>\n\n<p>Returns:\n    whether the computation is successfully requested to abort.</p>\n", "signature": "(self, computation_name: str) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.recommender_system.RecommenderSystem.run_experiment", "modulename": "src.fairreckitlib.recommender_system", "qualname": "RecommenderSystem.run_experiment", "type": "function", "doc": "<p>Run an experiment with the specified configuration.</p>\n\n<p>It is advised to validate the configuration (default) before running the\nexperiment, to make sure the configuration describes a valid experiment.\nThe configuration is invalid when it contains no selected datasets or\nmodels, only the evaluation is optional. If the configuration is invalidated\nthis function will return False.</p>\n\n<p>This functions raises an IOError when the result already exists or a TypeError\nwhen the provided configuration is not a valid experiment configuration.\nLastly a KeyError is raised when a computation with the same name is already active.</p>\n\n<p>Args:\n    events: the external events to dispatch during the experiment.\n    config: the configuration of the experiment.\n    num_threads: the max number of threads the experiment can use.\n    verbose: whether the internal events should give verbose output.\n    validate_config: whether to validate the configuration beforehand.</p>\n\n<p>Returns:\n    whether the experiment successfully started.</p>\n", "signature": "(\n    self,\n    config: Union[src.fairreckitlib.experiment.experiment_config.PredictorExperimentConfig, src.fairreckitlib.experiment.experiment_config.RecommenderExperimentConfig],\n    *,\n    events: Dict[str, Callable[[Any], NoneType]] = None,\n    num_threads: int = 0,\n    verbose: bool = True,\n    validate_config: bool = True\n) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.recommender_system.RecommenderSystem.run_experiment_from_yml", "modulename": "src.fairreckitlib.recommender_system", "qualname": "RecommenderSystem.run_experiment_from_yml", "type": "function", "doc": "<p>Run an experiment from a yml file.</p>\n\n<p>The configuration in the file is validated before starting the experiment.\nIt is invalid when it contains no selected datasets or models,\nonly the evaluation is optional.  If the configuration is invalidated\nthis function will return False.</p>\n\n<p>This function raises a FileNotFoundError when the specified yml file\nis not found or an IOError when the result already exists. Lastly a KeyError\nis raised when a computation with the same name is already active.</p>\n\n<p>Args:\n    events: the external events to dispatch during the experiment.\n    file_path: path to the yml file without extension.\n    num_threads: the max number of threads the experiment can use.\n    verbose: whether the internal events should give verbose output.</p>\n\n<p>Returns:\n    whether the experiment successfully started.</p>\n", "signature": "(\n    self,\n    file_path: str,\n    *,\n    events: Dict[str, Callable[[Any], NoneType]] = None,\n    num_threads: int = 0,\n    verbose: bool = True\n) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.recommender_system.RecommenderSystem.validate_experiment", "modulename": "src.fairreckitlib.recommender_system", "qualname": "RecommenderSystem.validate_experiment", "type": "function", "doc": "<p>Validate an experiment for an additional number of runs.</p>\n\n<p>The configuration file is expected to be stored in the specified result directory.\nMoreover, the configuration is validated before starting the experiment validation.\nIf the configuration is invalidated this function will return False.</p>\n\n<p>This functions raises an IOError when the result already exists or\na FileNotFoundError when the configuration file was not found in the\nspecified result directory. Lastly a KeyError is raised when a computation\nwith the same name is already active, meaning it is not possible to validate\nan active experiment computation until it is done.</p>\n\n<p>Args:\n    events: the external events to dispatch during the experiment.\n    result_dir: path to an existing experiment result directory.\n    num_runs: the number of runs to validate the experiment.\n    num_threads: the max number of threads the experiment can use.\n    verbose: whether the internal events should give verbose output.</p>\n\n<p>Returns:\n    whether the experiment successfully started.</p>\n", "signature": "(\n    self,\n    result_dir: str,\n    num_runs: int,\n    *,\n    events: Dict[str, Callable[[Any], NoneType]] = None,\n    num_threads: int = 0,\n    verbose: bool = True\n) -> bool", "funcdef": "def"}, {"fullname": "src.fairreckitlib.recommender_system.RecommenderSystem.get_active_computations", "modulename": "src.fairreckitlib.recommender_system", "qualname": "RecommenderSystem.get_active_computations", "type": "function", "doc": "<p>Get the names of any active computations.</p>\n\n<p>Returns:\n    a list of computations names that are currently running.</p>\n", "signature": "(self) -> List[str]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.recommender_system.RecommenderSystem.get_available_algorithms", "modulename": "src.fairreckitlib.recommender_system", "qualname": "RecommenderSystem.get_available_algorithms", "type": "function", "doc": "<p>Get the available algorithms of the recommender system.</p>\n\n<p>Args:\n    model_type: type of model to query for availability, accepted values are\n        TYPE_PREDICTION, TYPE_RECOMMENDATION or None.</p>\n\n<p>Returns:\n    a dictionary with the availability of algorithms categorized by API.</p>\n", "signature": "(self, model_type: str = None)", "funcdef": "def"}, {"fullname": "src.fairreckitlib.recommender_system.RecommenderSystem.get_available_datasets", "modulename": "src.fairreckitlib.recommender_system", "qualname": "RecommenderSystem.get_available_datasets", "type": "function", "doc": "<p>Get the available datasets of the recommender system.</p>\n\n<p>Returns:\n    a dictionary where the key corresponds to the dataset name and\n        the value corresponds to the matrix information dictionary.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.recommender_system.RecommenderSystem.get_available_data_filters", "modulename": "src.fairreckitlib.recommender_system", "qualname": "RecommenderSystem.get_available_data_filters", "type": "function", "doc": "<p>Get the available data filters of the recommender system.</p>\n\n<p>Returns:\n    a dictionary with the availability of data filters.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.recommender_system.RecommenderSystem.get_available_metrics", "modulename": "src.fairreckitlib.recommender_system", "qualname": "RecommenderSystem.get_available_metrics", "type": "function", "doc": "<p>Get the available metrics of the recommender system.</p>\n\n<p>Args:\n    eval_type(str): type of evaluation to query for availability, accepted values are\n        TYPE_PREDICTION, TYPE_RECOMMENDATION or None.</p>\n\n<p>Returns:\n    a dictionary with the availability of metrics categorized by evaluation type.</p>\n", "signature": "(self, eval_type: str = None) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.recommender_system.RecommenderSystem.get_available_rating_converters", "modulename": "src.fairreckitlib.recommender_system", "qualname": "RecommenderSystem.get_available_rating_converters", "type": "function", "doc": "<p>Get the available data rating converters of the recommender system.</p>\n\n<p>Returns:\n    a dictionary with the availability of rating converters.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}, {"fullname": "src.fairreckitlib.recommender_system.RecommenderSystem.get_available_splitters", "modulename": "src.fairreckitlib.recommender_system", "qualname": "RecommenderSystem.get_available_splitters", "type": "function", "doc": "<p>Get the available data splitters of the recommender system.</p>\n\n<p>Returns:\n    a dictionary with the availability of data splitters.</p>\n", "signature": "(self) -> Dict[str, Any]", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();